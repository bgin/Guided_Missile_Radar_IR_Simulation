<html><head><meta http-equiv="expires" content="Tue, 19 May 1998 01:00:00 GMT">
<meta name="htdig-keywords" content="MUDPACK:" multigrid="" software="" for="" elliptic="" partial="" differential="" equations="">
<title>MUDPACK: Multigrid Software for Elliptic Partial Differential Equations</title></head>

<body bgcolor="#ffffff">

<center>
<a name="beginning"><h2>MUDPACK: Multigrid Software for Elliptic Partial Differential Equations</h2></a>
<p>
(Fortran Code with OpenMP Directives for Shared Memory Parallelism)
</p><p>
by<br>
</p><p>
</p><p>
John C. Adams<br>
September 1999
</p><p>

<!--<a href="mailto:%20mudpack.john@earthlink.net">John C. 
Adams is Available for Consulting</a></p><p>
//-->

<img src="StackedGrid.gif" width="500" height="500">


</p></center> 
<p>

MUDPACK was first released in 1990, and has remained at version 5.0.1 the past 
five years.
It is a collection of portable, mostly Fortran 77 subprograms (the code also employs
a few Fortran 90 extensions).
Its purpose is the efficient solving of linear elliptic Partial Differential Equations 
(PDEs) -- both separable and nonseparable -- using multigrid iteration.
MUDPACK solvers can achieve parallel speedup via OpenMP directives in the 5.0.1 subroutines,
but the user will need to activate the directives by providing appropriate OpenMP compiler 
options when the library and application are built. Speedup is dependent on problem size 
and characteristics of the shared multi-processor platform where the code is compiled and run.
</p><p>
This description consists of the following parts: <br>
</p><p>
 1. <a href="#intro">Introduction</a>
</p><p>
 2. <a href="#special">Special Features</a>
</p><p>
 3. <a href="#descrip">Solver and Test Program Overview</a>
</p><p>
 4. <a href="#select">Solver Selection Flowchart</a>
</p><p>
 5. <a href="#parallel">Parallel Performance via OpenMP</a>
</p><p>
 6. <a href="#earlier">Information on Earlier Versions</a>
</p><p>
 7. <a href="#refer">and Multigrid References</a>
</p><p>
 8. <a href="#obtain">Obtaining MUDPACK Software</a>
</p><p>
 9. <a href="#acknow">Acknowledgements</a>
</p><p>

</p><h2>1. <a name="intro">Introduction</a></h2>
<p>
 MUDPACK is a collection of portable, Fortran 77 subprograms,
 with a few Fortran90 extensions, for efficiently solving linear elliptic 
 Partial  Differential Equations (PDEs) using multigrid iteration.
 The most frequent Fortran90 extension used is the DO-END DO loop.
 Users may compile with any Fortran90 compiler, but Fortran77 compilers
 usually accept the code without complaint.  In Fortran90 terminology,
 the source code is fixed-form, not free-form.
 OpenMP directives are included to enable
 shared memory parallelism.  The package
 was created to make multigrid iteration available in user friendly
 form.  The software is written in much the same format as the separable
 elliptic PDE package FISHPACK [5].
 It extends the domain of solvable
 problems to include both separable and nonseparable PDEs.  Detailed
 descriptions of earlier versions of MUDPACK are given [2,9].
</p><p>
 Multigrid iteration (see [13,14,16,18,19,21]) combines classical
 iterative techniques, such as Gauss-Seidel line or point relaxation,
 with subgrid refinement procedures to yield a method superior to the
 iterative techniques alone.  By iterating and transferring approximations
 and corrections at subgrid levels, a good initial guess and rapid
 convergence at the fine grid level can be achieved.  Multigrid iteration
 requires less storage and computation than direct methods for nonseparable
 elliptic PDEs (e.g., see [7]) and is competitive with direct methods such
 as cyclic reduction [5,15,25,26] for separable equations.  In particular,
 three-dimensional problems can often be handled at reasonable computational
 cost.  Achieving optimal multigrid performance requires hand-tailored
 coding for certain problems.  The generality of the equations solved by
 MUDPACK software may sometimes result in loss of efficiency.  It is hoped
 that this is compensated for by the package's ease of use, applicability
 to a wide range of real problems (including those typically encountered in
 the atmospheric sciences at NCAR [8,12]), and avoidance of repeated
 "re-inventions of the wheel."  Savings in human code development time
 can be at least as important as economic use of machine cycles.  With
 careful selection of relaxation and multigrid parameters, optimal performance
 can often be realized using MUDPACK software.  See [1,3,9,10] for a variety
 of problems where discretization level error (i.e., the same error that
 a direct method will produce) is reached in only one full multigrid cycle
 using MUDPACK solvers. Supercomputer performance from a decade ago [23]
 was measured with the examples in [1,7,9,10].
<hr>
</p><p>
</p><h2>2. <a name="special">Special Features</a></h2>
<p>
<b> * Solving Linear Elliptic PDEs in a Variety of Forms </b>
</p><p>
   These forms include real and complex, two- and three-dimensional,
   self-adjoint,  separable and nonseparable, and PDEs with cross
   derivative terms (see part 3 of this file).
</p><p>
<b> * Solving PDEs in Curvilinear Coordinate Systems </b>
</p><p>
   The solution regions are rectangular regions in the sense that the
   domain of each independent variable must be a bounded interval on
   the real line.  This means that curvilinear coordinate systems such
   as spherical or cylindrical coordinates are acceptable.  The codes
   are not restricted to Cartesian coordinates.
</p><p>
<b> * Generating Second- and Fourth-order Approximations </b>
</p><p>
   Standard second-order finite difference approximations are generated on
   uniform grids superimposed on the solution region.  These can be improved
   to fourth-order estimates using "deferred corrections" ([22,24]).
</p><p>
<b> * Handling of General Boundary Conditions </b>
</p><p>
   Any combination of periodic, specified (Dirichlet), and mixed
   derivative boundary conditions is allowed.  Some of the solvers
   allow oblique (non-normal) derivative boundary conditions.
</p><p>
<b> * Ease of Input of the Continuous Problem </b>
</p><p>
   User defined input subroutines are the mechanisms for passing
   PDE coefficients and boundary conditions.
</p><p>
<b> * Automatic Discretization of the Continuous Problem </b>
</p><p>
   The discretization is transparent to a user who only needs to supply
   the PDE, boundary conditions, and grid size information.  Standard
   second-order finite difference formula are used to approximate first
   and second partial derivatives.  The result is a linear block tridiagonal
   system of equations.  More complex difference formula (asymmetric
   near boundaries [4]) are used with the fourth-order solvers.  The
   coefficients multiplying the second partial derivatives in the PDE
   are adjusted during discretization at coarser grid levels if there
   are nonzero first-order coefficients which would destroy diagonal
   dominance. This is necessary to preserve convergence of iterative
   schemes.
</p><p>
<b> * Use of Multigrid Iteration to Approximate the Discretization Equations </b>
</p><p>
   This is the essential feature of the MUDPACK software.  It makes this
   complex collection of integrated numerical procedures available in
   friendly form.
</p><p>
<b> * Flexibility in Choosing Grid Size  </b>
</p><p>
   Second and fourth order approximations are generated on uniform
   l by m by n  grids superimposed on boxes in three dimensions
   or l by m grids superimposed on rectangles in two dimensions.
   The grid sizes have the form:
</p><p>
     l = p * 2<sup>(i-1)</sup>  + 1
</p><p>
     m = q * 2<sup>(j-1)</sup>  + 1
</p><p>
     n = r * 2<sup>(k-1)</sup>  + 1
</p><p>
   where p,q,r,i,j,k are positive integers.  i,j,k &gt; 0 determine the
   number and size of the subgrid levels employed by multigrid cycling.
   Values for p,q,r should be chosen as small as possible (typically
   2,3 or 5) and values for i,j,k as large as possible within grid size
   requirements for efficient cycling.  In particular, larger values for
   p,q or r can cause cause algorithm deterioration.  For 2-d and 3-d
   nonseparable PDEs this can be bypassed by using one of the "hybrid"
   solvers described below.
</p><p>
   Let G denote the finest l by m by n grid.  In MUDPACK, multigrid cycling
   is implemented on the ascending chain of grids
</p><p>
	  G(1) &lt; ... &lt; G(s) &lt; ... &lt; G(t) = G
</p><p>
   where t = max0(i,j,k) and each G(s) (s=1,...,t) has
   l(s) by m(s) by n(s) grid points given by:
</p><p>
	  l(s) = p * 2<sup>max0(i+s-t,1)</sup>  + 1
</p><p>
	  m(s) = q * 2<sup>max0(j+s-t,1)</sup>  + 1
</p><p>
	  n(s) = r * 2<sup>max0(k+s-t,1)</sup>  + 1
</p><p>
   When grid size requirements cannot be met with MUDPACK software (even
   with one of the hybrid solvers described below) then one option is to
   choose a grid which does satisfy the constraints which is as close
   as possible to the required grid and solve the problem there.  The
   approximation can then be transferred to the required grid using
   multidimensional cubic interpolation.
</p><p>
<b> * Selection of Multigrid Options </b>
</p><p>
   MUDPACK has options for implementing
   variants of multigrid iteration and default options for those preferring
   black box solvers. The default options (chosen for robustness) set cubic
   prolongation, fully weighted residual restriction, and W(2,1) cycling.
   The earlier version of MUDPACK described in [2,3] only allowed V(2,1)
   cycling with linear prolongation.  This is still available as a possibly
   more efficient choice for certain problems.
</p><p>
<b> * Selection of the Relaxation Method used within Multigrid Iteration </b>
</p><p>
   A relaxation menu is provided.  It includes vectorized Gauss-Seidel
   schemes [17] on alternating points (red/black), lines (in any combination
   of directions) and planes (for three-dimensional anisotropic elliptic
   PDEs [27]).  Choice of the correct relaxation method for a particular
   problem can be crucial.  It depends on the relative grid and PDE
   coefficient size.  Usually this can be pre-determined.  Sometimes
   experimentation is required.  Advice on method selection is given in the
   documentation.
</p><p>
<b> * Availability of "hybrid" Multigrid/Direct Method Solvers </b>
</p><p>
   The certainty of direct methods is combined with the efficiency of
   multigrid iteration by providing "hybrid" solvers for 2-d and 3-d
   nonseparable PDEs.  Gaussian elimination is used whenever the coarsest
   grid is encountered within multigrid cycling.  This eliminates the
   usual constraint that the coarsest grid must have "few" points
   thus giving additional flexibility in choosing grid size.  It also
   provides a way to compare approximations from multigrid and direct
   method solutions.  The hybrid codes become full direct method solvers
   replacing the codes described in [6] if grid size arguments are
   chosen so that the coarse and fine grids coincide.  Large storage
   and computational requirements make the use of the 3-d hybrid codes
   <b>muh3,cuh3</b> as direct methods
   possible only for very coarse grids.
</p><p>
<b> * Availability of Subroutines to Compute Residuals </b>
</p><p>
   Subroutines to compute fine grid residual after calling any of the
   second-order solvers are provided.  The residual measures how well the
   current approximation satisfies the linear system of equations coming
   from the discretization.  Residual ratios can be used to estimate the
   convergence rate of multigrid iteration.
</p><p>
<b> * No Initial Guess Requirement</b>
</p><p>
   Unlike the case with classical iterative schemes, initial guesses
   are not necessary and should not be supplied unless they are very
   good (as, for example, when restarting multigrid iteration using an
   approximation generated earlier).  Full multigrid cycling [13], beginning
   at the coarsest grid level, is used when there is no initial guess.
   Advice on how to use initial guesses within a time marching problem is
   given in the documentation.
</p><p>
<b> * Non-initialization Calls </b>
</p><p>
   Redundant discretization and matrix factorization processes can (and
   should) be bypassed on recalls to the software.  For example, this happens
   when only the right-hand side array has changed from a previous call or
   when more multigrid cycles are needed for additional accuracy.
</p><p>
<b> * Error Control </b>
</p><p>
   Maximum relative error can be used to monitor convergence.  Use of error
   control is optional and requires additional storage and computation.
</p><p>
<b> * Flagging of Errors involving Input Parameters</b>
</p><p>
   This includes detection of singular and/or nonelliptic PDEs.  Fatal
   and nonfatal errors are flagged.
</p><p>
<b> * Output of Exact Minimal Work Space Requirements </b>
</p><p>
   This is especially important with three-dimensional problems where
   central memory is easily exhausted.
</p><p>
<b> * Extensive Documentation and Test Programs</b>
</p><p>
   Users are encouraged to carefully read the documentation
   and execute the test program for the solver to be used.
   The next section provides links to documentation and
   fortran test program files.
</p><p>
</p><p>
</p><p>
<hr>
</p><h2>3. <a name="descrip">Solver and Test Program Overview</a></h2>
<p>
Table 1 below lists all mudpack two- and three-dimensional, second and fourth order solvers
for real and complex elliptic partial differential equations with and without
cross derivative terms.  Clicking on a solver will bring up its documentation
file.</p>
<p>Table 2 provides a list of the test and residual codes for each solver.
These codes are meant as tests but also as example codes in guiding users through 
the setup and calling of MUDPACK routines in their own applications.
</p><p>
</p><center>
<table border="1">
<tbody><tr>
<th colspan="2"><center>Table 1 <br>
An overview of MUDPACK solvers </center>
</th><th>
</th></tr><tr>
<th>computation
</th><th>subprograms
</th></tr><tr>
<td>2nd order/real 2D self-adjoint nonseparable
</td><td><a href="#mud2sa.txt">mud2sa</a>
</td></tr><tr>
<td>2nd order/real 2D separable
</td><td><a href="#mud2sp.txt">mud2sp</a>
</td></tr><tr>
<td>2nd order/real 2D nonseparable
</td><td><a href="#muh2.txt">muh2</a>,
<a href="#mud2.txt">mud2</a>
</td></tr><tr>
<td>2nd order/real 2D with cross term
</td><td><a href="#muh2cr.txt">muh2cr</a>,
<a href="#mud2cr.txt">mud2cr</a>
</td></tr><tr>
<td>4th order/real 2D separable
</td><td><a href="#mud24sp.txt">mud24sp</a>
</td></tr><tr>
<td>4th order/real 2D nonseparable
</td><td><a href="#muh24.txt">muh24</a>,
<a href="#mud24.txt">mud24</a>
</td></tr><tr>
<td>4th order/real 2D with cross term
</td><td><a href="#muh24cr.txt">muh24cr</a>,
<a href="#mud24cr.txt">mud24cr</a>
</td></tr><tr>
<td>2nd order/real 3D self-adjoint nonseparable
</td><td><a href="#mud3sa.txt">mud3sa</a>
</td></tr><tr>
<td>2nd order/real 3D separable
</td><td><a href="#mud3sp.txt">mud3sp</a>
</td></tr><tr>
<td>2nd order/real 3D nonseparable
</td><td><a href="#muh3.txt">muh3</a>,
<a href="#mud3.txt">mud3</a>
</td></tr><tr>
<td>2nd order/real 3D with cross term
</td><td><a href="#mud3cr.txt">mud3cr</a>
</td></tr><tr>
<td>4th order/real 3D separable
</td><td><a href="#mud34sp.txt">mud34sp</a>
</td></tr><tr>
<td>4th order/real 3D nonseparable
</td><td><a href="#mud34.txt">mud34</a>,
<a href="#muh34.txt">muh34</a>
</td></tr><tr>
<td>2nd order/complex 2D separable
</td><td><a href="#cud2sp.txt">cud2sp</a>
</td></tr><tr>
<td>2nd order/complex 2D nonseparable
</td><td><a href="#cuh2.txt">cuh2</a>,
<a href="#cud2.txt">cud2</a>
</td></tr><tr>
<td>2nd order/complex 2D with cross term
</td><td><a href="#cuh2cr.txt">cuh2cr</a>,
<a href="#cud2cr.txt">cud2cr</a>
</td></tr><tr>
<td>4th order/complex 2D separable
</td><td><a href="#cud24sp.txt">cud24sp</a>
</td></tr><tr>
<td>4th order/complex 2D nonseparable
</td><td><a href="#cud24.txt">cud24</a>,
<a href="#cuh24.txt">cuh24</a>
</td></tr><tr>
<td>4th order/complex 2D with cross term
</td><td><a href="#cud24cr.txt">cud24cr</a>,
<a href="#cuh24cr.txt">cuh24cr</a>
</td></tr><tr>
<td>2nd order/complex 3D separable
</td><td><a href="#cud3sp.txt">cud3sp</a>
</td></tr><tr>
<td>2nd order/complex 3D nonseparable
</td><td><a href="#cuh3.txt">cuh3</a>,
<a href="#cud3.txt">cud3</a>
</td></tr><tr>
<td>2nd order/complex 3D with cross term
</td><td><a href="#cud3cr.txt">cud3cr</a>
</td></tr><tr>
<td>4th order/complex 3D separable
</td><td><a href="#cud34sp.txt">cud34sp</a>
</td></tr><tr>
<td>4th order/complex 3D nonseparable
</td><td><a href="#cud34.txt">cud34</a>
</td></tr></tbody></table>
</center>
<p>
</p><center>
<table border="1">
<tbody><tr>
<th colspan="2"><center>Table 2 <br>
</center></th><th>
</th></tr><tr>
<th><b>solver</b>
</th><th>test &amp; residual codes
</th></tr><tr>
<td><b>mud2sa<b>
</b></b></td><td><a href="#tmud2sa.txt">tmud2sa</a>
</td></tr><tr>
<td><b>mud2sp<b>
</b></b></td><td><a href="#tmud2sp.txt">tmud2sp</a>,
<a href="#resm2sp.txt">resm2sp</a>
</td></tr><tr>
<td><b>mud2,muh2</b>
</td><td><a href="#tmud2.txt">tmud2</a>,
<a href="#tmuh2.txt">tmuh2</a>,
<a href="#resm2.txt">resm2</a>
</td></tr><tr>
<td><b>mud2cr,muh2cr</b>
</td><td><a href="#tmud2cr.txt">tmud2cr</a>,
<a href="#tmuh2cr.txt">tmuh2cr</a>,
<a href="#resm2.txt">resm2cr</a>
</td></tr><tr>
<td><b>mud24sp</b>
</td><td><a href="#tmud24sp.txt">tmud24sp</a>
</td></tr><tr>
<td><b>mud24,muh24</b>
</td><td><a href="#tmud24.txt">tmud24</a>,
<a href="#tmuh24.txt">tmuh24</a>
</td></tr><tr>
<td><b>mud24cr,muh24cr</b>
</td><td><a href="#tmud24cr.txt">tmud24cr</a>,
<a href="#tmuh24cr.txt">tmuh24cr</a>
</td></tr><tr>
<td><b>mud3sa<b>
</b></b></td><td><a href="#tmud3sa.txt">tmud3sa</a>
</td></tr><tr>
<td><b>mud3sp</b>
</td><td><a href="#tmud3sp.txt">tmud3sp</a>,
<a href="#resm3sp.txt">resm3sp</a>
</td></tr><tr>
<td><b>mud3,muh3</b>
</td><td><a href="#tmud3.txt">tmud3</a>,
<a href="#tmuh3.txt">tmuh3</a>,
<a href="#resm3.txt">resm3</a>
</td></tr><tr>
<td><b>mud3cr</b>
</td><td><a href="#tmud3cr.txt">tmud3cr</a>
</td></tr><tr>
<td><b>mud34sp</b>
</td><td><a href="#tmud34sp.txt">tmud34sp</a>
</td></tr><tr>
<td><b>mud34,muh34</b>
</td><td><a href="#tmud34.txt">tmud34</a>,
<a href="#tmuh34.txt">tmuh34</a>
</td></tr><tr>
<td><b>cud2sp</b>
</td><td><a href="#tcud2sp.txt">tcud2sp</a>,
<a href="#resc2sp.txt">resc2sp</a>
</td></tr><tr>
<td><b>cud2,cuh2</b>
</td><td><a href="#tcud2.txt">tcud2</a>,
<a href="#tcuh2.txt">tcuh2</a>,
<a href="#resc2.txt">resc2</a>
</td></tr><tr>
<td><b>cud2cr,cuh2cr</b>
</td><td><a href="#tcud2cr.txt">tcud2cr</a>,
<a href="#tcuh2cr.txt">tcuh2cr</a>,
<a href="#resc2cr.txt">resc2cr</a>
</td></tr><tr>
<td><b>cud24sp</b>
</td><td><a href="#tcud24sp.txt">tcud24sp</a>
</td></tr><tr>
<td><b>cud24,cuh24</b>
</td><td><a href="#tcud24.txt">tcud24</a>,
<a href="#tcuh24.txt">tcuh24</a>
</td></tr><tr>
<td><b>cud24cr,cuh24cr</b>
</td><td><a href="#tcud24cr.txt">tcud24cr</a>,
<a href="#tcuh24cr.txt">tcuh24cr</a>
</td></tr><tr>
<td><b>cud3sp</b>
</td><td><a href="#tcud3sp.txt">tcud3sp</a>,
<a href="#resc3sp.txt">resc3sp</a>
</td></tr><tr>
<td><b>cud3,cuh3</b>
</td><td><a href="#tcud3.txt">tcud3</a>,
<a href="#tcuh3.txt">tcuh3</a>,
<a href="#resc3.txt">resc3</a>
</td></tr><tr>
<td><b>cud34sp</b>
</td><td><a href="#tcud34sp.txt">tcud34sp</a>
</td></tr><tr>
<td><b>cud34</b>
</td><td><a href="#tcud34.txt">tcud34</a>
</td></tr></tbody></table>
</center>
<p>
<hr>
</p><h2>4. <a name="select">Solver Selection</a></h2>
<p>
    The following "flow chart" can be used in selecting the appropriate
    second-order software for the elliptic PDE to be solved:
</p><p>
    (1)  If the PDE is complex go to (9) else go to (2)
</p><p>
    (2)  If the PDE is three-dimensional go to (6) else go to (3)
</p><p>
    (3)  If the PDE is separable use <b>mud2sp</b> else go to (4)
</p><p>
    (4)  If the PDE has a cross derivative use <b>muh2cr</b> or <b>mud2cr</b> else go to (5)
</p><p>
    (5)  If the PDE is self-adjoint use <b>mud2sa</b> else use <b>muh2</b> or <b>mud2</b>.
</p><p>
    (6)  If the PDE is separable use <b>mud3sp</b> else go to (7)
</p><p>
    (7)  If the PDE is self-adjoint use <b>mud3sa</b> else go to (8)
</p><p>
    (8)  If the PDE has cross derivatives use <b>mud3cr</b> else use <b>muh3</b> or <b>mud3</b>.
</p><p>
    (9)  If the PDE is three dimensional go to (13) else go to (10)
</p><p>
    (10) If the PDE is separable use <b>cud2sp</b> else go to (11)
</p><p>
    (11)  If the PDE has a cross derivative use <b>cuh2cr</b> or <b>cud2cr</b> else go to (12)
</p><p>
    (12)  Use <b>cuh2</b> or <b>cud2</b>
</p><p>
    (13) If the PDE is separable use <b>cud3sp</b> else use <b>cuh3</b> or <b>cud3</b>.
</p><p>
    Fourth-order solvers can improve the approximation if the corresponding
    second-order solver has reached discretization level error (i.e., the
    same error level that a direct method will reach) [1,3,10].
</p><p>
<hr>

</p><h2>5. <a name="parallel">Parallel Performance via OpenMP</a></h2>

<p>
In single processor mode, the openMP statements in version 5.0.1 of 
MUDPACK are interpreted as comment cards not affecting execution.  
To ensure this is the case, users should check that their compilers 
do not recognize OpenMP directives by default.
If this is the case, the directives can be turned off with compiler flags
or removed by passing MUDPACK source code through an
appropriate sed or awk script which removes lines beginning with C$OMP.
<p>
Parallel performance was measured on
on a Cray J9, a SGI Origin, and a two processor IBM SP computer,
using the three MUDPACK solvers <b>mud2, mud3,</b> and<b> mud3cr</b>.
The tables below record measured wall clock time in seconds
for an increasing number of processors,<b> mp</b>.
For each example and grid size, either
the least expensive relaxation method (point relaxation
with 5 multigrid cycles)
or the more expensive and robust relaxation method (line relaxations
in all directions with 3 multigrid cycles) is executed.
This is typical of the amount of computation needed to solve elliptic
problems with the numerical methods embedded in MUDPACK.
<p>
The second example illustrates that the cost overhead for parallelization
of medium resolution two-dimensional problems can cancel any advantage
gained by selecting more than one processor.  Once
a resolution is chosen, some preliminary timings should be made before
using a MUDPACK solver with more than one processor.
<p>
<p>
<b> Example 1</b>: (513 X 769 grid)  executing
3 multigrid cycles using bi-directional line
relaxations with the multigrid solver <b>mud2</b>.
<p>
<center>
<table border=1>
<tr>
<th colspan=2>Cray J9 <br><th colspan=2>SGI Origin <br> <th colspan=2>IBM SP <br>
<tr>
<th>time
<th>mp
<th>time
<th>mp
<th>time
<th>mp
<tr>
<td>16.86
<td>1
<td> 8.78
<td>1
<td> 9.93
<td>1
<tr>
<td>9.76
<td>2
<td> 6.88
<td>2
<td> 5.61
<td>2
<tr>
<td>6.46
<td>4
<td> 5.29
<td>4
<tr>
<td>5.33
<td>8
<td> 4.30
<td>8
<tr>
<td>3.90
<td>16
<td> 3.89
<td>16
<tr>
</table>
</center>
<p>
<p>
<b> Example 2</b>: (257 X 193 grid)  executing
5 multigrid cycles using red/black Gauss-Seidel
point relaxation with the multigrid solver<b> mud2</b>.
<p>
<center>
<table border=1>
<tr>
<th colspan=2>Cray J9<br><th colspan=2>SGI Origin<br><th colspan=2>IBM SP <br>
<tr>
<th>time
<th>mp
<th>time
<th>mp
<th>time
<th>mp
<tr>
<td> 0.38
<td>1
<td> 0.27
<td>1
<td> 0.17
<td>1
<tr>
<td> 0.42
<td>2
<td> 0.49
<td>2
<td> 0.15
<td>2
<tr>
<td> 0.44
<td>4
<td> 0.95
<td>4
<tr>
<td> 0.44
<td>8
<td>0.99
<td>8
<tr>
<td> 0.45
<td>16
<td>1.16
<td>16
<tr>
</table>
</center>
<p>
<p>
<b> Example 3</b>: (95 X 65 X 129 grid)  executing
5 multigrid cycles using red/black Gauss-Seidel
point relaxation with the multigrid solver <b>mud3</b>.
<p>
<center>
<table border=1>
<tr>
<th colspan=2>Cray J9<br><th colspan=2>SGI Origin<br><th colspan=2>IBM SP <br>
<tr>
<th>time
<th>mp
<th>time
<th>mp
<th>time
<th>mp
<tr>
<td> 8.21
<td>1
<td> 9.83
<td>1
<td> 6.63
<td>1
<tr>
<td> 4.97
<td>2
<td> 8.46
<td>2
<td> 4.03
<td>2
<tr>
<td> 3.33
<td>4
<td> 5.17
<td>4
<tr>
<td> 2.62
<td>8
<td>4.22
<td>8
<tr>
<td> 2.54
<td>16
<td>3.13
<td>16
<tr>
</table>
</center>
<p>
<p>
<b> Example 4</b>: (49 X 257 X 49 grid)  executing
to a prescribed error tolerance
with point relaxation and then with
line relaxations in 3 directions with the
quasi-multigrid solver <b>mud3cr</b>
(see the documentation <b>mud3cr.d</b> and the test program <b>tmud3cr.f</b>
for a description of the problem approximated).
<p>
<center>
<table border=1>
<tr>
<th colspan=2>SGI Origin (point)<br> <th colspan=2>SGI Origin (lines)<br>
<tr>
<th>time
<th>mp
<th>time
<th>mp
<tr>
<td>39.6
<td>1
<td>74.2
<td>1
<tr>
<td>28.7
<td>2
<td>41.1
<td>2
<tr>
<td>12.0
<td>4
<td>26.8
<td>4
<tr>
<td>9.8
<td>8
<td>20.0
<td>8
<tr>
<td>8.9
<td>16
<td>15.7
<td>16
<tr>
</table>
</center>
<p>
<p><b>
<hr>
</p><h2>6. <a name="earlier">Information on Earlier Versions</a></h2></b>
<html>
<Head>
<body bgcolor="#FFFFFF">

<p>
The Fortran subroutines in MUDPACK discretize a variety of elliptic
Partial Differential Equations (PDEs) and boundary conditions using
finite difference formula on grids superimposed on the rectangular
solution regions.  Then multigrid iterative techniques are used
with point, line, or planar relaxation to generate second- and
fourth-order approximations to the underlying real and complex, two-
and three-dimensional continuous problems.
<p>
The MUDPACK software package includes 124 files containing over
100,000 lines of Fortran77 code and documentation. The code may
also be compiled with Fortran90 and 95 compilers, but you may need
to provide correct flags since the source code is fixed rather than
free source form.
<p>
The subroutine names, functionality, argument lists, test programs,
and documentation files for version 5.0.1 and version 5.0 of MUDPACK
are identical.  5.0.1 corrects an error in subroutine mud2sp, namely,
an incorrect call to routine rcd2spp is replaced by a call to rmd2spp.
<p><b>
VERSION 5.0.1 INCOMPATIBLE WITH VERSIONS EARLIER THAN 4.0
<p></b>
Version 5.0.1 of MUDPACK is the latest in a
series of major revisions since the software was first released in 1990.
Changes in argument lists, work space requirements, and file
organization make the current version incompatible with
versions of MUDPACK built before version 4.0.
The functionality has been expanded by adding
new solvers.  To ensure portability, all MUDPACK 5.0.1 software has been
passed through fortran verification software and compiled and executed
on different platforms with both fortran77 and fortran90 compilers.
<p><b>
OUTLINE OF MAJOR CHANGES BETWEEN VERSIONS 4.0 AND 5.0
</b>
<p>
(1) <b>Open MP directives</b>
<p>
Open MP directives have been inserted in the time critical
portions of each of 44 files within MUDPACK.
This was done for do loops where red/black Gauss-Seidel point, line,
and planar relaxation (for 3-d problems) are executed at different
grid levels and in loops where weighted residual restrictions occur.
The relaxation and residual restriction portion of multigrid codes
account for at least 90% of the execution time with most problems.
It was necessary to restructure line
relaxation kernels to allow more efficient parallelization when open
MP directives are inserted.  The changes did not adversely affect
single processor vector performance. See the parallel performance
tables above, on this page, for improvement measurements on a variety
of machines at the National Center for Atmospheric Research.

<p>
(2) <b>Code Simplification and modernization.</b>
<p>
Code simplification has been achieved by expanding internal arrays
to include virtual boundaries.  This has reduced the code complexity
required to handle the variety of boundary conditions MUDPACK software
allows.  Tests have indicated the resulting streamlining has yielded
a 10-30% speedup for a single processor depending on the problem and resolution.  Use of
equivalencing between arrays has been eliminated.  Statement labels
have been eliminated, all variable types declared, and nested loops
have been streamlined and indented.
<p>
(3) <b>Separation of discretization and approximation calls</b>
<p>
The first call to a solver discretizes the continuous elliptic
PDE and boundary conditions using standard second-order finite
difference formula. Afterwards, calls to generate approximations
can be made.  This is a natural separation analogous to separating
the LUD factorization and solution phase in matrix solvers.
Further it allows more appropriate efficiency monitoring
of MUDPACK software since the discretization phase is heavily
dependent upon user provided subroutines for inputing coefficients
and boundary conditions.  Only the approximation phase should
be monitored for efficiency.  Earlier versions of MUDPACK allowed
discretization and approximation to occur with the same call.
<p>
(4)<b>Simplification of multigrid options</b>
<p>
The variants in multigrid cycling have been simplified in version
5.0.  F cycling and unweighted or half weighted residual restriction
were deemed unnecessary and have been eliminated.  V cycles or W
cycles with fully weighted residual restriction are retained as
the optimal choices.  More general multigrid cycling is allowed
but flagged as a nonfatal error indicating probable inefficient
use of multigrid.  The prolongation operator can still be either
linear or cubic interpolation.
<p>
(5)<b>New three-dimensional solvers</b>
<p>
New "hybrid" three-dimensional multigrid/direct method solvers <b>muh3</b> and
<b>cuh3</b> along with a quasi-multigrid solver, <b>mud3cr</b>, for three-dimensional
problems with cross derivative terms and possibly oblique derivative
boundary have been added to the package.  Use of hybrid solvers for
nonsingular two- and three-dimensional problems is encouraged since they
can be more robust then their "multigrid only" counterparts and they cost
only marginally more in computation and storage.  The hybrid solvers
also provide more choices of grid resolution.
<p>
(6)<b>Four color relaxation</b>
<p>
Four color relaxation has replaced red/black relaxation for PDEs
with cross derivative terms.  This can provide better convergence
rates.
<p>
(7)<b>Correction in planar relaxation</b>
<p>
If planar relaxation is selected for three-dimensional anisotropic
PDEs then full two-dimensional multigrid cycling is implemented
for each plane visited during three dimensional multigrid cycling.
Earlier versions of MUDPACK did not use full two-dimensional cycling.
<p>
<hr>
</body>
</html>

</p><h2>7. <a name="refer">MUDPACK and Multigrid References</a></h2>
<p>
 [1] J. Adams, "Multigrid Software for Elliptic Partial Differential
 Equations: MUDPACK," NCAR Technical Note-357+STR, Feb. 1991, 51 pages.
</p><p>
 [2] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
 Solution of Linear Elliptic Partial Differential Equations,"
 Applied Math. and Comput. Vol.34, Nov 1989, pp.113-146.
</p><p>
 [3] J. Adams, "FMG Results with the Multigrid Software Package MUDPACK,"
 Proceedings of the Fourth Copper Mountain Conference on Multigrid, SIAM, 1989,
 pp.1-12.
</p><p>
 [4] J. Adams, "Fortran Subprograms for Finite Difference Formula,"
 J. Comp. Phys.,Vol 26, Jan 1978, pp. 113-116.
</p><p>
 [5] J. Adams, P. Swarztrauber, R. Sweet, "Efficient Fortran Subprograms
 for the Solution of Elliptic Partial Differential Equations,"
 Elliptic Problem Solvers, Academic Press, 1982, pp.333-390.
</p><p>
 [6] J. Adams, "New Software for Elliptic Partial Differential Equations,"
 Computing Facility Notes 55, November 1978
</p><p>
 [7] J. Adams, "Comparison of direct and iterative methods for approximating
 nonseparable elliptic PDEs at NCAR," SCD Computing News, Vol 10,
 Nov. 1989, pp.12-14.
</p><p>
 [8] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
 "Applications of Multigrid Software in the Atmospheric Sciences,"
  Monthly Weather Review,Vol. 120 # 7, July 1992, pp. 1447-1458.
</p><p>
 [9] J. Adams, "MUDPACK: Multigrid Software for Linear Elliptic Partial
 Differential Equations," SCD UserDoc, Version 2.0, NCAR,February 1990.
</p><p>
[10] J. Adams, "Recent Enhancements in MUDPACK, A Multigrid Software
 Package for Elliptic Partial Differential Equations," Applied Math.
 and Comp., Vol. 43, May 1991, pp.79-94.
</p><p>
[11] J. Adams, "MUDPACK-2: Multigrid Software for Elliptic Partial
Differential Equations on Uniform Grids with any Resolution," Applied. Math.
and Comp., Vol. 53, February 1993, pp. 235-249.
</p><p>
[12] J. Adams, and P. Smolarkiewicz, "Modified multigrid for 3D elliptic 
equations with cross derivatives", Applied Math. Comput., Vol. 121, 2001,
pp. 301-312.</p><p>
[13] A. Brandt, "Multi-level Adaptive Solutions to Boundary
 Value Problems," Math. Comp., 31, 1977, pp.333-390.
</p><p>
[14] W. Briggs, "A Multigrid Tutorial," SIAM, Philadelphia,1987.
</p><p>
[15] B. Buzbee, G. Golub, and C. Nielson, "On direct methods for solving
Poisson's equations," SIAM J. Numer. Anal., 7, 1970, pp.627-656.
</p><p>
[16] S. Fulton, R. Ciesielski, and W. Schubert, Multigrid methods for
elliptic problems:  a review.  Monthly Weather Review, 114:943-959 (1986).
</p><p>
[17] W. Gentzsch, "Vectorization of Computer Programs with Applications
to Computational Fluid Dynamics," Vieweg &amp; Sohn, 1984 (246 pages).
</p><p>
[18] W. Hackbush and U. Trottenberg, "Multigrid Methods,"
Springer-Verlag, Berlin,1982.
</p><p>
[19] D. Jespersen, "Multigrid Methods for Partial Differential
Equations." Studies in Numerical Analysis, Vol.24, MAA, 1984.
</p><p>
[20] J. Mandel and S, Parter, "On the Multigrid F-Cycle,"
Applied Math. and Comput., Vol 37, 1990, pp.19-36.
</p><p>
[21] S. McCormick, "Multigrid Methods," Vol 3 of SIAM Frontiers
Series, SIAM, Philadelphia, 1987.
</p><p>
[22] V. Pereyra, "Highly Accurate Numerical Solution of Casilinear
Elliptic Boundary-Value Problems in n Dimensions," Math. Comp., 24,
1970, pp.771-783.
</p><p>
[23] D. Sato, "PERFMON: The Cray Performance Monitor Utility,"
SCD UserDoc, Version 2.0, NCAR,March 1989.
</p><p>
[24] S. Schaffer, "Higher Order Multigrid Methods," Math. Comp.,
Vol 43, July 1984, pp. 89-115.
</p><p>
[25] P. Swarztrauber, "Fast Poisson Solvers,"  Studies in Numerical
Analysis, Math. Assoc, America, 1985, pp. 319-369.
</p><p>
[26] R. Sweet, "A Parallel and Vector Variant of the Cyclic Reduction
Algorithm," SIAM J. Sci. and Stat. Comp., Vol. 9, July 1988,
pp. 761-766.
</p><p>
[27] C. Thole and U. Trottenberg, "Basic Smoothing Procedures for
the Multigrid treatment of Elliptic 3D Operators," Applied Math.
and Comp., 19, 1986, pp. 333-345.
</p><p>
<hr>

</p><h2>8. <a name="obtain">Obtaining MUDPACK Software</a></h2>
<p>
 MUDPACK solver routines and test programs can be downloaded from 
the NCAR web page for MUDPACK. You will see a download tab on
that page.  When you click on it, you will be asked to agree to the
licensing terms for the package.
</p>
<hr>

</p><h2><b>9. <a name="acknow">Acknowledgements</a></b></h2>
<p>
Steve McCormick introduced the author to the multigrid community and provided
numerous helpful suggestions including the use of planar relaxation
with the three-dimensional solvers.  The importance of adjusting
discretization coefficients at coarser grid levels for PDEs with
nonzero first-order terms was pointed out by Klauss Steuben.  Achi Brandt
provided a complimentary foreword for the MUDPACK technical note [1].
A conversation with Achi Brandt affirmed that the default multigrid
options in MUDPACK are a good choice and that the use of deferred corrections
in obtaining fourth-order approximations with multigrid is a reasonable
strategy.  Dave Kennison, now retired, formerly of the NCAR graphics group 
provided the grid coarsening figure at the start of this document.
</p>
<hr>

<center>
<p><a href="#beginning"><h2>Return to beginning of this document</h2></a></p>
<p><h2>Text Below Contains Internal Files Referenced by Above Links</h2>
</center>

<a name="cud2.txt"><b>CUD2</b></a>
<PRE>
c
c     file cud2.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file cud2.d
c
c     contains documentation for:
c     subroutine cud2(iparm,fparm,work,coef,bndyc,rhs,phi,mgopt,ierror)
c     A sample fortran driver is file "tcud2.f".
c
c ... required MUDPACK files
c
c     cudcom.f
c
c ... purpose
c
c     subroutine cud2 automatically discretizes and attempts to compute
c     the second-order difference approximation to the complex 2-d
c     linear nonseparable elliptic partial differential equation on a
c     rectangle.  the approximation is generated on a uniform grid covering
c     the rectangle (see mesh description below).  boundary conditions
c     may be specified (dirchlet), periodic, or mixed derivative in any
c     combination.  the form of the pde solved is:
c
c
c          cxx(x,y)*pxx + cyy(x,y)*pyy + cx(x,y)*px + cy(x,y)*py +
c
c          ce(x,y)*p(x,y) = r(x,y).
c
c
c     pxx,pyy,px,py are second and first partial derivatives of the
c     unknown real solution function p(x,y) with respect to the
c     independent variables x,y.  cxx,cyy,cx,cy,ce are the known
c     complex coefficients of the elliptic pde and r(x,y) is the known
c     complex right hand side of the equation.  The real and imaginary
c     parts of cxx and cyy should be positive for all x,y in the solution
c     region.  Nonseparability means some of the coefficients depend on
c     both x and y.  Otherwise the PDE is separable and subroutine
c     cud2sp should be used instead of cud2
c                                                                               
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny grid.  the grid
c     is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1)
c
c     be the uniform grid increments in the x,y directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly
c
c     for i=1,...,nx and j=1,...,ny  denote the x,y uniform mesh points
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with Fortran77
c     and Fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 17 used to pass integer
c          arguments.  iparm is set internally and defined as
c          follows:
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      An approximation is NOT generated after an intl=0 call!
c          cud2 should be called with intl=1 to approximate the elliptic
c          PDE discretized by the intl=0 call.  intl=1 should also
c          be input if cud2 has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  This will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  Some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) cud2 is being recalled for additional accuracy.  In
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) cud2 is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) cud2 is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to cud2

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by coef (see below) have
c              changed since the previous call
c
c          (e) any of the "alfa" coefficients input by bndyc (see below)
c              have changed since the previous call.
c
c          If any of (a) through (e) are true then the elliptic PDE
c          must be discretized or rediscretized.  If none of (a)
c          through (e) holds, calls can be made with intl=1.
c          Incorrect calls with intl=1 will produce erroneous results.
c  ***     The values set in the saved work space "work" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the edge x=xa
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y
c            (if nxa=0 then nxb=0 is required, see ierror = 2)
c
c        = 1 if p(xa,y) is specified (this must be input thru phi(1,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see bndyc)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the edge x=xb
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y)
c            (if nxb=0 then nxa=0 is required, see ierror = 2)
c
c        = 1 if p(xb,y) is specified (this must be input thru phi(nx,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see bndyc)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the edge y=yc
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c            (if nyc=0 then nyd=0 is required, see ierror = 2)
c
c        = 1 if p(x,yc) is specified (this must be input thru phi(i,1))
c
c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see bndyc)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the edge y=yd
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c             (if nyd=0 then nyc=0 is required, see ierror = 2)
c
c        = 1 if p(x,yd) is specified (this must be input thru phi(i,ny))
c
c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see bndyc)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(6)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the x direction is not used.
c          if ixp > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of ixp can be removed by increasing iex = iparm(8)
c          without changing nx = iparm(10).
c
c
c ... jyq = iparm(7)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the y direction is not used.
c          if jyq > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of jyq can be removed by increasing jey = iparm(9)
c          without changing ny = iparm(11).
c
c
c ... iex = iparm(8)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx.
c
c
c ... jey = iparm(9)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(7)
c          as small as possible within grid size constraints when
c          defining ny.
c
c
c
c ... nx = iparm(10)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(6), iex = iparm(8).
c
c
c ... ny = iparm(11)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(7), jey = iparm(9).
c
c
c *** example
c
c         suppose a solution is wanted on a 33 by 97 grid.  then
c         ixp=2, jyq=6 and iex=jey=5 could be used.  a better
c         choice would be ixp=2, jyq=3, and iex=5, jey=6.
c
c
c *** note
c
c     let G be the nx by ny fine grid on which the approximation is
c     generated and let n = max0(iex,jey).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         G(1) < ... < G(k) < ... < G(n) = G.
c
c     each G(k) (k=1,...,n) has mx(k) by my(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c
c
c ... iguess=iparm(12)
c
c          = 0 if no initial guess to the pde is provided
c
c          = 1 if an initial guess to the pde is at the finest grid
c              level is provided in phi (see below)
c
c     comments on iguess = 0 or 1 . . .
c
c     even if iguess = 0, phi must be initialized at all grid points (this
c     is not checked).  phi can be set to 0.0 at non-dirchlet grid points
c     if nothing better is available.  the values set in phi when iguess = 0
c     are passed down and serve as an initial guess to the pde at the coarsest
c     grid level where cycling commences.  in this sense, values input in
c     phi always serve as an initial guess.  setting iguess = 0 forces full
c     multigrid cycling beginning at the coarsest and finishing at the finest
c     grid level.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c     time dependent problems . . .
c
c *** assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at nondirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(13)
c
c          the exact number of cycles executed between the finest (nx by
c          ny) and the coarsest ((ixp+1) by (jyq+1)) grid levels when
c          tolmax=fparm(5)=0.0 (no error control).  when tolmax > 0.0
c          is input (error control) then maxcy is a limit on the number
c          of cycles between the finest and coarsest grid levels.  in
c          any case, at most maxcy*(iprer+ipost) relaxation sweeps are
c          are performed at the finest grid level (see iprer=mgopt(2),
c          ipost=mgopt(3) below).  when multigrid iteration is working
c          "correctly" only a few are required for convergence.  large
c          values for maxcy should not be necessary.
c
c
c ... method = iparm(14) determines the method of relaxation
c              (gauss-seidel based on alternating points or lines)
c
c          = 0 for  point relaxation
c
c          = 1 for line relaxation in the x direction
c
c          = 2 for line relaxation in the y direction
c
c          = 3 for line relaxation in both the x and y direction
c
c
c *** choice of method. . .
c
c     let fx represent the quantity cabs(cxx(x,y))/dlx**2 over the solution region.
c
c     let fy represent the quantity cabs(cyy(x,y))/dly**2 over the solution region
c
c     if fx,fy are roughly the same size and do not vary too much over
c     the solution region choose method = 0.  if this fails try method=3.
c
c     if fx is much greater than fy choose method = 1.
c
c     if fy is much greater than fx choose method = 2
c
c     if neither fx or fy dominates over the solution region and they
c     both vary considerably choose method = 3.
c
c
c ... length = iparm(15)
c
c          the length of the complex work space provided in vector work (see below).
c          let isx = 0 if method = 0 or method = 2
c          let isx = 3 if method = 1 or method = 3 and nxa.ne.0
c          let isx = 5 if method = 1 or method = 3 and nxa.eq.0
c          let jsy = 0 if method = 0 or method = 1
c          let jsy = 3 if method = 2 or method = 3 and nyc.ne.0
c          let jsy = 5 if method = 2 or method = 3 and nyc.eq.0
c          then . . .
c
c               length = 4*[nx*ny*(10+isx+jsy)+8*(nx+ny+2)]/3
c
c          will suffice in most cases.  the exact minimal work space
c          length required for the current nx,ny and method is output
c          in iparm(16) (even if iparm(15) is too small).  this will be
c          less then the value given by the simplified formula above
c          in most cases.
c
c
c ... fparm                                                                     
c
c          a floating point vector of length 6 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in cud2 and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... tolmax = fparm(5)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j)
c          and phi2(i,j) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(cabs(phi2(i,j)-phi1(i,j))) for all i,j
c
c          and
c
c              phmax = max(cabs(phi2(i,j))) for all i,j
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(5)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible DO NOT use error control!).
c
c ... work                                                                      
c
c          a one dimensional complex saved work space (see iparm(15) for
c          length) which must be preserved from the previous call when
c          calling with intl=iparm(1)=1.
c
c ... bndyc                                                                     
c
c          a subroutine with  arguments (kbdy,xory,alfa,gbdy) which
c          are used to input mixed boundary conditions to cud2. bndyc
c          must be declared "external" in the program calling cud2.
c          the boundaries are numbered one thru four and the mixed
c          derivative boundary conditions are described below (see the
c          sample driver code "tcud2.f" for an example of how bndyc is
c          can beset up).
c                                                                               
c          * * * * * * * * * * * *  y=yd
c          *       kbdy=4        *
c          *                     *
c          *                     *
c          *                     *
c          * kbdy=1       kbdy=2 *
c          *                     *
c          *                     *
c          *                     *
c          *       kbdy=3        *
c          * * * * * * * * * * * *  y=yc
c
c          x=xa                  x=xb
c
c
c          (1) the kbdy=1 boundary
c
c          this is the edge x=xa where nxa=iparm(2)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dx + alfxa(y)*p(xa,y) = gbdxa(y)
c
c          in this case kbdy=1,xory=y will be input to bndyc and
c          alfa,gbdy corresponding to alfxa(y),gbdxa(y) must be returned.
c
c
c          (2) the kbdy=2 boundary
c
c          this is the edge x=xb where nxb=iparm(3)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dx + alfxb(y)*p(xb,y) = gbdxb(y)
c
c          in this case kbdy=2,xory=y, will be input to bndyc and
c          alfa,gbdy corresponding to alfxb(y),gbdxb(y) must be returned.
c
c
c          (3) the kbdy=3 boundary
c
c          this is the edge y=yc where nyc=iparm(4)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dy + alfyc(x)*p(x,yc) = gbdyc(x)
c
c          in this case kbdy=3,xory=x will be input to bndyc and
c          alfa,gbdy corresponding to alfyc(x),gbdyc(x) must be returned.
c
c
c          (4) the kbdy=4 boundary
c
c          this is the edge y=yd where nyd=iparm(5)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dy + alfyd(x)*p(x,yd) = gbdyd(x)
c
c          in this case kbdy=4,xory=x will be input to bndyc and
c          alfa,gbdy corresponding to alfyd(x),gbdyd(x) must be returned.
c
c                                                                               
c ***      bndyc must provide the mixed boundary condition values
c          in correspondence with those flagged in iparm(2) thru
c          iparm(5).  if all boundaries are specified or periodic
c          cud2 will never call bndyc.  even then it must be entered
c          as a dummy subroutine. bndyc must be declared "external"
c          in the routine calling cud2.  the actual name chosen may
c          be different.  alfxa,alfxb,alfyc,alfyd,gbdxa,gbdxb,gbdyc,
c          gbdyd must all be declared type complex.
c
c ... coef
c
c         a subroutine with arguments (x,y,cxx,cyy,cx,cy,ce) which
c         provides the known complex coefficients for the elliptic pde at
c         any real grid point (x,y).  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         "external."
c
c ... rhs                                                                       
c
c          a complex array dimensioned nx by ny which contains the given
c          right hand side values on the uniform 2-d mesh.
c
c              rhs(i,j) = r(xi,yj) for i=1,...,nx and j=1,...,ny
c
c ... phi                                                                       
c
c          a complex array dimensioned nx by ny.  on input phi must contain
c          specified boundary values. for example, if nyd=iparm(5)=1
c          then phi(i,ny) must be set equal to p(xi,yd) for i=1,...nx
c          prior to calling cud2.  these values are preserved by cud2.
c          if an initial guess is provided (iguess=iparm(11)=1) it must
c          be input thru phi.
c
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at all grid points (this is not checked).  these
c          values will serve as an initial guess to the pde at the coarsest
c          grid level after a transfer from the fine solution grid.  set phi
c          equal to to 0.0 at all internal and non-specified boundaries
c          grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid arguments (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the arguments
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).  all version 5.0.1
c     mudpack solvers use only fully weighted residual restriction
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---3-----3-----------3-----------------3---------------     level 1
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --6---6-------6---6-----------6---6-------6---6--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c
c **********************************************************************
c *** output arguments ************************************************
c **********************************************************************
c
c
c ... iparm(16)  *** set for intl=0 calls only
c
c          on output iparm(16) contains the actual complex work space length
c          required.  this will usually be less than that given by the
c          simplified formula for length=iparm(15) (see as input argument)
c
c
c ... iparm(17)  *** set for intl=1 calls only
c
c          on output iparm(17) contains the actual number of multigrid cycles
c          between the finest and coarsest grid levels used to obtain the
c          approximation when error control (tolmax > 0.0) is set.
c
c
c ... fparm(6)   *** set for intl=1 calls with fparm(5) > 0. only
c
c          on output fparm(6) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(6) is computed only if there is error control (tolmax > 0.0)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c               phdif = max(cabs(phi2(i,j)-phi1(i,j))) over all i,j
c
c          and
c
c               phmax = max(cabs(phi2(i,j)) over all i,j
c
c          then
c
c               fparm(6) = phdif/phmax
c
c          is returned whenever phmax > 0.0. in the degenerate case
c          phmax = 0.0, fparm(6) = phdif is returned.
c
c
c ... work
c
c          on output the complex space work contains intermediate values that
c          must not be destroyed if cud2 is to be called again with intl=1
c
c
c ... phi   *** for intl=1 calls only
c
c          on output phi(i,j) contains the approximation to p(xi,yj)
c          for all mesh points i = 1,...,nx and j=1,...,ny.  the last
c          computed iterate in phi is returned even if convergence is
c          not obtained
c
c
c ... ierror
c
c          For intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  Argument checking and discretization
c          is bypassed for intl=1 calls which can only return
c          ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              cabs(cx)*dlx > 2.*cabs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              cabs(cy)*dly > 2.*cabs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c
c             cxx = cmplx(0.5*cabs(cx)*dx,0.0)
c
c             cyy = cmplx(0.5*cabs(cy)*dy,0.0)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made when necessary to preserve convergence. if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-3  if the continuous elliptic pde is singular.  this means the
c          boundary conditions are periodic or pure derivative at all
c          boundaries and ce(x,y) =(0.0,0.0) for all x,y.  a solution is still
c          attempted but convergence may not occur due to ill-conditioning
c          of the linear system coming from the discretization.  the
c          ierror = -3 flag overrides the ierror=-4 and ierror=-5 nonfatal
c          flags.
c
c
c     =-2  if the pde is not elliptic
c
c             real(cxx)*real(cyy).le.0.0 or aimag(cxx)*aimag(cyy).le.0.0
c
c          in this case a solution is still attempted although convergence
c          may not occur due to ill-conditioning of the linear system.
c          the ierror = -2 flag overrides the ierror=-5,-4,-3 nonfatal
c          flags.
c
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd
c         in iparm(2),iparm(3),iparm(4),iparm(5) are not 0,1 or 2
c         or if nxa,nxb or nyc,nyd are not pairwise zero.
c
c     = 3 if mino(ixp,jyq) < 2 (ixp = iparm(6), jyq = iparm(7))
c
c     = 4 if min0(iex,jey) < 1 (iex = iparm(8), jey = iparm(9)) or
c         if max0(iex,jey) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or ny.ne.jyq*2**(jey-1)+1
c         (nx = iparm(10), ny = iparm(11))
c
c     = 6 if iguess = iparm(12) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(13) < 1
c
c     = 8 if method = iparm(14) is not 0,1,2, or 3
c
c     = 9 if length = iparm(15) is too small (see iparm(16) on output
c         for minimum required work space length)
c
c     =10 if xa > xb or yc > yd
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4))
c
c     =11 if tolmax = fparm(5) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(2) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c *********************************************************
c *********************************************************
c
c     end of cud2 documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="cud24.txt"><b>CUD24</b></a>
<PRE>
c
c     file cud24.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file cud24.d
c
c     contains documentation for subroutine cud24(work,phi,ierror)
c     A sample fortran driver is file "tcud24.f".
c
c ... required MUDPACK files
c
c     cud2.f, cudcom.f
c
c ... purpose
c
c     cud24 attempts to improve the estimate in phi, obtained by calling
c     cud2,  from second to fourth order accuracy.  see the file "cud2.d"
c     for a detailed discussion of the complex elliptic pde approximated and
c     arguments "work,phi" which are also part of the argument list for
c     cud2.
c
c ... assumptions
c
c     *  phi contains a second-order approximation from an earlier cud2 call
c
c     *  arguments "work,phi" are the same used in calling cud2
c
c     *  "work,phi" have not changed since the last call to cud2
c
c     *  the finest grid level contains at least 6 points in each direction
c
c
c *** warning
c
c     if the first assumption is not true then a fourth order approximation
c     cannot be produced in phi.  the last assumption (adequate grid size)
c     is the only one checked. failure in any of the others can result in
c     in an undetectable error.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections"
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... error argument
c
c     = 0 if no error is detected
c
c     = 30 if min0(nx,ny) < 6 where nx,ny are the fine grid sizes
c          in the x,y directions.
c                                                                               
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of cud24 documentation
c
c  ***********************************************************************
c  ***********************************************************************
c
</PRE>
<HR>
 
<a name="cud24cr.txt"><b>CUD24CR</b></a>
<PRE>
c
c     file cud24cr.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file cud24cr.d
c
c     contains documentation for:
c     subroutine cud24cr(work,coef,bndyc,phi,ierror)
c     A sample fortran driver is file "tcud24cr.f".
c
c ... required MUDPACK files
c
c     cud2cr.f, cudcom.f
c
c ... purpose
c
c     cud24cr attempts to improve the estimate in phi, obtained by calling
c     cud2cr,  from second to fourth order accuracy.  see the file "cud2cr.d"
c     for a detailed discussion of the elliptic pde approximated and
c     arguments "work,coef,bndyc,phi" which are also part of the argument
c     list for cud2cr
c
c ... assumptions
c
c     *  phi contains a second-order approximation from an earlier cud2cr call
c
c     *  arguments "work,coef,bndyc,phi" are the same used in calling cud2cr
c
c     *  "work,coef,bndyc,phi" have not changed since the last call to cud2cr
c
c     *  the finest grid level contains at least 6 points in each direction
c
c
c *** warning
c
c     if the first assumption is not true then a fourth order approximation
c     cannot be produced in phi.  the last assumption (adequate grid size)
c     is the only one checked. failure in any of the others can result in
c     in an undetectable error.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections"
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... error argument
c
c     = 0 if no error is detected
c
c     = 30 if min0(nx,ny) < 6 where nx,ny are the fine grid sizes
c          in the x,y directions.
c                                                                               
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of cud24cr documentation
c
c  ***********************************************************************
c  ***********************************************************************
c
</PRE>
<HR>
 
<a name="cud24sp.txt"><b>CUD24SP</b></a>
<PRE>
c
c     file cud24sp.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file cud24sp.d
c
c     contains documentation for subroutine cud24sp(work,phi,ierror)
c     A sample fortran driver is file "tcud24sp.f".
c
c ... required MUDPACK files
c
c     cud2sp.f, cudcom.f
c
c ... purpose
c
c     cud24sp attempts to improve the estimate in phi, obtained by calling
c     cud2sp,  from second to fourth order accuracy.  see the file "cud2sp.d"
c     for a detailed discussion of the complex elliptic pde approximated and
c     arguments "work,phi" which are also part of the argument list for
c     cud2sp.
c
c ... assumptions
c
c     *  phi contains a second-order approximation from an earlier cud2sp call
c
c     *  arguments "work,phi" are the same used in calling cud2sp
c
c     *  "work,phi" have not changed since the last call to cud2sp
c
c     *  the finest grid level contains at least 6 points in each direction
c
c
c *** warning
c
c     if the first assumption is not true then a fourth order approximation
c     cannot be produced in phi.  the last assumption (adequate grid size)
c     is the only one checked. failure in any of the others can result in
c     in an undetectable error.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections"
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... error argument
c
c     = 0 if no error is detected
c
c     = 30 if min0(nx,ny) < 6 where nx,ny are the fine grid sizes
c          in the x,y directions.
c                                                                               
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of cud24sp documentation
c
c  ***********************************************************************
c  ***********************************************************************
c
</PRE>
<HR>
 
<a name="cud2cr.txt"><b>CUD2CR</b></a>
<PRE>
c
c     file cud2cr.d
c
c  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
c  .                                                             .
c  .                  copyright (c) 2008 by UCAR                 .
c  .                                                             .
c  .       UNIVERSITY CORPORATION for ATMOSPHERIC RESEARCH       .
c  .                                                             .
c  .                      all rights reserved                    .
c  .                                                             .
c  .                                                             .
c  .                      MUDPACK version 5.0.1                  .
c  .                                                             .
c  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
c
c
c
c ... file cud2cr.d
c
c     contains documentation for the complex mudpack solver:
c     subroutine cud2cr(iparm,fparm,work,coef,bndyc,rhs,phi,mgopt,ierror)
c     a sample fortran driver is file "tcud2cr.f".
c
c ... required mudpack files
c
c     cudcom.f
c
c ... purpose
c
c     subroutine cud2cr automatically discretizes and attempts to compute
c     the second-order difference approximation to the complex 2-D
c     linear nonseparable elliptic partial differential equation with cross
c     derivative term on a rectangle.  the approximation is generated on a
c     uniform grid covering the rectangle (see mesh description below).
c     boundary conditions may be specified (dirchlet), periodic, or mixed
c     oblique derivative (see bndyc) in any combination.  the form of the pde
c     approximated is:
c
c
c          cxx(x,y)*pxx + cxy(x,y)*pxy + cyy(x,y)*pyy + cx(x,y)*px +
c
c          cy(x,y)*py + ce(x,y)*p(x,y) = r(x,y).
c
c
c     pxx,pxy,pyy,px,py are second and first partial derivatives of the
c     unknown complex solution function p(x,y) with respect to the
c     independent variables x,y.  cxx,cxy,cyy,cx,cy,ce are the known
c     complex coefficients of the elliptic pde and r(x,y) is the known
c     complex right hand side of the equation.  The real parts of cxx,cyy
c     or the imaginary parts of cxx,cyy should be positive for all x,y
c     in the solution region (see ierror=-2).  Nonseparability means some
c     of the coefficients depend on both x and y.  if the PDE is separable
c     and cxy = 0 then subroutine cud2sp should be used.
c                                                                               
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny grid.  the grid
c     is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1)
c
c     be the uniform grid increments in the x,y directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly
c
c     for i=1,...,nx and j=1,...,ny  denote the x,y uniform mesh points
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 17 used to pass integer
c          arguments.  iparm is set internally and defined as
c          follows:
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      an approximation is not generated after an intl=0 call!
c          cud2cr should be called with intl=1 to approximate the elliptic
c          pde discretized by the intl=0 call.  intl=1 should also
c          be input if cud2cr has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  this will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) cud2cr is being recalled for additional accuracy.  in
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) cud2cr is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) cud2cr is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to cud2cr

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by coef (see below) have
c              changed since the previous call
c
c          (e) any of the "alfa" coefficients input by bndyc (see below)
c              have changed since the previous call.
c
c          if any of (a) through (e) are true then the elliptic pde
c          must be discretized or rediscretized.  if none of (a)
c          through (e) holds, calls can be made with intl=1.
c          incorrect calls with intl=1 will produce erroneous results.
c  ***     the values set in the saved work space "work" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the edge x=xa
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y
c            (if nxa=0 then nxb=0 is required, see ierror = 2)
c
c        = 1 if p(xa,y) is specified (this must be input thru phi(1,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see bndyc)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the edge x=xb
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y)
c            (if nxb=0 then nxa=0 is required, see ierror = 2)
c
c        = 1 if p(xb,y) is specified (this must be input thru phi(nx,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see bndyc)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the edge y=yc
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c            (if nyc=0 then nyd=0 is required, see ierror = 2)
c
c        = 1 if p(x,yc) is specified (this must be input thru phi(i,1))
c
c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see bndyc)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the edge y=yd
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c             (if nyd=0 then nyc=0 is required, see ierror = 2)
c
c        = 1 if p(x,yd) is specified (this must be input thru phi(i,ny))
c
c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see bndyc)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(6)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the x direction is not used.
c          if ixp > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of ixp can be removed by increasing iex = iparm(8)
c          without changing nx = iparm(10).
c
c
c ... jyq = iparm(7)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the y direction is not used.
c          if jyq > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of jyq can be removed by increasing jey = iparm(9)
c          without changing ny = iparm(11).
c
c
c ... iex = iparm(8)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx.
c
c
c ... jey = iparm(9)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(7)
c          as small as possible within grid size constraints when
c          defining ny.
c
c
c
c ... nx = iparm(10)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(6), iex = iparm(8).
c
c
c ... ny = iparm(11)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(7), jey = iparm(9).
c
c
c *** example
c
c         suppose a solution is wanted on a 33 by 97 grid.  then
c         ixp=2, jyq=6 and iex=jey=5 could be used.  a better
c         choice would be ixp=2, jyq=3, and iex=5, jey=6.
c
c *** note
c
c     let g be the nx by ny fine grid on which the approximation is
c     generated and let n = max0(iex,jey).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         g(1) < ... < g(k) < ... < g(n) = g.
c
c     each g(k) (k=1,...,n) has mx(k) by my(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c
c
c ... iguess=iparm(12)
c
c          = 0 if no initial guess to the pde is provided
c
c          = 1 if an initial guess to the pde is at the finest grid
c              level is provided in phi (see below)
c
c     comments on iguess = 0 or 1 . . .
c
c     even if iguess = 0, phi must be initialized at all grid points (this
c     is not checked).  phi can be set to 0.0 at non-dirchlet grid points
c     if nothing better is available.  the values set in phi when iguess = 0
c     are passed down and serve as an initial guess to the pde at the coarsest
c     grid level where cycling commences.  in this sense, values input in
c     phi always serve as an initial guess.  setting iguess = 0 forces full
c     multigrid cycling beginning at the coarsest and finishing at the finest
c     grid level.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c     time dependent problems . . .
c
c *** assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at nondirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(13)
c
c          the exact number of cycles executed between the finest (nx by
c          ny) and the coarsest ((ixp+1) by (jyq+1)) grid levels when
c          tolmax=fparm(5)=0.0 (no error control).  when tolmax > 0.0
c          is input (error control) then maxcy is a limit on the number
c          of cycles between the finest and coarsest grid levels.  in
c          any case, at most maxcy*(iprer+ipost) relaxation sweeps are
c          are performed at the finest grid level (see iprer=mgopt(2),
c          ipost=mgopt(3) below).  when multigrid iteration is working
c          "correctly" only a few are required for convergence.  large
c          values for maxcy should not be necessary.
c
c
c ... method = iparm(14) determines the method of relaxation
c              (gauss-seidel based on alternating points or lines)
c
c          = 0 for  point relaxation
c
c          = 1 for line relaxation in the x direction
c
c          = 2 for line relaxation in the y direction
c
c          = 3 for line relaxation in both the x and y direction
c
c
c *** choice of method. . .
c
c     let fx represent the quantity cxx(x,y)/dlx**2 over the solution region.
c
c     let fy represent the quantity cyy(x,y)/dly**2 over the solution region
c
c     if fx,fy are roughly the same size and do not vary too much over
c     the solution region choose method = 0.  if this fails try method=3.
c
c     if fx is much greater than fy choose method = 1.
c
c     if fy is much greater than fx choose method = 2
c
c     if neither fx or fy dominates over the solution region and they
c     both vary considerably choose method = 3.
c
c
c ... length = iparm(15)
c
c          the length of the work space provided in complex work
c          space "work")
c
c          let isx = 0 if method = 0 or method = 2
c          let isx = 3 if method = 1 or method = 3 and nxa.ne.0
c          let isx = 5 if method = 1 or method = 3 and nxa.eq.0
c          let jsy = 0 if method = 0 or method = 1
c          let jsy = 3 if method = 2 or method = 3 and nyc.ne.0
c          let jsy = 5 if method = 2 or method = 3 and nyc.eq.0
c          then . . .
c
c           length = [7*(nx+2)*(ny+2)+4*(11+isx+jsy)*nx*ny]/3
c
c          will suffice in most cases.  the exact minimal work space
c          length required for the current nx,ny and method is output
c          in iparm(16) (even if iparm(15) is too small).  this will be
c          less then the value given by the simplified formula above
c          in most cases.
c
c
c ... fparm                                                                     
c
c          a floating point vector of length 6 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in cud2cr and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... tolmax = fparm(5)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j)
c          and phi2(i,j) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(abs(phi2(i,j)-phi1(i,j))) for all i,j
c
c          and
c
c              phmax = max(abs(phi2(i,j))) for all i,j
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(5)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible do not use error control!).
c
c ... work                                                                      
c
c          a complex saved work space (see iparm(15) for size) which
c          must be preserved from the previous call when calling with
c          intl=iparm(1)=1.
c
c ... bndyc                                                                     
c
c          a subroutine with  arguments (kbdy,xory,alfa,beta,gama,gbdy) which
c          are used to input mixed boundary conditions to cud2cr. bndyc
c          must be declared "external" in the program calling cud2cr.  kbdy
c          is type integer, xory real, and alfa,beta,gama,gbdy type complex.
c          the boundaries are numbered one thru four and the mixed
c          derivative boundary conditions are described below (see the
c          sample driver code "tcud2cr.f" for an example of how bndyc is
c          can beset up).
c                                                                               
c          * * * * * * * * * * * *  y=yd
c          *       kbdy=4        *
c          *                     *
c          *                     *
c          *                     *
c          * kbdy=1       kbdy=2 *
c          *                     *
c          *                     *
c          *                     *
c          *       kbdy=3        *
c          * * * * * * * * * * * *  y=yc
c
c          x=xa                  x=xb
c
c
c
c    (1)   the kbdy=1 boundary
c
c          this is the edge x=xa where nxa=iparm(2) = 2 flags
c          a mixed boundary condition of the form
c
c             alfxa(y)*px + betxa(y)*py + gamxa(y)*p(xa,y) = gbdxa(y)
c
c          in this case kbdy=1,xory=y will be input to bndyc and
c          alfa,beta,gama,gbdy corresponding to alfxa(y),betxa(y),gamxa(y),
c          gbdxa(y) must be returned.  alfxa(y) = 0. is not allowed for any y.
c          (see ierror = 13)
c
c    (2)   the kbdy=2 boundary
c
c          this is the edge x=xb where nxb=iparm(3) = 2 flags
c          a mixed boundary condition of the form
c
c             alfxb(y)*px + betxb(y)*py + gamxb(y)*p(xb,y) = gbdxb(y)
c
c          in this case kbdy=2,xory=y will be input to bndyc and
c          alfa,beta,gama,gbdy corresponding to alfxb(y),betxb(y),gamxb(y),
c          gbdxb(y) must be returned. alfxb(y) = 0.0 is not allowed for any y.
c          (see ierror = 13)
c
c    (3)   the kbdy=3 boundary
c
c          this is the edge y=yc where nyc=iparm(4) = 2 flags
c          a mixed boundary condition of the form
c
c             alfyc(x)*px + betyc(x)*py + gamyc(x)*p(x,yc) = gbdyc(x)
c
c          in this case kbdy=3,xory=x will be input to bndyc and
c          alfa,beta,gama,gbdy corresponding to alfyc(x),betyc(x),gamyc(x),
c          gbdyc(x) must be returned. betyc(x) = 0.0 is not allowed for any x.
c          (see ierror = 13)
c
c    (4)   the kbdy=4 boundary
c
c          this is the edge y=yd where nyd=iparm(5) = 2 flags
c          a mixed boundary condition of the form
c
c             alfyd(x)*px + betyd(x)*py + gamyd(x)*p(x,yd) = gbdyd(x)
c
c          in this case kbdy=4,xory=x will be input to bndyc and
c          alfa,beta,gama,gbdy corresponding to alfyd(x),betyd(x),gamyd(x),
c          gbdyd(x) must be returned. betyd(x) = 0.0 is not allowed for any x.
c          (see ierror = 13)
c
c                                                                               
c ***      bndyc must provide the mixed boundary condition values
c          in correspondence with those flagged in iparm(2) thru
c          iparm(5).  if all boundaries are specified or periodic
c          cud2cr will never call bndyc.  even then it must be entered
c          as a dummy subroutine. bndyc must be declared "external"
c          in the routine calling cud2cr.  the actual name chosen may
c          be different.
c
c
c ... coef
c
c         a subroutine with arguments (x,y,cxx,cxy,cyy,cx,cy,ce) which
c         provides the known complex coefficients for the elliptic pde at
c         any grid point (x,y).  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         "external."
c
c ... rhs                                                                       
c
c          a complex array dimensioned nx by ny which contains the given
c          right hand side values on the uniform 2-d mesh.
c
c              rhs(i,j) = r(xi,yj) for i=1,...,nx and j=1,...,ny
c
c ... phi                                                                       
c
c          a complex array dimensioned nx by ny.  on input phi must contain
c          specified boundary values. for example, if nyd=iparm(5)=1
c          then phi(i,ny) must be set equal to p(xi,yd) for i=1,...nx
c          prior to calling cud2cr.  these values are preserved by cud2cr.
c          if an initial guess is provided (iguess=iparm(11)=1) it must
c          be input thru phi.
c
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at all grid points (this is not checked).  these
c          values will serve as an initial guess to the pde at the coarsest
c          grid level after a transfer from the fine solution grid.  set phi
c          equal to to 0.0 at all internal and non-specified boundaries
c          grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid arguments (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the arguments
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).  all version 5.0.1
c     mudpack solvers use only fully weighted residual restriction
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---3-----3-----------3-----------------3---------------     level 1
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --6---6-------6---6-----------6---6-------6---6--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c
c **********************************************************************
c *** output arguments ************************************************
c **********************************************************************
c
c
c ... iparm(16)  *** set for intl=0 calls only
c
c          on output iparm(16) contains the actual work space length
c          required.  this will usually be less than that given by the
c          simplified formula for length=iparm(15) (see as input argument)
c
c
c ... iparm(17)  *** set for intl=1 calls only
c
c          on output iparm(17) contains the actual number of multigrid cycles
c          between the finest and coarsest grid levels used to obtain the
c          approximation when error control (tolmax > 0.0) is set.
c
c
c ... fparm(6)   *** set for intl=1 calls with fparm(5) > 0. only
c
c          on output fparm(6) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(6) is computed only if there is error control (tolmax > 0.0)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c               phdif = max(abs(phi2(i,j)-phi1(i,j))) over all i,j
c
c          and
c
c               phmax = max(abs(phi2(i,j)) over all i,j
c
c          then
c
c               fparm(6) = phdif/phmax
c
c          is returned whenever phmax > 0.0. in the degenerate case
c          phmax = 0.0, fparm(6) = phdif is returned.
c
c
c ... work
c
c          on output work contains intermediate values that must not
c          be destroyed if cud2cr is to be called again with intl=1
c
c
c ... phi   *** for intl=1 calls only
c
c          on output phi(i,j) contains the approximation to p(xi,yj)
c          for all mesh points i = 1,...,nx and j=1,...,ny.  the last
c          computed iterate in phi is returned even if convergence is
c          not obtained
c
c
c ... ierror
c
c          for intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  argument checking and discretization
c          is bypassed for intl=1 calls which can only return
c          ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              abs(cx)*dlx > 2.*abs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              abs(cy)*dly > 2.*abs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c
c             cxx = amax1(cxx,0.5*abs(cx)*dx)
c
c                          (and)
c
c             cyy = amax1(cyy,0.5*abs(cy)*dy)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made to preserve convergence of multigrid iteration. if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-3  if the continuous elliptic pde is singular.  this means the
c          boundary conditions are periodic or pure derivative at all
c          boundaries and ce(x,y) = 0.0 for all x,y.  a solution is still
c          attempted but convergence may not occur due to ill-conditioning
c          of the linear system coming from the discretization.  the
c          ierror = -3 flag overrides the ierror=-4 and ierror=-5 nonfatal
c          flags.
c
c
c     =-2  if the pde is not elliptic (i.e., cxx*cyy.le.0.0 for some (xi,yj))
c          in this case a solution is still attempted although convergence
c          may not occur due to ill-conditioning of the linear system.
c          the ierror = -2 flag overrides the ierror=-5,-4,-3 nonfatal
c          flags.
c
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd
c         in iparm(2),iparm(3),iparm(4),iparm(5) are not 0,1 or 2
c         or if nxa,nxb or nyc,nyd are not pairwise zero.
c
c     = 3 if mino(ixp,jyq) < 2 (ixp = iparm(6), jyq = iparm(7))
c
c     = 4 if min0(iex,jey) < 1 (iex = iparm(8), jey = iparm(9)) or
c         if max0(iex,jey) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or ny.ne.jyq*2**(jey-1)+1
c         (nx = iparm(10), ny = iparm(11))
c
c     = 6 if iguess = iparm(12) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(13) < 1
c
c     = 8 if method = iparm(14) is not 0,1,2, or 3
c
c     = 9 if length = iparm(15) is too small (see iparm(16) on output
c         for minimum required work space length)
c
c     =10 if xa >= xb or yc >= yd
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4))
c
c     =11 if tolmax = fparm(5) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(1) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c     =13 if there is a pure tangential derivative along a mixed derivative
c         boundary (e.g., nyd = 2 and betyd(x) = 0.0 for some
c         grid point x along y = yd)
c
c     =14 if there is the "singular" condition described below at a
c         cornor which is the intersection of two derivative boundaries.
c
c         (1) the cornor (xa,yc) if nxa=nyc=2 and
c             alfxa(yc)*betyc(xa)-alfyc(xa)*betxa(yc) = 0.0.
c
c         (2) the cornor (xa,yd) if nxa=nyd=2 and
c             alfxa(yd)*betyd(xa)-alfyd(xa)*betxa(yd) = 0.0.
c
c         (3) the cornor (xb,yc) if nxb=nyc=2 and
c             alfxb(yc)*betyc(xb)-alfyc(xb)*betxb(yc) = 0.0.
c
c         (4) the cornor (xb,yd) if nxb=nyd=2 and
c             alfxb(yd)*betyd(xb)-alfyd(xb)*betxb(yd) = 0.0.
c
c *** the conditions described in ierror = 13 or 14 will lead to division
c     by zero during discretization if undetected.
c
c
c *********************************************************
c *********************************************************
c
c     end of cud2cr documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="cud2sp.txt"><b>CUD2SP</b></a>
<PRE>
c
c     file cud2sp.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file cud2sp.d
c
c     contains documentation for:
c     subroutine cud2sp(iparm,fparm,work,cofx,cofy,bndyc,rhs,phi,mgopt,ierror)
c     A sample fortran driver is file "tcud2sp.f".
c
c ... required MUDPACK files
c
c     cudcom.f
c
c ... purpose
c
c     subroutine cud2sp automatically discretizes and attempts to compute
c     the second-order difference approximation to the complex two-dimensional
c     linear separable elliptic partial differential equation on a
c     rectangle.  the approximation is generated on a uniform grid covering
c     the rectangle (see mesh description below).  boundary conditions
c     may be specified (dirchlet), periodic, or mixed derivative in any
c     combination.  the form of the pde solved is:
c
c
c          cxx(x)*pxx + cx(x)*px + cex(x)*p(x,y) +
c
c          cyy(y)*pyy + cy(y)*py + cey(y)*p(x,y) = r(x,y)
c
c     pxx,pyy,px,py are second and first partial derivatives of the
c     unknown complex solution function p(x,y) with respect to the
c     independent variables x,y.  cxx,cx,cex,cyy,cy,cey are the known
c     complex coefficients of the elliptic pde and r(x,y) is the known
c     complex right hand side of the equation.  cxx and cyy should be
c     positive for all x,y in the solution region.  If some of the
c     coefficients depend on both x and y then the PDE is nonseparable.
c     In this case subroutine cud2 must be used instead of cud2sp
c     (see the file  cud2.d)
c                                                                               
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny grid.  the grid
c     is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1)
c
c     be the uniform grid increments in the x,y directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly
c
c     for i=1,...,nx and j=1,...,ny  denote the x,y uniform mesh points
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with Fortran77
c     and Fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 17 used to pass integer
c          arguments.  iparm is set internally and defined as
c          follows:
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      An approximation is NOT generated after an intl=0 call!
c          cud2sp should be called with intl=1 to approximate the elliptic
c          PDE discretized by the intl=0 call.  intl=1 should also
c          be input if cud2sp has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  This will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  Some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) cud2sp is being recalled for additional accuracy.  In
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) cud2sp is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) cud2sp is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to cud2sp

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by cofx,cofy (see below) have
c              changed since the previous call
c
c          (e) any of the constant "alfa" coefficients input by bndyc
c              (see below) have changed since the previous call.
c
c          If any of (a) through (e) are true then the elliptic PDE
c          must be discretized or rediscretized.  If none of (a)
c          through (e) holds, calls can be made with intl=1.
c          Incorrect calls with intl=1 will produce erroneous results.
c  ***     The values set in the saved work space "work" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the edge x=xa
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y
c            (if nxa=0 then nxb=0 is required, see ierror = 2)
c
c        = 1 if p(xa,y) is specified (this must be input thru phi(1,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see bndyc)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the edge x=xb
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y)
c            (if nxb=0 then nxa=0 is required, see ierror = 2)
c
c        = 1 if p(xb,y) is specified (this must be input thru phi(nx,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see bndyc)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the edge y=yc
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c            (if nyc=0 then nyd=0 is required, see ierror = 2)
c
c        = 1 if p(x,yc) is specified (this must be input thru phi(i,1))
c
c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see bndyc)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the edge y=yd
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c             (if nyd=0 then nyc=0 is required, see ierror = 2)
c
c        = 1 if p(x,yd) is specified (this must be input thru phi(i,ny))
c
c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see bndyc)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(6)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the x direction is not used.
c          if ixp > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of ixp can be removed by increasing iex = iparm(8)
c          without changing nx = iparm(10).
c
c
c ... jyq = iparm(7)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the y direction is not used.
c          if jyq > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of jyq can be removed by increasing jey = iparm(9)
c          without changing ny = iparm(11).
c
c
c ... iex = iparm(8)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx.
c
c
c ... jey = iparm(9)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(7)
c          as small as possible within grid size constraints when
c          defining ny.
c
c
c
c ... nx = iparm(10)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(6), iex = iparm(8).
c
c
c ... ny = iparm(11)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(7), jey = iparm(9).
c
c
c *** example
c
c         suppose a solution is wanted on a 33 by 97 grid.  then
c         ixp=2, jyq=6 and iex=jey=5 could be used.  a better
c         choice would be ixp=2, jyq=3, and iex=5, jey=6.
c
c
c *** note
c
c     let G be the nx by ny fine grid on which the approximation is
c     generated and let n = max0(iex,jey).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         G(1) < ... < G(k) < ... < G(n) = G.
c
c     each G(k) (k=1,...,n) has mx(k) by my(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c
c
c ... iguess=iparm(12)
c
c          = 0 if no initial guess to the pde is provided
c
c          = 1 if an initial guess to the pde is at the finest grid
c              level is provided in phi (see below)
c
c     comments on iguess = 0 or 1 . . .
c
c     even if iguess = 0, phi must be initialized at all grid points (this
c     is not checked).  phi can be set to 0.0 at non-dirchlet grid points
c     if nothing better is available.  the values set in phi when iguess = 0
c     are passed down and serve as an initial guess to the pde at the coarsest
c     grid level where cycling commences.  in this sense, values input in
c     phi always serve as an initial guess.  setting iguess = 0 forces full
c     multigrid cycling beginning at the coarsest and finishing at the finest
c     grid level.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c     time dependent problems . . .
c
c *** assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at nondirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(13)
c
c          the exact number of cycles executed between the finest (nx by
c          ny) and the coarsest ((ixp+1) by (jyq+1)) grid levels when
c          tolmax=fparm(5)=0.0 (no error control).  when tolmax > 0.0
c          is input (error control) then maxcy is a limit on the number
c          of cycles between the finest and coarsest grid levels.  in
c          any case, at most maxcy*(iprer+ipost) relaxation sweeps are
c          are performed at the finest grid level (see iprer=mgopt(2),
c          ipost=mgopt(3) below).  when multigrid iteration is working
c          "correctly" only a few are required for convergence.  large
c          values for maxcy should not be necessary.
c
c
c ... method = iparm(14) determines the method of relaxation
c              (gauss-seidel based on alternating points or lines)
c
c          = 0 for  point relaxation
c
c          = 1 for line relaxation in the x direction
c
c          = 2 for line relaxation in the y direction
c
c          = 3 for line relaxation in both the x and y direction
c
c
c *** choice of method. . .
c
c     let fx represent the quantity cxx(x,y)/dlx**2 over the solution region.
c
c     let fy represent the quantity cyy(x,y)/dly**2 over the solution region
c
c     if fx,fy are roughly the same size and do not vary too much over
c     the solution region choose method = 0.  if this fails try method=3.
c
c     if fx is much greater than fy choose method = 1.
c
c     if fy is much greater than fx choose method = 2
c
c     if neither fx or fy dominates over the solution region and they
c     both vary considerably choose method = 3.
c
c
c ... length = iparm(15)
c
c          the length of the complex work space provided in vector work (see below).
c          let isx = 0 if method = 0 or method = 2
c          let isx = 3 if method = 1 or method = 3 and nxa.ne.0
c          let isx = 5 if method = 1 or method = 3 and nxa.eq.0
c          let jsy = 0 if method = 0 or method = 1
c          let jsy = 3 if method = 2 or method = 3 and nyc.ne.0
c          let jsy = 5 if method = 2 or method = 3 and nyc.eq.0
c          then . . .
c
c               length = nx*ny*(5+3*(isx+jsy)/2)+ 10*(nx+ny)
c
c          will suffice in all cases but very small nx and ny.
c          the exact minimal work space length required for the
c          current set of input arugments is output in iparm(16).
c          (even if iparm(15) is too small).  this will be usually
c          be less then the value given by the simplified formula
c          above.  * Notice that cud2sp requires considerably less
c          work space than the nonseparable solver cud2 if
c          and only if method=0 is chosen.
c
c ... fparm                                                                     
c
c          a floating point vector of length 6 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in cud2sp and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... tolmax = fparm(5)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j)
c          and phi2(i,j) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(cabs(phi2(i,j)-phi1(i,j))) for all i,j
c
c          and
c
c              phmax = max(cabs(phi2(i,j))) for all i,j
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(5)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible DO NOT use error control!).
c
c ... work                                                                      
c
c          a one dimensional complex saved work space (see iparm(15) for
c          length) which must be preserved from the previous call when
c          calling with intl=iparm(1)=1.
c
c ... bndyc                                                                     
c
c          a subroutine with  arguments (kbdy,xory,alfa,gbdy) which
c          are used to input mixed boundary conditions to cud2sp. bndyc
c          must be declared "external" in the program calling cud2sp.
c          the boundaries are numbered one thru four and the mixed
c          derivative boundary conditions are described below (see the
c          sample driver code "tcud2sp.f" for an example of how bndyc is
c          can beset up).
c                                                                               
c          * * * * * * * * * * * *  y=yd
c          *       kbdy=4        *
c          *                     *
c          *                     *
c          *                     *
c          * kbdy=1       kbdy=2 *
c          *                     *
c          *                     *
c          *                     *
c          *       kbdy=3        *
c          * * * * * * * * * * * *  y=yc
c
c          x=xa                  x=xb
c
c
c          (1) the kbdy=1 boundary
c
c          this is the edge x=xa where nxa=iparm(2)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dx + alfxa*p(xa,y) = gbdxa(y)
c
c          in this case kbdy=1,xory=y will be input to bndyc and
c          alfa,gbdy corresponding to alfxa,gbdxa(y) must be returned
c
c
c          (2) the kbdy=2 boundary
c
c          this is the edge x=xb where nxb=iparm(3)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dx + alfxb*p(xb,y) = gbdxb(y)
c
c          in this case kbdy=2,xory=y, will be input to bndyc and
c          alfa,gbdy corresponding to alfxb,gbdxb(y) must be returned.
c
c
c          (3) the kbdy=3 boundary
c
c          this is the edge y=yc where nyc=iparm(4)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dy + alfyc*p(x,yc) = gbdyc(x)
c
c          in this case kbdy=3,xory=x will be input to bndyc and
c          alfa,gbdy corresponding to alfyc,gbdyc(x) must be returned.
c
c
c          (4) the kbdy=4 boundary
c
c          this is the edge y=yd where nyd=iparm(5)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dy + alfyd*p(x,yd) = gbdyd(x)
c
c          in this case kbdy=4,xory=x will be input to bndyc and
c          alfa,gbdy corresponding to alfyd,gbdyd(x) must be returned.
c
c                                                                               
c ***      alfxa,alfxb,alfyc,alfyd must be complex constants and gbdy type
c          complex for cud2sp.  Use cud2 if any of these depend on x or y.
c          bndyc must provide the mixed boundary condition values
c          in correspondence with those flagged in iparm(2) thru
c          iparm(5).  if all boundaries are specified or periodic
c          cud2sp will never call bndyc.  even then it must be entered
c          as a dummy subroutine. bndyc must be declared "external"
c          in the routine calling cud2sp the actual name chosen may
c          be different.
c
c
c ... cofx
c
c         a subroutine with arguments (x,cxx,cx,cex) which provides
c         the known x dependent complex coefficients for the separable
c         elliptic pde at any x grid point.  the name chosen in the calling
c         routine may be different where the coefficient routine must be declared
c         "external."
c
c ... cofy
c
c         a subroutine with arguments (y,cyy,cy,cey) which provides
c         the known y dependent complex coefficients for the separable
c         elliptic pde at any y grid point.  the name chosen in the calling
c         routine may be different where the coefficient routine must be declared
c         "external."
c
c ... rhs                                                                       
c
c          a complex array dimensioned nx by ny which contains the given
c          right hand side values on the uniform 2-d mesh.
c
c              rhs(i,j) = r(xi,yj) for i=1,...,nx and j=1,...,ny
c
c ... phi                                                                       
c
c          a complex array dimensioned nx by ny.  on input phi must contain
c          specified boundary values. for example, if nyd=iparm(5)=1
c          then phi(i,ny) must be set equal to p(xi,yd) for i=1,...nx
c          prior to calling cud2sp.  these values are preserved by cud2sp.
c          if an initial guess is provided (iguess=iparm(11)=1) it must
c          be input thru phi.
c
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at all grid points (this is not checked).  these
c          values will serve as an initial guess to the pde at the coarsest
c          grid level after a transfer from the fine solution grid.  set phi
c          equal to to 0.0 at all internal and non-specified boundaries
c          grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid arguments (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the arguments
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).  all version 5.0.1
c     mudpack solvers use only fully weighted residual restriction
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---3-----3-----------3-----------------3---------------     level 1
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --6---6-------6---6-----------6---6-------6---6--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c
c **********************************************************************
c *** output arguments ************************************************
c **********************************************************************
c
c
c ... iparm(16)  *** set for intl=0 calls only
c
c          on output iparm(16) contains the actual work space length
c          required.  this will usually be less than that given by the
c          simplified formula for length=iparm(15) (see as input argument)
c
c
c ... iparm(17)  *** set for intl=1 calls only
c
c          on output iparm(17) contains the actual number of multigrid cycles
c          between the finest and coarsest grid levels used to obtain the
c          approximation when error control (tolmax > 0.0) is set.
c
c
c ... fparm(6)   *** set for intl=1 calls with fparm(5) > 0. only
c
c          on output fparm(6) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(6) is computed only if there is error control (tolmax > 0.0)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c               phdif = max(cabs(phi2(i,j)-phi1(i,j))) over all i,j
c
c          and
c
c               phmax = max(cabs(phi2(i,j)) over all i,j
c
c          then
c
c               fparm(6) = phdif/phmax
c
c          is returned whenever phmax > 0.0. in the degenerate case
c          phmax = 0.0, fparm(6) = phdif is returned.
c
c
c ... work
c
c          on output work contains intermediate values that must not
c          be destroyed if cud2sp is to be called again with intl=1
c
c
c ... phi   *** for intl=1 calls only
c
c          on output phi(i,j) contains the approximation to p(xi,yj)
c          for all mesh points i = 1,...,nx and j=1,...,ny.  the last
c          computed iterate in phi is returned even if convergence is
c          not obtained
c
c
c ... ierror
c
c          For intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  Argument checking and discretization
c          is bypassed for intl=1 calls which can only return
c          ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              cabs(cx)*dlx > 2.*cabs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              cabs(cy)*dly > 2.*cabs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c
c             cxx = cmplx(0.5*cabs(cx)*dx,0.0)
c
c             cyy = cmplx(0.5*cabs(cy)*dy,0.0)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made when necessary to preserve convergence.  if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-3  if the continuous elliptic pde is singular.  this means the
c          boundary conditions are periodic or pure derivative at all
c          boundaries and ce(x,y) = (0.0,0.0) for all x,y.  a solution is still
c          attempted but convergence may not occur due to ill-conditioning
c          of the linear system coming from the discretization.  the
c          ierror = -3 flag overrides the ierror=-4 and ierror=-5 nonfatal
c          flags.
c
c
c     =-2  unlike cud2 and cud2cr, there is no ellipticity test with cud2sp
c          so this flag is not set
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on the first call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd
c         in iparm(2),iparm(3),iparm(4),iparm(5) are not 0,1 or 2
c         or if nxa,nxb or nyc,nyd are not pairwise zero.
c
c     = 3 if mino(ixp,jyq) < 2 (ixp = iparm(6), jyq = iparm(7))
c
c     = 4 if min0(iex,jey) < 1 (iex = iparm(8), jey = iparm(9)) or
c         if max0(iex,jey) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or ny.ne.jyq*2**(jey-1)+1
c         (nx = iparm(10), ny = iparm(11))
c
c     = 6 if iguess = iparm(12) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(13) < 1
c
c     = 8 if method = iparm(14) is not 0,1,2, or 3
c
c     = 9 if length = iparm(15) is too small (see iparm(16) on output
c         for minimum required work space length)
c
c     =10 if xa >= xb or yc >= yd
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4))
c
c     =11 if tolmax = fparm(5) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(1) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c *********************************************************
c *********************************************************
c
c     end of cud2sp documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="cud3.txt"><b>CUD3</b></a>
<PRE>
c
c     file cud3.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... required MUDPACK files
c
c     cudcom.f, cud3ln.f, cud3pn.f
c
c ... purpose
c
c     subroutine cud3 automatically discretizes and attempts to compute
c     the second order finite difference approximation to a COMPLEX
c     3-d linear nonseparable elliptic partial differential equation
c     on a box.  the approximation is generated on a uniform grid
c     covering the box (see mesh description below).  boundary
c     conditions may be any combination of mixed, specified (Dirchlet)
c     or periodic.  the form of the pde solved is . . .
c
c          cxx(x,y,z)*pxx + cyy(x,y,z)*pyy + czz(z,y,z)*pzz +
c
c          cx(x,y,z)*px + cy(x,y,z)*py + cz(x,y,z)*pz +
c
c          ce(x,y,z)*p(x,y,z) = r(x,y,z)
c
c     here cxx,cyy,czz,cx,cy,cz,ce are the known complex coefficients
c     of the pde; pxx,pyy,pzz,px,py,pz are the second and first partial
c     derivatives of the unknown complex solution function p(x,y,z)
c     with respect to the independent variables x,y,z; r(x,y,z) is
c     is the known complex right hand side of the elliptic pde.  cxx,cyy
c     and czz should have real and imaginary parts positive for all (x,y,z)
c     in the solution region.
c                                                                               
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny by nz grid.
c     the grid is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd] x [ze,zf].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1), dlz = (zf-ze)/(nz-1)
c
c     be the uniform grid increments in the x,y,z  directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly, zk = ze+(k-1)*dlz
c
c     for i=1,...,nx; j=1,...,ny; k=1,...,nz  denote the x,y,z uniform
c     mesh points.
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with Fortran77
c     and Fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 23 used to efficiently pass
c          integer arguments.  iparm is set internally in cud3
c          and defined as follows . . .                                         
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      An approximation is NOT generated after an intl=0 call!
c          cud3 should be called with intl=1 to approximate the elliptic
c          PDE discretized by the intl=0 call.  intl=1 should also
c          be input if cud3 has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  This will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  Some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) cud3 is being recalled for additional accuracy.  In
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) cud3 is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) cud3 is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to cud3

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by coef (see below) have
c              changed since the previous call
c
c          (e) any of the "alfa" coefficients input by bndyc (see below)
c              have changed since the previous call.
c
c          If any of (a) through (e) are true then the elliptic PDE
c          must be discretized or rediscretized.  If none of (a)
c          through (e) holds, calls can be made with intl=1.
c          Incorrect calls with intl=1 will produce erroneous results.
c  ***     The values set in the saved work space "work" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the (y,z) plane x=xa                    
c
c        = 0 if p(x,y,z) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y,z) = p(x,y,z) for all x,y,z)
c
c        = 1 if p(xa,y,z) is specified  (this must be input thru phi(1,j,k))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see "bndyc" description below where kbdy = 1)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the (y,z) plane x=xb                    
c
c        = 0 if p(x,y,z) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y,z) = p(x,y,z) for all x,y,z)
c
c        = 1 if p(xb,y,z) is specified (this must be input thru phi(nx,j,k))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see "bndyc" description below where kbdy = 2)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the (x,z) plane y=yc                    
c
c        = 0 if p(x,y,z) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc,z) = p(x,y,z) for all x,y,z)

c        = 1 if p(x,yc,z) is specified (this must be input thru phi(i,1,k))

c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see "bndyc" description below where kbdy = 3)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the (x,z) plane y=yd                    
c
c        = 0 if p(x,y,z) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc,z) = p(x,y,z) for all x,y,z)

c        = 1 if p(x,yd,z) is specified (this must be input thru phi(i,ny,k))

c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see "bndyc" description below where kbdy = 4)
c
c
c ... nze=iparm(6)
c
c          flags boundary conditions on the (x,y) plane z=ze                    
c
c        = 0 if p(x,y,z) is periodic in z on [ze,zf]
c            (i.e., p(x,y,z+zf-ze) = p(x,y,z) for all x,y,z

c        = 1 if p(x,y,ze) is specified (this must be input thru phi(i,j,1))

c        = 2 if there are mixed derivative boundary conditions at z=ze
c            (see "bndyc" description below where kbdy = 5)
c
c
c ... nzf=iparm(7)
c
c          flags boundary conditions on the (x,y) plane z=zf                    
c
c        = 0 if p(x,y,z) is periodic in z on [ze,zf]
c            (i.e., p(x,y,z+zf-ze) = p(x,y,z) for all x,y,z

c        = 1 if p(x,y,zf) is specified (this must be input thru phi(i,j,nz))

c        = 2 if there are mixed derivative boundary conditions at z=zf
c            (see "bndyc" description below where kbdy = 6)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(8)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(14)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible.
c          recommended values are the small primes 2 or 3 or (possibly) 5.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the x direction is not used.
c          if ixp > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of ixp can be removed by increasing iex = iparm(11)
c          without changing nx = iparm(14)
c
c
c ... jyq = iparm(9)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(15)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible.
c          recommended values are the small primes 2 or 3 or (possibly) 5.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the y direction is not used.
c          if jyq > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of jyq can be removed by increasing jey = iparm(12)
c          without changing ny = iparm(15)
c
c
c ... kzr = iparm(10)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the z direction (see nz = iparm(16)).  "kzr+1"
c          is the number of points on the coarsest z grid visited during
c          multigrid cycling.  kzr should be chosen as small as possible.
c          recommended values are the small primes 2 or 3 or (possibly) 5.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the z direction is not used.
c          if kzr > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of kzr can be removed by increasing kez = iparm(13)
c          without changing nz = iparm(16)
c
c
c ... iex = iparm(11)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(14)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx = iparm(14).
c
c
c ... jey = iparm(12)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(15)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(9)
c          as small as possible within grid size constraints when
c          defining ny = iparm(15).
c
c
c ... kez = iparm(13)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the z direction (see nz = iparm(16)).
c          kez .le. 50 is required.  for efficient multigrid cycling,
c          kez should be chosen as large as possible and kzr=iparm(10)
c          as small as possible within grid size constraints when
c          defining nz = iparm(16).
c
c
c ... nx = iparm(14)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(8), iex = iparm(11).
c
c
c ... ny = iparm(15)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(9), jey = iparm(12).
c
c
c ... nz = iparm(16)
c
c          the number of equally spaced grid points in the interval [ze,zf]
c          (including the boundaries).  nz must have the form
c
c               nz = kzr*(2**(kez-1)) + 1
c
c          where kzr = iparm(10), kez = iparm(13)
c
c
c *** example
c
c         suppose a solution is wanted on a 33 by 65 by 97 grid.  then
c         ixp=2, jyq=4, kzr=6 and iex=jey=kez=5 could be used.  a better
c         choice would be ixp=jyq=2, kzr=3, and iex=5, jey=kez=6.
c
c *** note
c
c     let G be the nx by ny by nz fine grid on which the approximation is
c     generated and let n = max0(iex,jey,kez).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         G(1) < ... < G(k) < ... < G(n) = G.
c
c     each g(k) (k=1,...,n) has mx(k) by my(k) by mz(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c         mz(k) = kzr*[2**(max0(kez+k-n,1)-1)] + 1
c
c
c
c ... iguess=iparm(17)
c
c          = 0 if no initial guess to the pde is provided
c              and/or full multigrid cycling beginning at the
c              coarsest grid level is desired.
c
c          = 1 if an initial guess to the pde at the finest grid
c              level is provided in phi (see below).  in this case
c              cycling beginning or restarting at the finest grid
c              is initiated.
c
c *** comments on iguess = 0 or 1 . . .
c
c
c     setting iguess=0 forces full multigrid or "fmg" cycling.  phi
c     must be initialized at all grid points.  it can be set to zero at
c     non-Dirchlet grid points if nothing better is available.  the
c     values set in phi when iguess = 0 are passed and down and serve
c     as an initial guess to the pde at the coarsest grid level where
c     multigrid cycling commences.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c *** time dependent problems . . .
c
c     assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at non-Dirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(18)
c
c          the exact number of cycles executed between the finest
c          (nx by ny by nz) and the coarsest ((ixp+1) by (jyq+1) by
c          (kzr+1)) grid levels when tolmax=fparm(7)=0.0 (no error
c          control). when tolmax=fparm(7).gt.0.0 is input (error control)
c          then maxcy is a limit on the number of cycles between the
c          finest and coarsest grid levels.  in any case, at most
c          maxcy*(iprer+ipost) relaxation sweeps are performed at the
c          finest grid level (see iprer=mgopt(2),ipost=mgopt(3) below)
c          when multigrid iteration is working "correctly" only a few
c          cycles are required for convergence.  large values for maxcy
c          should not be required.
c
c
c ... method = iparm(19)
c
c          this sets the method of relaxation (all relaxation
c          schemes in mudpack use red/black type ordering)
c
c          = 0 for gauss-seidel pointwise relaxation
c
c          = 1 for line relaxation in the x direction
c
c          = 2 for line relaxation in the y direction
c
c          = 3 for line relaxation in the z direction
c
c          = 4 for line relaxation in the x and y direction
c
c          = 5 for line relaxation in the x and z direction
c
c          = 6 for line relaxation in the y and z direction
c
c          = 7 for line relaxation in the x,y and z direction
c
c          = 8 for x,y planar relaxation
c
c          = 9 for x,z planar relaxation
c
c          =10 for y,z planar relaxation
c
c ***  if nxa = 0 and nx = 3 at a grid level where line relaxation in the x
c      direction is flagged then it will be replaced by gauss-seidel point
c      relaxation at that grid level.
c
c ***  if nyc = 0 and ny = 3 at a grid level where line relaxation in the y
c      direction is flagged then it will be replaced by gauss-seidel point
c      relaxation at that grid level.
c
c ***  if nze = 0 and nz = 3 at a grid level where line relaxation in the z
c      direction is flagged then it will be replaced by gauss-seidel point
c      relaxation at that grid level.
c
c      these adjustments are necessary since the simultaneous tri-diagonal
c      solvers used with line periodic relaxation must have n > 2 where n
c      is number of unknowns (excluding the periodic point).

c ***  choice of method
c
c      this is very important for efficient convergence.  in some cases
c      experimentation may be required.
c
c      let fx represent the quantity cxx(x,y,z)/dlx**2 over the solution box
c
c      let fy represent the quantity cyy(x,y,z)/dly**2 over the solution box
c
c      let fz represent the quantity czz(x,y,z)/dlz**2 over the solution box
c
c      (0) if fx,fy,fz are roughly the same size and do not vary too
c          much choose method = 0.  if this fails try method = 7.
c
c      (1) if fx is much greater then fy,fz and fy,fz are roughly the same
c          size choose method = 1
c
c      (2) if fy is much greater then fx,fz and fx,fz are roughly the same
c          size choose method = 2
c
c      (3) if fz is much greater then fx,fy and fx,fy are roughly the same
c          size choose method = 3
c
c      (4) if fx,fy are roughly the same and both are much greater then fz
c          try method = 4.  if this fails try method = 8
c
c      (5) if fx,fz are roughly the same and both are much greater then fy
c          try method = 5.  if this fails try method = 9
c
c      (6) if fy,fz are roughly the same and both are much greater then fx
c          try method = 6.  if this fails try method = 10
c
c      (7) if fx,fy,fz vary considerably with none dominating try method = 7
c
c      (8) if fx and fy are considerably greater then fz but not necessarily
c          the same size (e.g., fx=1000.,fy=100.,fz=1.) try method = 8
c
c      (9) if fx and fz are considerably greater then fy but not necessarily
c          the same size (e.g., fx=10.,fy=1.,fz=1000.) try method = 9
c
c      (10)if fy and fz are considerably greater then fx but not necessarily
c          the same size (e.g., fx=1.,fy=100.,fz=10.) try method = 10
c
c
c ... meth2 = iparm(20) determines the method of relaxation used in the planes
c             when method = 8 or 9 or 10.
c
c
c          as above, let fx,fy,fz represent the quantities cxx/dlx**2,
c          cyy/dly**2,czz/dlz**2 over the box.
c
c          (if method = 8)
c
c          = 0 for gauss-seidel pointwise relaxation
c              in the x,y plane for each fixed z
c          = 1 for line relaxation in the x direction
c              in the x,y plane for each fixed z
c          = 2 for line relaxation in the y direction
c              in the x,y plane for each fixed z
c          = 3 for line relaxation in the x and y direction
c              in the x,y plane for each fixed z
c
c          (1) if fx,fy are roughly the same and vary little choose meth2 = 0
c          (2) if fx is much greater then fy choose meth2 = 1
c          (3) if fy is much greater then fx choose meth2 = 2
c          (4) if none of the above or meth2 = 0 fails choose meth2 = 3
c
c          (if method = 9)
c
c          = 0 for gauss-seidel pointwise relaxation with red/black ordering
c              in the x,z plane for each fixed y
c          = 1 for simultaneous line relaxation in the x direction
c              of the x,z plane for each fixed y
c          = 2 for simultaneous line relaxation in the z direction
c              of the x,z plane for each fixed y
c          = 3 for simultaneous line relaxation in the x and z direction
c              of the x,z plane for each fixed y
c
c          (1) if fx,fz are roughly the same and vary little choose meth2 = 0
c          (2) if fx is much greater then fz choose meth2 = 1
c          (3) if fz is much greater then fx choose meth2 = 2
c          (4) if none of the above or meth2 = 0 fails choose meth2 = 3
c
c          (if method = 10)
c
c          = 0 for gauss-seidel pointwise relaxation with red/black ordering
c              in the y,z plane for each fixed x
c          = 1 for simultaneous line relaxation in the y direction
c              of the y,z plane for each fixed x
c          = 2 for simultaneous line relaxation in the z direction
c              of the y,z plane for each fixed x
c          = 3 for simultaneous line relaxation in the y and z direction
c              of the y,z plane for each fixed x
c
c          (1) if fy,fz are roughly the same and vary little choose meth2 = 0
c          (2) if fy is much greater then fz choose meth2 = 1
c          (3) if fz is much greater then fy choose meth2 = 2
c          (4) if none of the above or meth2 = 0 fails choose meth2 = 3
c
c
c ... length = iparm(21)
c
c          the length of the work space provided in vector work.
c
c          let isx = 3 if method = 1,4,5 or 7 and nxa.ne.0
c          let isx = 5 if method = 1,4,5 or 7 and nxa.eq.0
c          let isx = 0 if method has any other value
c
c          let jsy = 3 if method = 2,4,6 or 7 and nyc.ne.0
c          let jsy = 5 if method = 2,4,6 or 7 and nyc.eq.0
c          let jsy = 0 if method has any other value
c
c          let ksz = 3 if method = 3,5,6 or 7 and nze.ne.0
c          let ksz = 5 if method = 3,5,6 or 7 and nze.eq.0
c          let ksz = 0 if method has any other value
c
c
c          then (for method .le.7)
c
c         (1)   length = (nx+2)*(ny+2)*(nz+2)*(10+isx+jsy+ksz)
c
c          or (for method.gt.7)
c
c         (2)   length = 14*(nx+2)*(ny+2)*(nz+2)
c
c          will usually but not always suffice.  The exact minimal length depends,
c          in a complex way, on the grid size arguments and method chosen.
c  ***     It can be predetermined for the current input arguments by calling
c          cud3 with length=iparm(21)=0 and printing iparm(22) or (in f90)
c          dynamically allocating the work space using the value in iparm(22)
c          in a subsequent cud3 call.
c
c ... fparm                                                                     
c
c          a floating point vector of length 8 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in cud3 and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... ze=fparm(5), zf=fparm(6)
c
c          the range of the z independent variable. ze must                     
c          be less than zf.                                                     
c
c
c ... tolmax = fparm(5)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j,k)
c          and phi2(i,j,k) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(cabs(phi2(i,j,k)-phi1(i,j,k))) for all i,j,k
c
c          and
c
c              phmax = max(cabs(phi2(i,j,k))) for all i,j,k
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(5)=0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible DO NOT use error control!).
c
c
c ... work                                                                      
c
c          a complex one dimensional array that must be provided for work space.
c          see length = iparm(21). the values in work must be preserved
c          if cud3 is called again with intl=iparm(1).ne.0 or if cud34
c          is called to improve accuracy.
c
c
c ... bndyc                                                                     
c
c          a subroutine with arguments (kbdy,xory,yorz,alfa,gbdy).
c          which are used to input mixed boundary conditions to cud3.
c          the boundaries are numbered one thru six and the form of
c          conditions are described below.
c                                                                               
c
c     (1) the kbdy=1 boundary
c
c     this is the (y,z) plane x=xa where nxa=iparm(2) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dx + alfxa(y,z)*p(xa,y,z) = gbdxa(y,z)
c
c     in this case kbdy=1,xory=y,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfxa(y,z),gbdxa(y,z) must be returned.
c
c
c     (2) the kbdy=2 boundary
c
c     this is the (y,z) plane x=xb where nxb=iparm(3) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dx + alfxb(y,z)*p(xb,y,z) = gbdxb(y,z)
c
c     in this case kbdy=2,xory=y,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfxb(y,z),gbdxb(y,z) must be returned.
c
c
c     (3) the kbdy=3 boundary
c
c     this is the (x,z) plane y=yc where nyc=iparm(4) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dy + alfyc(x,z)*p(x,yc,z) = gbdyc(x,z)
c
c     in this case kbdy=3,xory=x,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfyc(x,z),gbdyc(x,z) must be returned.
c
c
c     (4) the kbdy=4 boundary
c
c     this is the (x,z) plane y=yd where nyd=iparm(5) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dy + alfyd(x,z)*p(x,yd,z) = gbdyd(x,z)
c
c     in this case kbdy=4,xory=x,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfyd(x,z),gbdyd(x,z) must be returned.
c
c                                                                               
c     (5) the kbdy=5 boundary
c
c     this is the (x,y) plane z=ze where nze=iparm(6) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dz + alfze(x,y)*p(x,y,ze) = gbdze(x,y)
c
c     in this case kbdy=5,xory=x,yorz=y will be input to bndyc and
c     alfa,gbdy corresponding to alfze(x,y),gbdze(x,y) must be returned.
c
c
c     (6) the kbdy=6 boundary
c
c     this is the (x,y) plane z=zf where nzf=iparm(7) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dz + alfzf(x,y)*p(x,y,zf) = gbdzf(x,y)
c
c     in this case kbdy=6,xory=x,yorz=y will be input to bndyc and
c     alfa,gbdy corresponding to alfzf(x,y),gbdzf(x,y) must be returned.
c
c                                                                               
c *** alfxa,alfyc,alfze nonpositive and alfxb,alfyd,alfze nonnegative
c     will help maintain matrix diagonal dominance during discretization
c     aiding convergence.
c
c *** bndyc must provide the mixed boundary condition
c     values in correspondence with those flagged in iparm(2)
c     thru iparm(7).  if all boundaries are specified then
c     cud3 will never call bndyc.  even then it must be entered
c     as a dummy subroutine. bndyc must be declared
c     external in the routine calling cud3.  the actual
c     name chosen may be different.
c
c
c ... coef
c
c         a subroutine with arguments (x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
c         which provides the known complex coefficients for the elliptic pde
c         at any grid point (x,y,z).  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         external.
c
c ... rhs                                                                       
c
c          a complex array dimensioned nx by ny by nz which contains
c          the given right hand side values on the uniform 3-d mesh.            
c          rhs(i,j,k) = r(xi,yj,zk) for i=1,...,nx and j=1,...,ny               
c          and k=1,...,nz.
c
c ... phi                                                                       
c
c          a complex array dimensioned nx by ny by nz .  on input phi must
c          contain specified boundary values and an initial guess
c          to the solution if flagged (see iguess=iparm(17)=1).  for
c          example, if nyd=iparm(5)=1 then phi(i,ny,k) must be set
c          equal to p(xi,yd,zk) for i=1,...,nx and k=1,...,nz prior to
c          calling cud3.  the specified values are preserved by cud3.
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at non-Dirchlet grid points (this is not
c          checked). these values are projected down and serve as an initial
c          guess to the pde at the coarsest grid level.  set phi to 0.0 at
c          nonDirchlet grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid arguments (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the arguments
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---3-----3-----------3-----------------3---------------     level 1
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --6---6-------6---6-----------6---6-------6---6--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c ***********************************************************************
c ****output arguments**************************************************
c ***********************************************************************
c
c
c ... iparm(22)
c
c          on output iparm(22) contains the actual complex work space length
c          required for the current grid sizes and method.  This value
c          will be computed and returned even if iparm(21) is less then
c          iparm(22) (see ierror=9).
c
c
c ... iparm(23)
c
c          if error control is selected (tolmax = fparm(7) .gt. 0.0) then
c          on output iparm(23) contains the actual number of cycles executed
c          between the coarsest and finest grid levels in obtaining the
c          approximation in phi.  the quantity (iprer+ipost)*iparm(23) is
c          the number of relaxation sweeps performed at the finest grid level.
c
c
c ... fparm(8)                                                                  
c
c          on output fparm(8) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(8) is computed only if there is error control (tolmax.gt.0.)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c             phdif = max(cabs(phi2(i,j,k)-phi1(i,j,k))) for all i,j,k
c
c          and
c
c             phmax = max(cabs(phi2(i,j,k))) for all i,j,k
c
c          then
c
c             fparm(8) = phdif/phmax
c
c          is returned whenever phmax.gt.0.0.  in the degenerate case
c          phmax = 0.0, fparm(8) = phdif is returned.
c
c
c
c ... work
c
c          on output work contains intermediate values that must not be
c          destroyed if cud3 is to be called again with iparm(1)=1 or
c          if cud34 is to be called to improve the estimate to fourth
c          order.
c
c ... phi
c
c          on output phi(i,j,k) contains the approximation to
c          p(xi,yj,zk) for all mesh points i=1,...,nx; j=1,...,ny;
c          k=1,...,nz.  the last computed iterate in phi is returned
c          even if convergence is not obtained (ierror=-1)
c
c ... ierror
c
c          For intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  Argument checking and discretization
c          is bypassed for intl=1 calls which can only return
c          ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              cabs(cx)*dlx > 2.*cabs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              cabs(cy)*dly > 2.*cabs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c             if cabs(cxx) < 0.5*cabs(cx)*dx then
c             cxx = cmplx(0.5*cabs(cx)*dx,0.0)
c
c                          (and)
c
c             if (cabs(cyy) < 0.5*cabs(cy)*dy then
c             cyy = cmplx(0.5*cabs(cy)*dy,0.0)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made to preserve convergence of multigrid iteration. if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-3  if the continuous elliptic pde is singular.  this means the
c          boundary conditions are periodic or pure derivative at all
c          boundaries and ce(x,y) = 0.0 for all x,y.  a solution is still
c          attempted but convergence may not occur due to ill-conditioning
c          of the linear system coming from the discretization.  the
c          ierror = -3 flag overrides the ierror=-4 and ierror=-5 nonfatal
c          flags.
c
c
c     =-2  if the pde is not elliptic (i.e., cxx*cyy.le.0.0 for some (xi,yj))
c          in this case a solution is still attempted although convergence
c          may not occur due to ill-conditioning of the linear system.
c          the ierror = -2 flag overrides the ierror=-5,-4,-3 nonfatal
c          flags.
c
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd,nze,nzf
c         in iparm(2) through iparm(7)is not 0,1 or 2 or if
c         (nxa,nxb) or (nyc,nyd) or (nze,nzf) are not pairwise zero.
c
c     = 3 if mino(ixp,jyq,kzr) < 2 (ixp=iparm(8),jyq=iparm(9),kzr=iparm(10))
c
c     = 4 if min0(iex,jey,kez) < 1 (iex=iparm(11),jey=iparm(12),kez=iparm(13))
c         or if max0(iex,jey,kez) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or if ny.ne.jyq*2**(jey-1)+1 or
c         if nz.ne.kzr*2**(kez-1)+1 (nx=iparm(14),ny=iparm(15),nz=iparm(16))
c
c     = 6 if iguess = iparm(17) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(18) < 1 (large values for maxcy should not be used)
c
c     = 8 if method = iparm(19) is less than 0 or greater than 10 or
c         if meth2 = iparm(20) is not 0 or 1 or 2 or 3 when method > 7.
c
c     = 9 if length = iparm(20) is too small (see iparm(21) on output
c         for minimum required work space length)
c
c     =10 if any of:  xa < xb or yc < yd or ze < zf is false
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4),ze=fparm(5),zf=fparm(6))
c
c     =11 if tolmax = fparm(7) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(2) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c *********************************************************
c *********************************************************
c
c     end of cud3 documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="cud34.txt"><b>CUD34</b></a>
<PRE>
c
c     file cud34.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file cud34.d
c
c     contains documentation for subroutine cud34(work,phi,ierror)
c     A sample fortran driver is file "tcud34.f".
c
c ... required MUDPACK files
c
c     cud3.f, cudcom.f, cud3ln.f, cud3pn.f
c
c ... purpose
c
c     cud34 attempts to improve the estimate in phi, obtained by calling
c     cud3,  from second to fourth order accuracy.  see the file "cud3.d"
c     for a detailed discussion of the elliptic pde approximated and
c     arguments "work,phi" which are also part of the argument list for
c     cud3.
c
c ... assumptions
c
c     *  phi contains a second-order approximation from an earlier cud3 call
c
c     *  arguments "work,phi" are the same used in calling cud3
c
c     *  "work,phi" have not changed since the last call to cud3
c
c     *  the finest grid level contains at least 6 points in each direction
c
c
c *** warning
c
c     if the first assumption is not true then a fourth order approximation
c     cannot be produced in phi.  the last assumption (adequate grid size)
c     is the only one checked. failure in any of the others can result in
c     in an undetectable error.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections"
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... error argument
c
c     = 0 if no error is detected
c
c     = 30 if min0(nx,ny) < 6 where nx,ny are the fine grid sizes
c          in the x,y directions.
c                                                                               
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of cud34 documentation
c
c  ***********************************************************************
c  ***********************************************************************
c
</PRE>
<HR>
 
<a name="cud34sp.txt"><b>CUD34SP</b></a>
<PRE>
c
c     file cud34sp.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file cud34sp.d
c
c     contains documentation for subroutine cud34sp(work,phi,ierror)
c     A sample fortran driver is file "tcud34sp.f".
c
c ... required MUDPACK files
c
c     cud3sp.f, cudcom.f
c
c ... purpose
c
c     cud34sp attempts to improve the estimate in phi, obtained by calling
c     cud3sp,  from second to fourth order accuracy.  see the file "cud3sp.d"
c     for a detailed discussion of the elliptic pde approximated and
c     arguments "work,phi" which are also part of the argument list for
c     cud3sp.
c
c ... assumptions
c
c     *  phi contains a second-order approximation from an earlier cud3sp call
c
c     *  arguments "work,phi" are the same used in calling cud3sp
c
c     *  "work,phi" have not changed since the last call to cud3sp
c
c     *  the finest grid level contains at least 6 points in each direction
c
c
c *** warning
c
c     if the first assumption is not true then a fourth order approximation
c     cannot be produced in phi.  the last assumption (adequate grid size)
c     is the only one checked. failure in any of the others can result in
c     in an undetectable error.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c ... portability                                                               
c
c     mudpack5.01 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections"
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... error argument
c
c     = 0 if no error is detected
c
c     = 30 if min0(nx,ny) < 6 where nx,ny are the fine grid sizes
c          in the x,y directions.
c                                                                               
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of cud34sp documentation
c
c  ***********************************************************************
c  ***********************************************************************
c
</PRE>
<HR>
 
<a name="cud3cr.txt"><b>CUD3CR</b></a>
<PRE>
c
c     file cud3cr.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file cud3cr.d
c
c     contains documentation for:
c     subroutine cud3cr(iparm,fparm,work,coef,bnd3cr,rhs,phi,mgopt,
c    +icros,crsxy,crsxz,crsyz,tol,maxit,iouter,rmax,ierror)
c     A sample fortran driver is file "tcud3cr.f".
c
c ... required MUDPACK files
c
c     cudcom.f
c
c
c ... purpose
c
c     subroutine cud3cr automatically discretizes and attempts to compute
c     the second order finite difference approximation to a complex 3-d
c     linear nonseparable elliptic partial differential equation with
c     cross derivative terms on a box.  the approximation is generated
c     on a uniform grid covering the box (see mesh description below).
c     boundary conditions may be any combination of oblique mixed
c     derivative (see bnd3cr description below), specified (Dirchlet) or
c     periodic.  the form of the pde in operator notation is
c
c          l(p) + lxyz(p) = r(x,y,z)
c
c     where
c
c          l(p) = cxx(x,y,z)*pxx + cyy(x,y,z)*pyy + czz(z,y,z)*pzz +
c
c                 cx(x,y,z)*px + cy(x,y,z)*py + cz(x,y,z)*pz +
c
c                 ce(x,y,z)*p(x,y,z) = r(x,y,z)
c
c     and
c
c       lxyz(p) = cxy(x,y,z)*pxy + cxz(x,y,z)*pxz + cyz(x,y,z)*pyz
c
c     here cxx,cyy,czz,cx,cy,cz,ce,cxy,cxz,cyz  are the known complex
c     coefficients of the pde; pxx,pyy,pzz,px,py,pz are the second and
c     first partial derivatives of the unknown complex solution function p
c     with respect to the independent variables x,y,z; pxy,pxz, and pyz
c     are the second order mixed partial derivatives of p with respect
c     to xy,xz, and yz.  r(x,y,z) is the known complex right hand side.
c
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny by nz grid.
c     the grid is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd] x [ze,zf].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1), dlz = (zf-ze)/(nz-1)
c
c     be the uniform grid increments in the x,y,z  directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly, zk = ze+(k-1)*dlz
c
c     for i=1,...,nx; j=1,...,ny; k=1,...,nz  denote the x,y,z uniform
c     mesh points.
c
c
c
c ... methods
c
c
c     subroutine cud3cr is a recent addition to mudpack.  details
c     of the methods employeed by the other solvers in mudpack are in
c     [1,9,10].  [1,2,7,9,10] contain performance measurements on a variety
c     of elliptic pdes (see "references" in the file "readme").  the multi-
c     grid methods are described in documentation for the other solvers.
c
c *** cud3cr differs fundamentally from the other solvers in mudpack.
c     the full pde including cross derivative terms is discretized on
c     the INTERIOR of the solution region:
c
c       xa < x < xb, yc < y < yd, ze < z < zf
c
c     however, on nonspecified (nondirchlet) boundaries only l(p) is
c     discretized and the cross derivative term lxyz(p) is moved to the
c     right hand side of the pde and approximated by second order finite
c     finite difference formula applied to a previous estimate in p(k-1).
c     similarly, oblique mixed derivative boundary conditions (see bnd3cr)
c     are converted to a "cud3" type mixed normal form using second-order
c     finite difference formula applied to a previous estimate p(k-1) to
c     approximate non-normal derivative components.  for example if
c     the mixed derivative condition
c
c       py + a(x,z)*px + b(x,z)*pz + c(x,z)*p(x,yd,z) = gyd(y,z)
c
c     is specifed on the (x,z) plane of the upper y=yd boundary (see
c     bnd3cr for kbdy=4 below) then cud3cr converts this to the mixed
c     normal derivative form
c
c       py + c(x,z)*p(x,yd,z) = h(k,x,z)
c
c     where the modified right hand side h(k,x,z) is given by
c
c       h(k,x,z) = gyd(x,z) - [a(x,z)*dx(p(k-1)) + b(x,z)*dz(p(k-1)].
c
c     dx(p(k-1)) and dz(p(k-1)) are second order finite difference
c     approximations to the nonnormal partial derivatives px,pz using the
c     previous estimate in p(k-1).
c
c     the result of full discretization on interior grid points and partial
c     discretization with right hand side modifications on boundaries,
c     is a linear system which we denote by
c
c       D(p(k)) = r - Dxyz(p(k-1)).
c
c     D is the coefficient matrix coming from the discretization and
c     Dxyz(p(k-1)) stands for the right hand side modification obtained
c     by approximating boundary cross derivative terms and/or nonnormal
c     derivative components from mixed derivative boundary conditions
c     with second order finite difference formula applied to p(k-1).
c     with this notation, we formally describe the outer iteration employeed
c     by cud3cr:
c
c     algorithm cud3cr
c     .
c     set k = 0
c     .
c     set p(0) = 0.0 for all nonspecified grid points
c     .
c     repeat
c
c     .. k = k+1
c
c     .. solve D(p(k)) = r - Dxyz(p(k-1)) using multigrid iteration
c
c     .. set rmax(k) = ||p(k) - p(k-1)|| / ||p(k)||
c
c     until (rmax(k) < tol or k = maxit)
c     .
c     end cud3cr
c
c     tol is an error tolerance for convergence and maxit is a limit on
c     the number of outer iterations.  both are user prescribed input
c     arguments to cud3cr.  the maximum vector norm || || is used in
c     computing the relative difference between successive estimates in
c     rmax(k).  large values for maxit should not be used.
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with Fortran77
c     and Fortran90 on a variety of platforms.
c                                                                               
c
c ... references (partial list)
c
c     for a complete list see "references" in the mudpack information and
c     directory file "readme"
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c **********************************************************************
c *** arguments ********************************************************
c **********************************************************************
c
c     arguments iparm,fparm,work,rhs,phi,coef,mgopt are the same as
c     those input to cud3 (see cud3.d for a detailed description) with the
c     following provisions:
c
c     (1) the minimum required complex work space length for cud3cr is increased
c         by approximately
c
c              nx*ny*nz*(1+8*(icros(1)+icros(2)+icros(3))/7 +
c
c              2*(icros(1)+icros(2)+icros(3))*(nx*ny+nx*nz+ny*nz)
c
c         words over the minimum work space required by cud3 (see icros
c         description below).  the exact minimal work space required
c         by cud3cr for the current set of input arguments is output
c         in iparm(22). * The exact minimal work length required
c         for the current method and grid size arguments can be
c         predetermined by calling cud3cr with iparm(21)=0 and
c         printout of iparm(22) or (in fortran 90 codes) dynamically
c         allocating work using the the value in iparm(22) in subsequent
c         calls to cud3cr.
c
c     (2) at least two calls to cud3cr are necessary to generate an
c         approximation. intl=iparm(1)=0 is required on the first
c         call.  this call will do "once only" discretization, and
c         set intermediate values in work which must be preserved
c         for noninitial calls.
c
c     (3) maxcy = iparm(18) must be 1 or 2 (see ierror = 13).
c
c     (4) tolmax = fparm(5) = 0.0 is required.  no "internal" error control
c         is allowed within multigrid cycling (see cud3.d)
c
c     (5) mgopt(1) = 0 is required.  only the default multigrid
c         options (W(2,1) cycles with cubic prolongation) can be used
c         with cud3cr
c
c *** new arguments
c
c      the arguments: bnd3cr,icros,crsxy,crsxz,crsyz,tol,maxit,iouter,rmax
c      are all new to cud3cr.  the error argument, ierror, has been expanded.
c      these are all described below:
c
c
c ... bnd3cr(kbdy,xory,yorz,a,b,c,g)
c
c      a subroutine with input arguments kbdy,xory,yorz and output
c      arguments a,b,c,g.  bnd3cr inputs OBLIQUE mixed derivative
c      conditions at any of the six x,y,z boundaries to cud3cr.
c      a,b,c,g are all type complex.
c      described below:
c
c         (1) the kbdy=1 boundary
c
c         this is the (y,z) plane x=xa where nxa=iparm(2)=2 flags
c         an oblique mixed boundary condition of the form
c
c           px + axa(y,z)*py + bxa(y,z)*pz +cxa(y,z)*p(xa,y,z) = gxa(y,z)
c
c         in this case kbdy=1,xory=y,yorz=z will be input to bnd3cr and
c         a,b,c,g corresponding to the known coefficients axa(y,z),bxa(y,z),
c         cxa(y,z),gxa(y,z) must be returned
c
c
c         (2) the kbdy=2 boundary
c
c         this is the (y,z) plane x=xb where nxb=iparm(3)=2 flags
c         an oblique mixed boundary condition of the form
c
c           px + axb(y,z)*py + bxb(y,z)*pz +cxb(y,z)*p(xb,y,z) = gxb(y,z)
c
c         in this case kbdy=2,xory=y,yorz=z will be input to bnd3cr and
c         a,b,c,g corresponding to the known coefficients axb(y,z),bxb(y,z),
c         cxb(y,z),gxb(y,z) must be returned
c
c         (3) the kbdy=3 boundary
c
c         this is the (x,z) plane y=yc where nyc=iparm(4)=2 flags
c         an oblique mixed boundary condition of the form
c
c           py + ayc(x,z)*px + byc(x,z)*pz +cyc(x,z)*p(x,yc,z) = gyc(x,z)
c
c         in this case kbdy=3,xory=x,yorz=z will be input to bnd3cr and
c         a,b,c,g corresponding to the known coefficients ayc(x,z),byc(x,z),
c         cyc(x,z),gyc(x,z) must be returned
c
c
c         (4) the kbdy=4 boundary
c
c         this is the (x,z) plane y=yd where nyd=iparm(5)=2 flags
c         an oblique mixed boundary condition of the form
c
c           py + ayd(x,z)*px  + byd(x,z)*pz +cyd(x,z)*p(x,yd,z) = gyd(x,z)
c
c         in this case kbdy=4,xory=x,yorz=z will be input to bnd3cr and
c         a,b,c,g corresponding to the known coefficients ayd(x,z),byd(x,z),
c         cyd(x,z),gyd(x,z) must be returned
c
c         (5) the kbdy=5 boundary
c
c         this is the (x,y) plane z=ze where nze=iparm(6)=2 flags
c         an oblique mixed boundary condition of the form
c
c           pz + aze(x,y)*px + bze(x,y)*py + cze(x,y)*p(x,y,ze) = gze(x,y)
c
c         in this case kbdy=5,xory=x,yorz=y will be input to bnd3cr and
c         a,b,c,g corresponding to the known coefficients aze(x,y),bze(x,y),
c         cze(x,y),gze(x,y) must be returned
c
c         (6) the kbdy=6 boundary
c
c         this is the (x,y) plane z=zf where nzf=iparm(7)=2 flags
c         an oblique mixed boundary condition of the form
c
c           pz + azf(x,y)*px + bzf(x,y)*py + czf(x,y)*p(x,y,zf) = gzf(x,y)
c
c         in this case kbdy=6,xory=x,yorz=y will be input to bnd3cr and
c         a,b,c,g corresponding to the known coefficients azf(x,y),bzf(x,y),
c         czf(x,y),gzf(x,y) must be returned
c
c
c     bnd3cr must be delcared "external" in the routine calling cud3cr
c     where its name may be different.  bnd3cr must be entered as a
c     dummy subroutine even if there are no derivative boundary conditions.
c     for an example of how to set up a subroutine to input derivative
c     boundary conditions, see the test program tcud3cr.f
c
c ... icros
c
c     an integer vector argument dimensioned 3 which flags the presence
c     or absence of cross derivative terms in the pde as follows:
c
c       icros(1) = 1 if cxy(x,y,z) is nonzero for any grid point (x,y,z)
c       icros(1) = 0 if cxy(x,y,z) = (0.0,0.0) for all grid points (x,y,z)
c
c       icros(2) = 1 if cxz(x,y,z) is nonzero for any grid point (x,y,z)
c       icros(2) = 0 if cxz(x,y,z) = (0.0,0.0) for all grid points (x,y,z)
c
c       icros(3) = 1 if cyz(x,y,z) is nonzero for any grid point (x,y,z)
c       icros(3) = 0 if cyz(x,y,z) = (0.0,0.0) for all grid points (x,y,z)
c
c
c ... crsxy(x,y,z,cxy)
c
c     if icros(1) = 1 then crsxy is a subroutine with arguments
c     (x,y,z,cxy) which supplies the xy cross derivative coefficient
c     cxy at the grid point (x,y,z).  if icros(1) = 0 then crsxy
c     is a dummy subroutine argument (i.e., it must be provided but
c     will not be invoked).
c
c
c ... crsxz(x,y,z,cxz)
c
c     if icros(2) = 1 then crsxz is a subroutine with arguments
c     (x,y,z,cxz) which supplies the xz cross derivative coefficient
c     cxz at the grid point (x,y,z).  if icros(2) = 0 then crsxz
c     is a dummy subroutine argument (i.e., it must be provided but
c     will not be invoked).
c
c
c ... crsyz(x,y,z,cyz)
c
c     if icros(3) = 1 then crsyz is a subroutine with arguments
c     (x,y,z,cyz) which supplies the yz cross derivative coefficient
c     cxy at the grid point (x,y,z).  if icros(3) = 0 then crsyz
c     is a dummy subroutine argument (i.e., it must be provided but
c     will not be invoked).
c
c     crsxy,crsxz,crsyz must be declared "external" in the routine
c     calling cud3cr.  the names chosen for these routines can be
c     different (see tcud3cr.f for an example)
c
c ... tol
c
c     tol is an error control argument for the outer iteration employed
c     by cud3cr (see "methods" description above).  if tol > 0.0 is input
c     then tol is a relative error tolerance for convergence.  the outer
c     iteration terminates and convergence is deemed to have occurred at the
c     k(th) iterate if the maximum relative difference, rmax(k), satisfies
c
c                  def
c           rmax(k) = ||p(k) - p(k-1)||/ ||p(k)|| < tol.
c
c     the last approximation p(maxit) is returned in phi even if
c     convergence does not occurr.  the maximum norm || || is used.
c     when tol = 0.0 is input, error control is not implemented and
c     exactly maxit (see below) outer iterations are executed in cud3cr.
c     the tol = 0.0 option eliminates unnecessary computation when
c     the user is certain of the required value for maxit.
c
c
c ... maxit
c
c     a limit on the outer iteration loop (see "method" description)
c     used to approximate the 3-d pde with cross derivative terms when
c     tol > 0.0.  if tol = 0.0 is entered then exactly maxit outer
c     iterations are performed and only rmax(maxit) is computed.  the
c     total number of relaxation sweeps performed at the finest grid
c     level is bounded by 3*maxcy*maxit.  large values for maxit should
c     not be used.
c
c
c ***********************************************************************
c ****output arguments**************************************************
c ***********************************************************************
c
c
c ... iparm(22)
c
c          on output iparm(22) contains the actual work space length
c          required by cud3cr for the current grid sizes and method.
c          this will be approximately

c              nx*ny*nz*(1+8*(icros(1)+icros(2)+icros(3))/7 +
c
c              2*(icros(1)+icros(2)+icros(3))*(nx*ny+nx*nz+ny*nz)
c
c          words longer than the space required by cud3 (see cud3.d)
c
c
c ... work
c
c          on output work contains intermediate values that must not be
c          destroyed if cud3cr is to be called again with iparm(1)=1
c          and iparm(17)=1.
c
c
c ... phi
c
c          on output phi(i,j,k) contains the approximation to
c          p(xi,yj,zk) for all mesh points i=1,...,nx; j=1,...,ny;
c          k=1,...,nz.  the last computed iterate in phi is returned
c          even if convergence is not obtained.
c
c
c ... iouter
c
c          the number of outer iterations (see "method" description above)
c          executed by cud3cr for the current call. maxit is an upper bound
c          for iouter
c
c
c ... rmax (see tol,maxit descriptions above)
c
c          a maxit dimensioned real vector.  if tol > 0.0 is input then
c          rmax(k) for k=1,...,iouter contain the maximum relative
c          difference between successive estimates.  rmax(k) is
c          given by
c
c               rmax(k) = ||p(k) - p(k-1)||/ ||p(k)||
c
c          for k=1,...,iouter.  the maximum norm || || is used.  either
c          iouter < maxit (convergence) or iouter = maxit is possible.
c          if tol = 0.0 input then exactly maxit outer iterations are
c          executed and only rmax(maxit) is computed.  in this case
c          rmax(1),...,rmax(maxit-1) are set to 0.0.  the tol = 0.0
c          option eliminates unnecessary computation when the user is
c          certain of the required value for maxit.
c
c
c ... ierror
c
c          an integer error argument which indicates fatal errors when
c          returned positive.  the negative values -5,-4,-3,-2,-1  and
c          ierror = 2,3,4,5,6,9,10 have the same meaning as described for
c          for cud3 (see cud3.d).  in addition:
c
c ***      new nonfatal error
c
c          ierror = -10 if tol > 0.0 is input (error control) and convergence
c          fails in maxit outer iterations.  in this case the latest
c          approximation p(maxit) is returned in phi (cud3cr can be recalled
c          with iparm(1)=iparm(17)=1 to improve the approximation as long
c          as all other arguments are unchanged)
c
c ***      new fatal errors
c
c ... ierror
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls of if intl=0 and iguess=iparm(17)=1
c
c     = 7 if maxcy = iparm(18) is not 1 or 2
c
c     = 8 if method = iparm(19) is less than 0 or greater than 7
c         cud3cr does not allow planar relaxation.  meth2=iparm(20)
c         is not used or checked.
c
c     =11 if tolmax = fparm(7) is not 0.0
c
c     =12 if kcycle = mgopt(1) is not 0
c
c     =13 if icros(1) or icros(2) or icros(3) is not 0 or 1
c
c     =14 if tol < 0.0
c
c     =15 if maxit < 1
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of cud3cr documentation
c
c  ***********************************************************************
c  ***********************************************************************
c

</PRE>
<HR>
 
<a name="cud3sp.txt"><b>CUD3SP</b></a>
<PRE>
c
c     file cud3sp.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file cud3sp.d
c
c     contains documentation for:
c     subroutine cud3sp(iparm,fparm,work,cofx,cofy,cofz,bndyc,rhs,phi,
c    +                   mgopt,ierror)
c     A sample fortran driver is file "tcud3sp.f".
c
c ... required MUDPACK files
c
c     cudcom.f
c
c ... purpose
c
c     subroutine cud3sp automatically discretizes and attempts to compute
c     the second order finite difference approximation to a complex three-
c     dimensional linear SEPARABLE elliptic partial differential
c     equation on a box.  the approximation is generated on a uniform
c     grid covering the box (see mesh description below).  boundary
c     conditions may be any combination of mixed, specified (Dirchlet)
c     or periodic.  the form of the pde solved is . . .
c
c       cxx(x)*pxx + cx(x)*px + cex(x)*p(x,y,z) +
c
c       cyy(y)*pyy + cy(y)*py + cey(y)*p(x,y,z) +
c
c       czz(z)*pzz + cz(z)*pz + cez(z)*p(x,y,z) = r(x,y,z)
c
c     here cxx,cx,cex,cyy,cy,cey,czz,cz,cez are the known complex coefficients
c     of the pde; pxx,pyy,pzz,px,py,pz are the second and first
c     partial derivatives of the unknown solution function p(x,y,z)
c     with respect to the independent variables x,y,z; r(x,y,z) is
c     is the known complex right hand side of the elliptic pde.
c                                                                               
c     SEPARABILITY means:
c
c       cxx,cx,cex depend only on x
c       cyy,cy,cey depend only on y
c       czz,cz,cez depend only on z
c
c     For example, LaPlace's equation in Cartesian coordinates is separable.
c     Nonseparable elliptic PDEs can be approximated with cud3.
c     cud3sp requires considerably less work space then cud3.
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny by nz grid.
c     the grid is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd] x [ze,zf].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1), dlz = (zf-ze)/(nz-1)
c
c     be the uniform grid increments in the x,y,z  directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly, zk = ze+(k-1)*dlz
c
c     for i=1,...,nx; j=1,...,ny; k=1,...,nz  denote the x,y,z uniform
c     mesh points.
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with Fortran77
c     and Fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 22 used to efficiently pass
c          integer arguments.  iparm is set internally in cud3sp
c          and defined as follows . . .                                         
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      An approximation is NOT generated after an intl=0 call!
c          cud3sp should be called with intl=1 to approximate the elliptic
c          PDE discretized by the intl=0 call.  intl=1 should also
c          be input if cud3sp has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  This will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  Some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) cud3sp is being recalled for additional accuracy.  In
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) cud3sp is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) cud3sp is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to cud3sp

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by coef (see below) have
c              changed since the previous call
c
c          (e) any of the "alfa" coefficients input by bndyc (see below)
c              have changed since the previous call.
c
c          If any of (a) through (e) are true then the elliptic PDE
c          must be discretized or rediscretized.  If none of (a)
c          through (e) holds, calls can be made with intl=1.
c          Incorrect calls with intl=1 will produce erroneous results.
c  ***     The values set in the saved work space "work" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the (y,z) plane x=xa                    
c
c        = 0 if p(x,y,z) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y,z) = p(x,y,z) for all x,y,z)
c
c        = 1 if p(xa,y,z) is specified  (this must be input thru phi(1,j,k))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see "bndyc" description below where kbdy = 1)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the (y,z) plane x=xb                    
c
c        = 0 if p(x,y,z) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y,z) = p(x,y,z) for all x,y,z)
c
c        = 1 if p(xb,y,z) is specified (this must be input thru phi(nx,j,k))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see "bndyc" description below where kbdy = 2)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the (x,z) plane y=yc                    
c
c        = 0 if p(x,y,z) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc,z) = p(x,y,z) for all x,y,z)

c        = 1 if p(x,yc,z) is specified (this must be input thru phi(i,1,k))

c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see "bndyc" description below where kbdy = 3)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the (x,z) plane y=yd                    
c
c        = 0 if p(x,y,z) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc,z) = p(x,y,z) for all x,y,z)

c        = 1 if p(x,yd,z) is specified (this must be input thru phi(i,ny,k))

c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see "bndyc" description below where kbdy = 4)
c
c
c ... nze=iparm(6)
c
c          flags boundary conditions on the (x,y) plane z=ze                    
c
c        = 0 if p(x,y,z) is periodic in z on [ze,zf]
c            (i.e., p(x,y,z+zf-ze) = p(x,y,z) for all x,y,z

c        = 1 if p(x,y,ze) is specified (this must be input thru phi(i,j,1))

c        = 2 if there are mixed derivative boundary conditions at z=ze
c            (see "bndyc" description below where kbdy = 5)
c
c
c ... nzf=iparm(7)
c
c          flags boundary conditions on the (x,y) plane z=zf                    
c
c        = 0 if p(x,y,z) is periodic in z on [ze,zf]
c            (i.e., p(x,y,z+zf-ze) = p(x,y,z) for all x,y,z

c        = 1 if p(x,y,zf) is specified (this must be input thru phi(i,j,nz))

c        = 2 if there are mixed derivative boundary conditions at z=zf
c            (see "bndyc" description below where kbdy = 6)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(8)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(14)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible.
c          recommended values are the small primes 2 or 3 or (possibly) 5.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the x direction is not used.
c          if ixp > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of ixp can be removed by increasing iex = iparm(11)
c          without changing nx = iparm(14)
c
c
c ... jyq = iparm(9)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(15)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible.
c          recommended values are the small primes 2 or 3 or (possibly) 5.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the y direction is not used.
c          if jyq > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of jyq can be removed by increasing jey = iparm(12)
c          without changing ny = iparm(15)
c
c
c ... kzr = iparm(10)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the z direction (see nz = iparm(16)).  "kzr+1"
c          is the number of points on the coarsest z grid visited during
c          multigrid cycling.  kzr should be chosen as small as possible.
c          recommended values are the small primes 2 or 3 or (possibly) 5.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the z direction is not used.
c          if kzr > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of kzr can be removed by increasing kez = iparm(13)
c          without changing nz = iparm(16)
c
c
c ... iex = iparm(11)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(14)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx = iparm(14).
c
c
c ... jey = iparm(12)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(15)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(9)
c          as small as possible within grid size constraints when
c          defining ny = iparm(15).
c
c
c ... kez = iparm(13)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the z direction (see nz = iparm(16)).
c          kez .le. 50 is required.  for efficient multigrid cycling,
c          kez should be chosen as large as possible and kzr=iparm(10)
c          as small as possible within grid size constraints when
c          defining nz = iparm(16).
c
c
c ... nx = iparm(14)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(8), iex = iparm(11).
c
c
c ... ny = iparm(15)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(9), jey = iparm(12).
c
c
c ... nz = iparm(16)
c
c          the number of equally spaced grid points in the interval [ze,zf]
c          (including the boundaries).  nz must have the form
c
c               nz = kzr*(2**(kez-1)) + 1
c
c          where kzr = iparm(10), kez = iparm(13)
c
c
c *** example
c
c         suppose a solution is wanted on a 33 by 65 by 97 grid.  then
c         ixp=2, jyq=4, kzr=6 and iex=jey=kez=5 could be used.  a better
c         choice would be ixp=jyq=2, kzr=3, and iex=5, jey=kez=6.
c
c *** note
c
c     let G be the nx by ny by nz fine grid on which the approximation is
c     generated and let n = max0(iex,jey,kez).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         G(1) < ... < G(k) < ... < G(n) = G.
c
c     each g(k) (k=1,...,n) has mx(k) by my(k) by mz(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c         mz(k) = kzr*[2**(max0(kez+k-n,1)-1)] + 1
c
c
c
c ... iguess=iparm(17)
c
c          = 0 if no initial guess to the pde is provided
c              and/or full multigrid cycling beginning at the
c              coarsest grid level is desired.
c
c          = 1 if an initial guess to the pde at the finest grid
c              level is provided in phi (see below).  in this case
c              cycling beginning or restarting at the finest grid
c              is initiated.
c
c *** comments on iguess = 0 or 1 . . .
c
c
c     setting iguess=0 forces full multigrid or "fmg" cycling.  phi
c     must be initialized at all grid points.  it can be set to zero at
c     non-Dirchlet grid points if nothing better is available.  the
c     values set in phi when iguess = 0 are passed and down and serve
c     as an initial guess to the pde at the coarsest grid level where
c     multigrid cycling commences.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c *** time dependent problems . . .
c
c     assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at non-Dirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(18)
c
c          the exact number of cycles executed between the finest
c          (nx by ny by nz) and the coarsest ((ixp+1) by (jyq+1) by
c          (kzr+1)) grid levels when tolmax=fparm(7)=0.0 (no error
c          control). when tolmax=fparm(7).gt.0.0 is input (error control)
c          then maxcy is a limit on the number of cycles between the
c          finest and coarsest grid levels.  in any case, at most
c          maxcy*(iprer+ipost) relaxation sweeps are performed at the
c          finest grid level (see iprer=mgopt(2),ipost=mgopt(3) below)
c          when multigrid iteration is working "correctly" only a few
c          cycles are required for convergence.  large values for maxcy
c          should not be required.
c
c
c ... method = iparm(19)
c
c
c          = 0 for gauss-seidel pointwise relaxation with red/black ordering
c
c           This is the only relaxation method offered with cud3sp.  Line
c           or planar relaxation would "lose" the significant savings in
c           work space length defeating the purpose of cud3sp.  If line
c           or planar relaxation is required then use cud3.  method is
c           used as an argument only to focus attention on the purpose
c           of cud3sp.
c
c ... length = iparm(20)
c
c          the length of the work space provided in vector work.
c          This is considerably less then the work space required by
c          the nonseparable solver cud3.
c
c            length = 7*(nx+2)*(ny+2)*(nz+2)/2
c
c          will usually but not always suffice.  The exact minimal length
c          depends on the grid size arguments.  It can be predetermined
c  ***     for the current input arguments by calling cud3sp with iparm(20)
c          set equal to zero and printing iparm(21) or (in f90) dynamically
c          allocating the work space using the value in iparm(21) in a
c          subsequent cud3sp call.
c
c ... fparm                                                                     
c
c          a floating point vector of length 8 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in cud3sp and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... ze=fparm(5), zf=fparm(6)
c
c          the range of the z independent variable. ze must                     
c          be less than zf.                                                     
c
c
c ... tolmax = fparm(7)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j,k)
c          and phi2(i,j,k) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(abs(phi2(i,j,k)-phi1(i,j,k))) for all i,j,k
c
c          and
c
c              phmax = max(abs(phi2(i,j,k))) for all i,j,k
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(7)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible DO NOT use error control!).
c
c
c ... work                                                                      
c
c          a complex array that must be provided for work space.
c          see length = iparm(20). the values in work must be preserved
c          if cud3sp is called again with intl=iparm(1).ne.0 or if cud34sp
c          is called to improve accuracy.
c
c
c ... bndyc                                                                     
c
c          a subroutine with arguments (kbdy,xory,yorz,alfa,gbdy).
c          which are used to input complex mixed boundary conditions.
c          the boundaries are numbered one thru six and the form of
c          conditions are described below.
c                                                                               
c
c     (1) the kbdy=1 boundary
c
c     this is the (y,z) plane x=xa where nxa=iparm(2) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dx + alfxa*p(xa,y,z) = gbdxa(y,z)
c
c     in this case kbdy=1,xory=y,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfxa,gbdxa(y,z) must be returned.
c
c
c     (2) the kbdy=2 boundary
c
c     this is the (y,z) plane x=xb where nxb=iparm(3) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dx + alfxb*p(xb,y,z) = gbdxb(y,z)
c
c     in this case kbdy=2,xory=y,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfxb,gbdxb(y,z) must be returned.
c
c
c     (3) the kbdy=3 boundary
c
c     this is the (x,z) plane y=yc where nyc=iparm(4) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dy + alfyc*p(x,yc,z) = gbdyc(x,z)
c
c     in this case kbdy=3,xory=x,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfyc,gbdyc(x,z) must be returned.
c
c
c     (4) the kbdy=4 boundary
c
c     this is the (x,z) plane y=yd where nyd=iparm(5) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dy + alfyd*p(x,yd,z) = gbdyd(x,z)
c
c     in this case kbdy=4,xory=x,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfyd,gbdyd(x,z) must be returned.
c
c                                                                               
c     (5) the kbdy=5 boundary
c
c     this is the (x,y) plane z=ze where nze=iparm(6) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dz + alfze*p(x,y,ze) = gbdze(x,y)
c
c     in this case kbdy=5,xory=x,yorz=y will be input to bndyc and
c     alfa,gbdy corresponding to alfze,gbdze(x,y) must be returned.
c
c
c     (6) the kbdy=6 boundary
c
c     this is the (x,y) plane z=zf where nzf=iparm(7) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dz + alfzf*p(x,y,zf) = gbdzf(x,y)
c
c     in this case kbdy=6,xory=x,yorz=y will be input to bndyc and
c     alfa,gbdy corresponding to alfzf,gbdzf(x,y) must be returned.
c
c                                                                               
c *** alfa,gbdy must be delcared complex.  alfa is constant.
c
c *** bndyc must provide the mixed boundary condition
c     values in correspondence with those flagged in iparm(2)
c     thru iparm(7).  if all boundaries are specified then
c     cud3sp will never call bndyc.  even then it must be entered
c     as a dummy subroutine. bndyc must be declared
c     external in the routine calling cud3sp.  the actual
c     name chosen may be different.
c
c
c ... cofx
c
c         a subroutine with arguments (x,cxx,cx,cex) which provides the
c         known complex coefficients of the x derivative terms for the pde
c         at any grid point x.  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         external.
c
c ... cofy
c
c         a subroutine with arguments (y,cyy,cy,cey) which provides the
c         known complex coefficients of the y derivative terms for the pde
c         at any grid point y.  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         external.
c
c ... cofz
c
c         a subroutine with arguments (z,czz,cz,cez) which provides the
c         known complex coefficients of the z derivative terms for the pde
c         at any grid point z.  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         external.
c
c ... rhs                                                                       
c
c          an array dimensioned nx by ny by nz which contains
c          the given right hand side values on the uniform 3-d mesh.            
c          rhs(i,j,k) = r(xi,yj,zk) for i=1,...,nx and j=1,...,ny               
c          and k=1,...,nz.
c
c ... phi                                                                       
c
c          an array dimensioned nx by ny by nz .  on input phi must
c          contain specified boundary values and an initial guess
c          to the solution if flagged (see iguess=iparm(17)=1).  for
c          example, if nyd=iparm(5)=1 then phi(i,ny,k) must be set
c          equal to p(xi,yd,zk) for i=1,...,nx and k=1,...,nz prior to
c          calling cud3sp.  the specified values are preserved by cud3sp.
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at non-Dirchlet grid points (this is not
c          checked). these values are projected down and serve as an initial
c          guess to the pde at the coarsest grid level.  set phi to 0.0 at
c          nonDirchlet grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid arguments (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the arguments
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---3-----3-----------3-----------------3---------------     level 1
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --6---6-------6---6-----------6---6-------6---6--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c ***********************************************************************
c ****output arguments**************************************************
c ***********************************************************************
c
c
c ... iparm(21)
c
c          on output iparm(21) contains the actual work space length
c          required for the current grid sizes and method.  This value
c          will be computed and returned even if iparm(20) is less then
c          iparm(21) (see ierror=9).
c
c
c ... iparm(22)
c
c          if error control is selected (tolmax = fparm(7) .gt. 0.0) then
c          on output iparm(22) contains the actual number of cycles executed
c          between the coarsest and finest grid levels in obtaining the
c          approximation in phi.  the quantity (iprer+ipost)*iparm(22) is
c          the number of relaxation sweeps performed at the finest grid level.
c
c
c ... fparm(8)                                                                  
c
c          on output fparm(8) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(8) is computed only if there is error control (tolmax.gt.0.)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c             phdif = max(abs(phi2(i,j,k)-phi1(i,j,k))) for all i,j,k
c
c          and
c
c             phmax = max(abs(phi2(i,j,k))) for all i,j,k
c
c          then
c
c             fparm(8) = phdif/phmax
c
c          is returned whenever phmax.gt.0.0.  in the degenerate case
c          phmax = 0.0, fparm(8) = phdif is returned.
c
c
c
c ... work
c
c          on output work contains intermediate values that must not be
c          destroyed if cud3sp is to be called again with iparm(1)=1 or
c          if cud34sp is to be called to improve the estimate to fourth
c          order.
c
c ... phi
c
c          on output phi(i,j,k) contains the approximation to
c          p(xi,yj,zk) for all mesh points i=1,...,nx; j=1,...,ny;
c          k=1,...,nz.  the last computed iterate in phi is returned
c          even if convergence is not obtained (ierror=-1)
c
c ... ierror
c
c          For intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  Argument checking and discretization
c          is bypassed for intl=1 calls which can only return
c          ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              abs(cx)*dlx > 2.*abs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              abs(cy)*dly > 2.*abs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c
c             cxx = amax1(cxx,0.5*abs(cx)*dx)
c
c                          (and)
c
c             cyy = amax1(cyy,0.5*abs(cy)*dy)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made to preserve convergence of multigrid iteration. if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-3  if the continuous elliptic pde is singular.  this means the
c          boundary conditions are periodic or pure derivative at all
c          boundaries and ce(x,y) = 0.0 for all x,y.  a solution is still
c          attempted but convergence may not occur due to ill-conditioning
c          of the linear system coming from the discretization.  the
c          ierror = -3 flag overrides the ierror=-4 and ierror=-5 nonfatal
c          flags.
c
c
c     =-2  nonellipticity is not checked with cud3sp so this flag is not set.
c          (compare with cud3.f)
c
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd,nze,nzf
c         in iparm(2) through iparm(7)is not 0,1 or 2 or if
c         (nxa,nxb) or (nyc,nyd) or (nze,nzf) are not pairwise zero.
c
c     = 3 if mino(ixp,jyq,kzr) < 2 (ixp=iparm(8),jyq=iparm(9),kzr=iparm(10))
c
c     = 4 if min0(iex,jey,kez) < 1 (iex=iparm(11),jey=iparm(12),kez=iparm(13))
c         or if max0(iex,jey,kez) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or if ny.ne.jyq*2**(jey-1)+1 or
c         if nz.ne.kzr*2**(kez-1)+1 (nx=iparm(14),ny=iparm(15),nz=iparm(16))
c
c     = 6 if iguess = iparm(17) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(18) < 1 (large values for maxcy should not be used)
c
c     = 8 if method = iparm(19) is not equat to zero
c
c     = 9 if length = iparm(20) is too small (see iparm(21) on output
c         for minimum required work space length)
c
c     =10 if xa >= xb or yc >= yd or ze >= zf
c    (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4),ze=fparm(5),zf=fparm(6))
c
c     =11 if tolmax = fparm(7) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(2) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c *********************************************************
c *********************************************************
c
c     end of cud3sp documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="cuh2.txt"><b>CUH2</b></a>
<PRE>
c
c     file cuh2.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file cuh2.d
c
c     contains documentation for:
c     subroutine cuh2(iparm,fparm,wk,iwk,coef,bndyc,rhs,phi,mgopt,ierror)
c     a sample fortran driver is file "tcuh2.f".
c
c ... required mudpack files
c
c     cudcom.f, cuhcom.f
c
c ... purpose
c
c     the "hybrid" multigrid/direct method code cuh2 approximates the
c     same 2-d nonseparable elliptic pde as the mudpack solver cud2.
c     cuh2 combines the efficiency of multigrid iteration with the certainty
c     a direct method.  the basic algorithm is modified by using banded
c     gaussian elimination in place of relaxation whenever the coarsest
c     subgrid is encountered within multigrid cycling.  this provides
c     additional grid size flexibility by eliminating the usual multigrid
c     constraint that the coarsest grid consist of "few" points for effective
c     error reduction with multigrid cycling.  In many cases the hybrid method
c     provides more robust convergence characteristics than multigrid cycling
c     alone.
c
c     The form of the pde solved is:
c
c
c          cxx(x,y)*pxx + cyy(x,y)*pyy + cx(x,y)*px + cy(x,y)*py +
c
c          ce(x,y)*p(x,y) = r(x,y).
c
c
c     pxx,pyy,px,py are second and first partial derivatives of the
c     unknown complex solution function p(x,y) with respect to the
c     independent variables x,y.  cxx,cyy,cx,cy,ce are the known
c     complex coefficients of the elliptic pde and r(x,y) is the known
c     complex right hand side of the equation.  Nonseparability means
c     some of the coefficients depend on both x and y.  if the pde
c     is separable subroutine cud2sp should be used instead
c     of cud2 or cuh2.
c
c *** cuh2 becomes a full direct method if grid size arguments are chosen
c     so that the coarsest and finest grids coincide.  choosing iex=jey=1
c     and ixp=nx-1, jyq=ny-1 (iex=iparm(6),jey=iparm(7),ixp=iparm(8),
c     jyq=iparm(9),nx=iparm(10),ny=iparm(11)) will set gaussian elimination
c     on the nx by ny grid.
c
c
c ... argument differences with cud2.f
c
c     the input and output arguments of cuh2 are almost identical to the
c     arguments of cud2 (see cud2.d) with the following exceptions:
c
c     (1) the complex work space vector "wk" requires
c
c              (ixp+1)*(jyq+1)*(2*ixp+3)
c
c         additional words of storage (ixp = iparm(6), jyq = iparm(7))
c         if periodic boundary conditions are not flagged in the y direction
c         (nyc .ne. 0 where nyc = iparm(4)) or
c
c              (ixp+1)*[2*(ixp+1)*(2*jyq-1)+jyq+1]
c
c         additional words of storage if periodic boundary conditions are
c         flagged in the y direction (nyc = 0).  the extra work space is
c         used for a direct solution with gaussian elimination whenever the
c         coarsest grid is encountered within multigrid cycling.
c
c     (2) An integer work space iwk of length at least (ixp+1)*(jyq+1)
c         must be provided.
c
c     (3) jyq must be greater than 2 if periodic boundary conditions
c         are flagged in the y direction and ixp must be greater than
c         2 if periodic boundary conditions are flagged in the x direction.
c         inputting jyq = 2 when nyc = 0 or inputting ixp = 2 when nxa = 0
c         will set the fatal error flag ierror=3
c
c *** (4) it is no longer necessary that ixp and jyq be "small" for
c         effective error reduction with multigrid iteration.  there
c         is no reduction in convergence rates when larger values for
c         ixp or jyq are used .  this provides additional flexibility
c         in choosing grid size.  in many cases cuh2 provides more
c         robust convergence than cud2.  it can be used in place of
c         cud2 for all nonsingular problems (see (5) below).
c
c     (5) iguess = iparm(11) = 1 (flagging an initial guess) or
c         maxcy = iparm(14) > 1 (setting more than one multigrid
c         cycle) are not allowed if cuh2 becomes a full direct method
c         by choosing iex = jey = 1 (iex = iparm(8),jey = iparm(9)).
c         this conflicting combination of input arguments for multigrid
c         iteration and a full direct method set the fatal error flag
c
c              ierror = 13
c
c         iguess = 0 and maxcy = 1 are required when cuh2 becomes a
c         full direct method.
c
c     (6) if a "singular" pde is detected (see ierror=-3 description in cud2.d;
c         ce(x,y) = 0.0 for all x,y and the boundary conditions are a combination
c         of periodic and/or pure derivatives) then cuh2 sets the fatal error
c         flag
c
c              ierror = 14
c
c         The direct method utilized by cuh2 would likely cause a division
c         by zero in the singular case.  cud2 can be tried for singular problems
c
c
c ... grid size considerations
c
c     (1) flexibility
c
c         cuh2 should be used in place of cud2 whenever grid size
c         requirements do not allow choosing ixp and jyq to be "small"
c         positive integers (typically less than 4).
c
c         example:
c
c         suppose we wish to solve an elliptic pde on a one degree grid on
c         the full surface of a sphere.  choosing ixp = jyq = 45 and iex = 4
c         and jyq = 3 fits the required 361 by 181 grid exactly.  multigrid
c         cycling will be used on the sequence of subgrid sizes:
c
c           46 x 46  <  91 x 46  <  181 x 91  <  361 x 181
c
c         the 46 x 46 coarsest subgrid has too much resolution for effective
c         error reduction with relaxation only.  cuh2 circumvents this
c         difficulty by generating an exact direct solution (modulo roundoff
c         error) whenever the coarsest grid is encountered.
c
c     (2) additional work space (see (1) under "arguments differences") is
c         required by cuh2 to implement gaussian elimination at the coarsest
c         grid level.  this may limit the size of ixp and jyq.
c
c     (3) operation counts
c
c         for simplicity, assume p = ixp = jyq and n = nx = ny.  banded
c         gaussian elimination requires o(p**4) operations for solution
c         on the coarsest subgrid while multigrid iteration is a o(n**2)
c         algorithm. these are approximately balanced when
c
c           p**4 =: (n/(2**k))**4 =: n**2
c
c         or
c
c           k =: log2(n)/2
c
c         grid levels are chosen with the hybrid method.  so if
c         p is approximately equal to
c
c           n/(2**(log2(n)/2))
c
c         then the direct method and multigrid parts of the hybrid algorithm
c         require roughly the same amount of computer time.  larger values
c         for p mean the direct method will dominate the computation.  smaller
c         values mean the hybrid method will cost only marginally more than
c         multigrid iteration with coarse grid relaxation.
c
c
c *** the remaining documentation is almost identical to cud2.d
c     except for the modifications already indicated.
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny grid.  the grid
c     is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1)
c
c     be the uniform grid increments in the x,y directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly
c
c     for i=1,...,nx and j=1,...,ny  denote the x,y uniform mesh points
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 17 used to pass integer
c          arguments.  iparm is set internally and defined as
c          follows:
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      an approximation is not generated after an intl=0 call!
c          cuh2 should be called with intl=1 to approximate the elliptic
c          pde discretized by the intl=0 call.  intl=1 should also
c          be input if cuh2 has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  this will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) cuh2 is being recalled for additional accuracy.  in
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) cuh2 is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) cuh2 is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to cuh2

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by coef (see below) have
c              changed since the previous call
c
c          (e) any of the "alfa" coefficients input by bndyc (see below)
c              have changed since the previous call.
c
c          if any of (a) through (e) are true then the elliptic pde
c          cust be discretized or rediscretized.  if none of (a)
c          through (e) holds, calls can be made with intl=1.
c          incorrect calls with intl=1 will produce erroneous results.
c  ***     the values set in the saved work space "work" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the edge x=xa
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y
c            (if nxa=0 then nxb=0 is required, see ierror = 2)
c
c        = 1 if p(xa,y) is specified (this must be input thru phi(1,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see bndyc)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the edge x=xb
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y)
c            (if nxb=0 then nxa=0 is required, see ierror = 2)
c
c        = 1 if p(xb,y) is specified (this must be input thru phi(nx,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see bndyc)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the edge y=yc
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c            (if nyc=0 then nyd=0 is required, see ierror = 2)
c
c        = 1 if p(x,yc) is specified (this must be input thru phi(i,1))
c
c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see bndyc)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the edge y=yd
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c             (if nyd=0 then nyc=0 is required, see ierror = 2)
c
c        = 1 if p(x,yd) is specified (this must be input thru phi(i,ny))
c
c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see bndyc)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(6)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the x direction is not used.
c          if ixp > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of ixp can be removed by increasing iex = iparm(8)
c          without changing nx = iparm(10).
c
c
c ... jyq = iparm(7)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the y direction is not used.
c          if jyq > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of jyq can be removed by increasing jey = iparm(9)
c          without changing ny = iparm(11).
c
c
c ... iex = iparm(8)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx.
c
c
c ... jey = iparm(9)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(7)
c          as small as possible within grid size constraints when
c          defining ny.
c
c
c
c ... nx = iparm(10)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(6), iex = iparm(8).
c
c
c ... ny = iparm(11)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(7), jey = iparm(9).
c
c
c *** example
c
c         suppose a solution is wanted on a 33 by 97 grid.  then
c         ixp=2, jyq=6 and iex=jey=5 could be used.  a better
c         choice would be ixp=2, jyq=3, and iex=5, jey=6.
c
c *** grid size flexibility considerations:
c
c     the hybrid multigrid/direct method code cuh2 provides more grid size
c     flexibility than cud2 by removing the constraint that ixp and jyq are
c     2 or 3.  this is accomplished by using a direct method whenever the
c     coarsest (ixp+1) x (jyq+1) grid is encountered in multigrid cycling.
c     if nx = ixp+1 and ny = jyq+1 then cuh2 becomes a full direct method.
c     cuh2 is roughly equivalent to cud2 in efficiency as long as ixp and
c     jyq remain "small".   if the problem to be approximated requires
c     a grid neither cud2 or cuh2 can exactly fit then another option
c     is to generate an approximation on a "close grid" using cud2 or cuh2.
c     then transfer the result to the required grid using cubic interpolation
c     via the package "regridpack"(contact john adams about this software)
c
c *** note
c
c     let G be the nx by ny fine grid on which the approximation is
c     generated and let n = max0(iex,jey).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         G(1) < ... < G(k) < ... < G(n) = g.
c
c     each G(k) (k=1,...,n) has mx(k) by my(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c     If iex = jey = 1 then G(1) = G(n) and cuh2 solves the problem
c     directly with block banded Gaussian elimination.  Otherwise
c     cuh2 replaces relaxation with a direct method on G(1).
c
c ... iguess=iparm(12)
c
c          = 0 if no initial guess to the pde is provided
c
c          = 1 if an initial guess to the pde is at the finest grid
c              level is provided in phi (see below)
c
c     comments on iguess = 0 or 1 . . .
c
c     even if iguess = 0, phi must be initialized at all grid points (this
c     is not checked).  phi can be set to 0.0 at non-dirchlet grid points
c     if nothing better is available.  the values set in phi when iguess = 0
c     are passed down and serve as an initial guess to the pde at the coarsest
c     grid level where cycling commences.  in this sense, values input in
c     phi always serve as an initial guess.  setting iguess = 0 forces full
c     multigrid cycling beginning at the coarsest and finishing at the finest
c     grid level.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c     time dependent problems . . .
c
c *** assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at nondirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(13)
c
c          the exact number of cycles executed between the finest (nx by
c          ny) and the coarsest ((ixp+1) by (jyq+1)) grid levels when
c          tolmax=fparm(5)=0.0 (no error control).  when tolmax > 0.0
c          is input (error control) then maxcy is a limit on the number
c          of cycles between the finest and coarsest grid levels.  in
c          any case, at most maxcy*(iprer+ipost) relaxation sweeps are
c          are performed at the finest grid level (see iprer=mgopt(2),
c          ipost=mgopt(3) below).  when multigrid iteration is working
c          "correctly" only a few are required for convergence.  large
c          values for maxcy should not be necessary.
c
c
c ... method = iparm(14) determines the method of relaxation
c              (gauss-seidel based on alternating points or lines)
c
c          = 0 for  point relaxation
c
c          = 1 for line relaxation in the x direction
c
c          = 2 for line relaxation in the y direction
c
c          = 3 for line relaxation in both the x and y direction
c
c
c *** choice of method. . .
c
c     let fx represent the quantity cabs(cxx(x,y))/dlx**2 over the solution region.
c
c     let fy represent the quantity cabs(cyy(x,y))/dly**2 over the solution region
c
c     if fx,fy are roughly the same size and do not vary too much over
c     the solution region choose method = 0.  if this fails try method=3.
c
c     if fx is much greater than fy choose method = 1.
c
c     if fy is much greater than fx choose method = 2
c
c     if neither fx or fy dominates over the solution region and they
c     both vary considerably choose method = 3.
c
c
c ... length = iparm(15)
c
c          the length of the work space provided in vector work (see below).
c          let isx = 0 if method = 0 or method = 2
c          let isx = 3 if method = 1 or method = 3 and nxa.ne.0
c          let isx = 5 if method = 1 or method = 3 and nxa.eq.0
c          let jsy = 0 if method = 0 or method = 1
c          let jsy = 3 if method = 2 or method = 3 and nyc.ne.0
c          let jsy = 5 if method = 2 or method = 3 and nyc.eq.0
c
c          let ldir = (ixp+1)*(jyq+1)*(2*ixp+3) if nyc.ne.0 or
c          let ldir = (ixp+1)*[2*(ixp+1)*(2*jyq-1)+jyq+1] if nyc=0
c
c          then . . .
c
c            length = 4*[nx*ny*(10+isx+jsy)+8*(nx+ny+2)]/3 + ldir
c
c          will suffice in most cases.  the exact minimal work space
c          length required for the current nx,ny and method is output
c          in iparm(16) (even if iparm(15) is too small).  this will be
c          less then the value given by the simplified formula above
c          in most cases.
c
c
c ... fparm                                                                     
c
c          a floating point vector of length 6 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in cuh2 and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... tolmax = fparm(5)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j)
c          and phi2(i,j) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(cabs(phi2(i,j)-phi1(i,j))) for all i,j
c
c          and
c
c              phmax = max(cabs(phi2(i,j))) for all i,j
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(5)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible DO NOT error control!).
c
c ... wk
c
c          a one dimensional complex saved work space (see iparm(15) for
c          length) which must be preserved from the previous call when
c          calling with intl=iparm(1)=1.
c
c ... iwk
c
c          an integer vector dimensioned of length at least (ixp+1)*(jyq+1)
c          (ixp = iparm(6),jyq=iparm(7)) in the routine calling cuh2.
c          The length of iwk is not checked!  If iwk has length less than
c          (ixp+1)*(jyq+1) then undetectable errors will result.
c
c ... bndyc                                                                     
c
c          a subroutine with  arguments (kbdy,xory,alfa,gbdy) which
c          are used to input mixed boundary conditions to cuh2. bndyc
c          must be declared "external" in the program calling cuh2.
c          kbdy is type integer, xory type real, alfa,gbdy type complex
c          the boundaries are numbered one thru four and the mixed
c          derivative boundary conditions are described below (see the
c          sample driver code "tcuh2.f" for an example of how bndyc is
c          can beset up).
c                                                                               
c          * * * * * * * * * * * *  y=yd
c          *       kbdy=4        *
c          *                     *
c          *                     *
c          *                     *
c          * kbdy=1       kbdy=2 *
c          *                     *
c          *                     *
c          *                     *
c          *       kbdy=3        *
c          * * * * * * * * * * * *  y=yc
c
c          x=xa                  x=xb
c
c
c          (1) the kbdy=1 boundary
c
c          this is the edge x=xa where nxa=iparm(2)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dx + alfxa(y)*p(xa,y) = gbdxa(y)
c
c          in this case kbdy=1,xory=y will be input to bndyc and
c          alfa,gbdy corresponding to alfxa(y),gbdxa(y) must be returned.
c
c
c          (2) the kbdy=2 boundary
c
c          this is the edge x=xb where nxb=iparm(3)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dx + alfxb(y)*p(xb,y) = gbdxb(y)
c
c          in this case kbdy=2,xory=y, will be input to bndyc and
c          alfa,gbdy corresponding to alfxb(y),gbdxb(y) must be returned.
c
c
c          (3) the kbdy=3 boundary
c
c          this is the edge y=yc where nyc=iparm(4)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dy + alfyc(x)*p(x,yc) = gbdyc(x)
c
c          in this case kbdy=3,xory=x will be input to bndyc and
c          alfa,gbdy corresponding to alfyc(x),gbdyc(x) must be returned.
c
c
c          (4) the kbdy=4 boundary
c
c          this is the edge y=yd where nyd=iparm(5)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dy + alfyd(x)*p(x,yd) = gbdyd(x)
c
c          in this case kbdy=4,xory=x will be input to bndyc and
c          alfa,gbdy corresponding to alfyd(x),gbdyd(x) must be returned.
c
c                                                                               
c ***      bndyc must provide the mixed boundary condition values
c          in correspondence with those flagged in iparm(2) thru
c          iparm(5).  if all boundaries are specified or periodic
c          cuh2 will never call bndyc.  even then it must be entered
c          as a dummy subroutine. bndyc must be declared "external"
c          in the routine calling cuh2.  the actual name chosen may
c          be different.
c
c
c ... coef
c
c         a subroutine with arguments (x,y,cxx,cyy,cx,cy,ce) which
c         provides the known complex coefficients for the elliptic pde at
c         any grid point (x,y).  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         "external."
c
c ... rhs                                                                       
c
c          an array dimensioned nx by ny which contains the given
c          right hand side values on the uniform 2-d mesh.
c
c              rhs(i,j) = r(xi,yj) for i=1,...,nx and j=1,...,ny
c
c ... phi                                                                       
c
c          an array dimensioned nx by ny.  on input phi must contain
c          specified boundary values. for example, if nyd=iparm(5)=1
c          then phi(i,ny) must be set equal to p(xi,yd) for i=1,...nx
c          prior to calling cuh2.  these values are preserved by cuh2.
c          if an initial guess is provided (iguess=iparm(11)=1) it must
c          be input thru phi.
c
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at all grid points (this is not checked).  these
c          values will serve as an initial guess to the pde at the coarsest
c          grid level after a transfer from the fine solution grid.  set phi
c          equal to to 0.0 at all internal and non-specified boundaries
c          grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid parameters (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the parameters
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).  all version 5.0.1
c     mudpack solvers use only fully weighted residual restriction.  The
c     "D" at grid level 1 indicates a direct method is used.
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---D-----D-----------D-----------------D---------------     level 1
c
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --D---D-------D---D-----------D---D-------D---D--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c *** this algorithim is modified with the hybrid solvers which use
c     a direct method whenever grid level 1 is encountered.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c
c **********************************************************************
c *** output arguments ************************************************
c **********************************************************************
c
c
c ... iparm(16)  *** set for intl=0 calls only
c
c          on output iparm(16) contains the actual work space length
c          required.  this will usually be less than that given by the
c          simplified formula for length=iparm(15) (see as input argument)
c
c
c ... iparm(17)  *** set for intl=1 calls only
c
c          on output iparm(17) contains the actual number of multigrid cycles
c          between the finest and coarsest grid levels used to obtain the
c          approximation when error control (tolmax > 0.0) is set.
c
c
c ... fparm(6)   *** set for intl=1 calls with fparm(5) > 0. only
c
c          on output fparm(6) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(6) is computed only if there is error control (tolmax > 0.0)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c               phdif = max(cabs(phi2(i,j)-phi1(i,j))) over all i,j
c
c          and
c
c               phmax = max(cabs(phi2(i,j)) over all i,j
c
c          then
c
c               fparm(6) = phdif/phmax
c
c          is returned whenever phmax > 0.0. in the degenerate case
c          phmax = 0.0, fparm(6) = phdif is returned.
c
c
c ... work
c
c          on output work contains intermediate values that must not
c          be destroyed if cuh2 is to be called again with intl=1
c
c
c ... phi   *** for intl=1 calls only
c
c          on output phi(i,j) contains the approximation to p(xi,yj)
c          for all mesh points i = 1,...,nx and j=1,...,ny.  the last
c          computed iterate in phi is returned even if convergence is
c          not obtained
c
c
c ... ierror
c
c          for intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  discretization is bypassed for intl=1 calls
c          which can only return ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              cabs(cx)*dlx > 2.*cabs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              cabs(cy)*dly > 2.*cabs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c
c             cxx = cmplx(0.5*cabs(cx)*dx,0.0)
c
c             cyy = cmplx(0.5*cabs(cy)*dy,0.0)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made when necessary to preserve convergence. if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-2  if the pde is not elliptic
c
c             real(cxx)*real(cyy).le.0.0 or aimag(cxx)*aimag(cyy).le.0.0
c
c          in this case a solution is still attempted although convergence
c          may not occur due to ill-conditioning of the linear system.
c          the ierror = -2 flag overrides the ierror=-5,-4 nonfatal
c          flags.
c
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd
c         in iparm(2),iparm(3),iparm(4),iparm(5) are not 0,1 or 2
c         or if nxa,nxb or nyc,nyd are not pairwise zero.
c
c     = 3 if mino(ixp,jyq) < 2 (ixp = iparm(6), jyq = iparm(7))
c         of if ixp < 3 when nxa=0 or if jyq < 3 when nyc=0.
c
c     = 4 if min0(iex,jey) < 1 (iex = iparm(8), jey = iparm(9)) or
c         if max0(iex,jey) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or ny.ne.jyq*2**(jey-1)+1
c         (nx = iparm(10), ny = iparm(11))
c
c     = 6 if iguess = iparm(12) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(13) < 1
c
c     = 8 if method = iparm(14) is not 0,1,2, or 3
c
c     = 9 if length = iparm(15) is too small (see iparm(16) on output
c         for minimum required work space length)
c
c     =10 if xa >= xb or yc >= yd
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4))
c
c     =11 if tolmax = fparm(5) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(1) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c     =13 if iex=jey=1 (full direct method) and iguess=1 or maxcy > 1
c
c     =14 if the elliptic pde is singular (see ierror=-3 in cud2.d)
c
c *********************************************************
c *********************************************************
c
c     end of cuh2 documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="cuh24.txt"><b>CUH24</b></a>
<PRE>
c
c     file cuh24.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file cuh24.d
c
c     contains documentation for:
c     subroutine cuh24(wk,iwk,phi,ierror)
c     A sample fortran driver is file "tcuh24.f".
c
c ... required MUDPACK files
c
c     cuh2.f, cudcom.f
c
c ... purpose
c
c     cuh24 attempts to improve the estimate in phi, obtained by calling
c     cuh2,  from second to fourth order accuracy.  see the file "cuh2.d"
c     for a detailed discussion of the elliptic pde approximated and
c     arguments "wk,iwk,phi" which are also part of the argument list for
c     cuh2.
c
c ... assumptions
c
c     *  phi contains a second-order approximation from an earlier cuh2 call
c
c     *  arguments "wk,iwk,phi" are the same used in calling cuh2
c
c     *  "wk,iwk,phi" have not changed since the last call to cuh2
c
c     *  the finest grid level contains at least 6 points in each direction
c
c
c *** warning
c
c     if the first assumption is not true then a fourth order approximation
c     cannot be produced in phi.  the last assumption (adequate grid size)
c     is the only one checked. failure in any of the others can result in
c     in an undetectable error.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections"
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... error parameter
c
c     = 0 if no error is detected
c
c     = 30 if min0(nx,ny) < 6 where nx,ny are the fine grid sizes
c          in the x,y directions.
c                                                                               
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of cuh24 documentation
c
c  ***********************************************************************
c  ***********************************************************************
c
</PRE>
<HR>
 
<a name="cuh24cr.txt"><b>CUH24CR</b></a>
<PRE>
c
c     file cuh24cr.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file cuh24cr.d
c
c     contains documentation for:
c     subroutine cuh24cr(wk,iwk,coef,bndyc,phi,ierror)
c     A sample fortran driver is file "tcuh24cr.f".
c
c ... required MUDPACK files
c
c     cuh2cr.f, cudcom.f
c
c ... purpose
c
c     cuh24cr attempts to improve the estimate in phi, obtained by calling
c     cuh2cr,  from second to fourth order accuracy.  see the file "cuh2cr.d"
c     for a detailed discussion of the elliptic pde approximated and
c     arguments "wk,iwk,coef,bndyc,phi" which are also part of the argument
c     list for cuh2cr.
c
c ... assumptions
c
c     *  phi contains a second-order approximation from an earlier cuh2cr call
c
c     *  arguments "wk,iwk,coef,bndyc,phi" are the same used in calling cuh2cr
c
c     *  "wk,iwk,coef,bndyc,phi" have not changed since the last call to cuh2cr
c
c     *  the finest grid level contains at least 6 points in each direction
c
c
c *** warning
c
c     if the first assumption is not true then a fourth order approximation
c     cannot be produced in phi.  the last assumption (adequate grid size)
c     is the only one checked. failure in any of the others can result in
c     in an undetectable error.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections"
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... error parameter
c
c     = 0 if no error is detected
c
c     = 30 if min0(nx,ny) < 6 where nx,ny are the fine grid sizes
c          in the x,y directions.
c                                                                               
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of cuh24cr documentation
c
c  ***********************************************************************
c  ***********************************************************************
c
</PRE>
<HR>
 
<a name="cuh2cr.txt"><b>CUH2CR</b></a>
<PRE>
c
c     file cuh2cr.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file cuh2cr.d
c
c     contains documentation for the complex mudpack solver:
c     subroutine cuh2cr(iparm,fparm,work,iw,coef,bndyc,rhs,phi,mgopt,ierror)
c     a sample fortran driver is file "tcuh2cr.f".
c
c ... required mudpack files
c
c     cudcom.f
c
c ... purpose
c
c     the "hybrid" multigrid/direct method code cuh2cr approximates the
c     same 2-d nonseparable elliptic pde as the mudpack solver cud2cr.
c     cuh2cr combines the efficiency of multigrid iteration with the certainty
c     a direct method.  the basic algorithm is modified by using banded
c     gaussian elimination in place of relaxation whenever the coarsest
c     subgrid is encountered within multigrid cycling.  this provides
c     additional grid size flexibility by eliminating the usual multigrid
c     constraint that the coarsest grid consist of "few" points for effective
c     error reduction with multigrid cycling.  In many cases the hybrid method
c     provides more robust convergence characteristics than multigrid cycling
c     alone.

c     The pde approximated is:
c
c
c          cxx(x,y)*pxx + cxy(x,y)*pxy + cyy(x,y)*pyy + cx(x,y)*px +
c
c          cy(x,y)*py + ce(x,y)*p(x,y) = r(x,y).
c
c
c     pxx,pxy,pyy,px,py are second and first partial derivatives of the
c     unknown complex solution function p(x,y) with respect to the
c     independent variables x,y.  cxx,cxy,cyy,cx,cy,ce are the known
c     complex coefficients of the elliptic pde and r(x,y) is the known
c     complex right hand side of the equation.  The real parts of cxx,cyy
c     or the imaginary parts of cxx,cyy should be positive for all x,y
c     in the solution region (see ierror=-2).  Nonseparability means some
c     of the coefficients depend on both x and y.  if the PDE is separable
c     and cxy = 0 then subroutine cud2sp should be used.
c                                                                               
c *** cuh2cr becomes a full direct method if grid size arguments are chosen
c     so that the coarsest and finest grids coincide.  choosing iex=jey=1
c     and ixp=nx-1, jyq=ny-1 (iex=iparm(6),jey=iparm(7),ixp=iparm(8),
c     jyq=iparm(9),nx=iparm(10),ny=iparm(11)) will set gaussian elimination
c     on the nx by ny grid.
c
c ... argument differences with cud2cr.f
c
c     the input and output arguments of cuh2cr are almost identical to the
c     arguments of cud2cr (see cud2cr.d) with the following exceptions:
c
c     (1) the complex work space vector "wk" requires
c
c              (ixp+1)*(jyq+1)*(2*ixp+3)
c
c         additional words of storage (ixp = iparm(6), jyq = iparm(7))
c         if periodic boundary conditions are not flagged in the y direction
c         (nyc .ne. 0 where nyc = iparm(4)) or
c
c              (ixp+1)*[2*(ixp+1)*(2*jyq-1)+jyq+1]
c
c         additional words of storage if periodic boundary conditions are
c         flagged in the y direction (nyc = 0).  the extra work space is
c         used for a direct solution with gaussian elimination whenever the
c         coarsest grid is encountered within multigrid cycling.
c
c     (2) An integer work space iwk of length at least (ixp+1)*(jyq+1)
c         must be provided.
c
c     (3) jyq must be greater than 2 if periodic boundary conditions
c         are flagged in the y direction and ixp must be greater than
c         2 if periodic boundary conditions are flagged in the x direction.
c         inputting jyq = 2 when nyc = 0 or inputting ixp = 2 when nxa = 0
c         will set the fatal error flag ierror=3
c
c *** (4) it is no longer necessary that ixp and jyq be "small" for
c         effective error reduction with multigrid iteration.  there
c         is no reduction in convergence rates when larger values for
c         ixp or jyq are used .  this provides additional flexibility
c         in choosing grid size.  in many cases cuh2 provides more
c         robust convergence than cud2.  it can be used in place of
c         cud2 for all nonsingular problems (see (5) below).
c
c     (5) iguess = iparm(11) = 1 (flagging an initial guess) or
c         maxcy = iparm(14) > 1 (setting more than one multigrid
c         cycle) are not allowed if cuh2 becomes a full direct method
c         by choosing iex = jey = 1 (iex = iparm(8),jey = iparm(9)).
c         this conflicting combination of input arguments for multigrid
c         iteration and a full direct method set the fatal error flag
c
c              ierror = 13
c
c         iguess = 0 and maxcy = 1 are required when cuh2 becomes a
c         full direct method.
c
c     (6) if a "singular" pde is detected (see ierror=-3 description in cud2.d;
c         ce(x,y) = 0.0 for all x,y and the boundary conditions are a combination
c         of periodic and/or pure derivatives) then cuh2 sets the fatal error
c         flag
c
c              ierror = 14
c
c         The direct method utilized by cuh2 would likely cause a division
c         by zero in the singular case.  cud2 can be tried for singular problems
c
c
c ... grid size considerations
c
c     (1) flexibility
c
c         cuh2 should be used in place of cud2 whenever grid size
c         requirements do not allow choosing ixp and jyq to be "small"
c         positive integers (typically less than 4).
c
c         example:
c
c         suppose we wish to solve an elliptic pde on a one degree grid on
c         the full surface of a sphere.  choosing ixp = jyq = 45 and iex = 4
c         and jyq = 3 fits the required 361 by 181 grid exactly.  multigrid
c         cycling will be used on the sequence of subgrid sizes:
c
c           46 x 46  <  91 x 46  <  181 x 91  <  361 x 181
c
c         the 46 x 46 coarsest subgrid has too much resolution for effective
c         error reduction with relaxation only.  cuh2 circumvents this
c         difficulty by generating an exact direct solution (modulo roundoff
c         error) whenever the coarsest grid is encountered.
c
c     (2) additional work space (see (1) under "arguments differences") is
c         required by cuh2 to implement gaussian elimination at the coarsest
c         grid level.  this may limit the size of ixp and jyq.
c
c     (3) operation counts
c
c         for simplicity, assume p = ixp = jyq and n = nx = ny.  banded
c         gaussian elimination requires o(p**4) operations for solution
c         on the coarsest subgrid while multigrid iteration is a o(n**2)
c         algorithm. these are approximately balanced when
c
c           p**4 =: (n/(2**k))**4 =: n**2
c
c         or
c
c           k =: log2(n)/2
c
c         grid levels are chosen with the hybrid method.  so if
c         p is approximately equal to
c
c           n/(2**(log2(n)/2))
c
c         then the direct method and multigrid parts of the hybrid algorithm
c         require roughly the same amount of computer time.  larger values
c         for p mean the direct method will dominate the computation.  smaller
c         values mean the hybrid method will cost only marginally more than
c         multigrid iteration with coarse grid relaxation.
c
c
c *** the remaining documentation is almost identical to cud2.d
c     except for the modifications already indicated.
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny grid.  the grid
c     is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1)
c
c     be the uniform grid increments in the x,y directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly
c
c     for i=1,...,nx and j=1,...,ny  denote the x,y uniform mesh points
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 17 used to pass integer
c          arguments.  iparm is set internally and defined as
c          follows:
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      an approximation is not generated after an intl=0 call!
c          cuh2cr should be called with intl=1 to approximate the elliptic
c          pde discretized by the intl=0 call.  intl=1 should also
c          be input if cuh2cr has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  this will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) cuh2cr is being recalled for additional accuracy.  in
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) cuh2cr is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) cuh2cr is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to cuh2cr

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by coef (see below) have
c              changed since the previous call
c
c          (e) any of the "alfa" coefficients input by bndyc (see below)
c              have changed since the previous call.
c
c          if any of (a) through (e) are true then the elliptic pde
c          must be discretized or rediscretized.  if none of (a)
c          through (e) holds, calls can be made with intl=1.
c          incorrect calls with intl=1 will produce erroneous results.
c  ***     the values set in the saved work space "work" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the edge x=xa
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y
c            (if nxa=0 then nxb=0 is required, see ierror = 2)
c
c        = 1 if p(xa,y) is specified (this must be input thru phi(1,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see bndyc)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the edge x=xb
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y)
c            (if nxb=0 then nxa=0 is required, see ierror = 2)
c
c        = 1 if p(xb,y) is specified (this must be input thru phi(nx,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see bndyc)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the edge y=yc
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c            (if nyc=0 then nyd=0 is required, see ierror = 2)
c
c        = 1 if p(x,yc) is specified (this must be input thru phi(i,1))
c
c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see bndyc)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the edge y=yd
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c             (if nyd=0 then nyc=0 is required, see ierror = 2)
c
c        = 1 if p(x,yd) is specified (this must be input thru phi(i,ny))
c
c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see bndyc)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(6)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the x direction is not used.
c          if ixp > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of ixp can be removed by increasing iex = iparm(8)
c          without changing nx = iparm(10).
c
c
c ... jyq = iparm(7)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the y direction is not used.
c          if jyq > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of jyq can be removed by increasing jey = iparm(9)
c          without changing ny = iparm(11).
c
c
c ... iex = iparm(8)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx.
c
c
c ... jey = iparm(9)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(7)
c          as small as possible within grid size constraints when
c          defining ny.
c
c
c
c ... nx = iparm(10)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(6), iex = iparm(8).
c
c
c ... ny = iparm(11)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(7), jey = iparm(9).
c
c
c *** example
c
c         suppose a solution is wanted on a 33 by 97 grid.  then
c         ixp=2, jyq=6 and iex=jey=5 could be used.  a better
c         choice would be ixp=2, jyq=3, and iex=5, jey=6.
c
c *** note
c
c     let g be the nx by ny fine grid on which the approximation is
c     generated and let n = max0(iex,jey).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         g(1) < ... < g(k) < ... < g(n) = g.
c
c     each g(k) (k=1,...,n) has mx(k) by my(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c
c
c ... iguess=iparm(12)
c
c          = 0 if no initial guess to the pde is provided
c
c          = 1 if an initial guess to the pde is at the finest grid
c              level is provided in phi (see below)
c
c     comments on iguess = 0 or 1 . . .
c
c     even if iguess = 0, phi must be initialized at all grid points (this
c     is not checked).  phi can be set to 0.0 at non-dirchlet grid points
c     if nothing better is available.  the values set in phi when iguess = 0
c     are passed down and serve as an initial guess to the pde at the coarsest
c     grid level where cycling commences.  in this sense, values input in
c     phi always serve as an initial guess.  setting iguess = 0 forces full
c     multigrid cycling beginning at the coarsest and finishing at the finest
c     grid level.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c     time dependent problems . . .
c
c *** assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at nondirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(13)
c
c          the exact number of cycles executed between the finest (nx by
c          ny) and the coarsest ((ixp+1) by (jyq+1)) grid levels when
c          tolmax=fparm(5)=0.0 (no error control).  when tolmax > 0.0
c          is input (error control) then maxcy is a limit on the number
c          of cycles between the finest and coarsest grid levels.  in
c          any case, at most maxcy*(iprer+ipost) relaxation sweeps are
c          are performed at the finest grid level (see iprer=mgopt(2),
c          ipost=mgopt(3) below).  when multigrid iteration is working
c          "correctly" only a few are required for convergence.  large
c          values for maxcy should not be necessary.
c
c
c ... method = iparm(14) determines the method of relaxation
c              (gauss-seidel based on alternating points or lines)
c
c          = 0 for  point relaxation
c
c          = 1 for line relaxation in the x direction
c
c          = 2 for line relaxation in the y direction
c
c          = 3 for line relaxation in both the x and y direction
c
c
c *** choice of method. . .
c
c     let fx represent the quantity cxx(x,y)/dlx**2 over the solution region.
c
c     let fy represent the quantity cyy(x,y)/dly**2 over the solution region
c
c     if fx,fy are roughly the same size and do not vary too much over
c     the solution region choose method = 0.  if this fails try method=3.
c
c     if fx is much greater than fy choose method = 1.
c
c     if fy is much greater than fx choose method = 2
c
c     if neither fx or fy dominates over the solution region and they
c     both vary considerably choose method = 3.
c
c
c ... length = iparm(15)
c
c          the length of the work space provided in complex work
c          space "work")
c
c          let isx = 0 if method = 0 or method = 2
c          let isx = 3 if method = 1 or method = 3 and nxa.ne.0
c          let isx = 5 if method = 1 or method = 3 and nxa.eq.0
c          let jsy = 0 if method = 0 or method = 1
c          let jsy = 3 if method = 2 or method = 3 and nyc.ne.0
c          let jsy = 5 if method = 2 or method = 3 and nyc.eq.0
c          then . . .
c
c           length = [7*(nx+2)*(ny+2)+4*(11+isx+jsy)*nx*ny]/3
c
c          will suffice in most cases.  the exact minimal work space
c          length required for the current nx,ny and method is output
c          in iparm(16) (even if iparm(15) is too small).  this will be
c          less then the value given by the simplified formula above
c          in most cases.
c
c
c ... fparm                                                                     
c
c          a floating point vector of length 6 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in cuh2cr and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... tolmax = fparm(5)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j)
c          and phi2(i,j) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(abs(phi2(i,j)-phi1(i,j))) for all i,j
c
c          and
c
c              phmax = max(abs(phi2(i,j))) for all i,j
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(5)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible do not use error control!).
c
c ... work                                                                      
c
c          a complex saved work space (see iparm(15) for size) which
c          must be preserved from the previous call when calling with
c          intl=iparm(1)=1.
c
c ... bndyc                                                                     
c
c          a subroutine with  arguments (kbdy,xory,alfa,beta,gama,gbdy) which
c          are used to input mixed boundary conditions to cuh2cr. bndyc
c          must be declared "external" in the program calling cuh2cr.  kbdy
c          is type integer, xory real, and alfa,beta,gama,gbdy type complex.
c          the boundaries are numbered one thru four and the mixed
c          derivative boundary conditions are described below (see the
c          sample driver code "tcuh2cr.f" for an example of how bndyc is
c          can beset up).
c                                                                               
c          * * * * * * * * * * * *  y=yd
c          *       kbdy=4        *
c          *                     *
c          *                     *
c          *                     *
c          * kbdy=1       kbdy=2 *
c          *                     *
c          *                     *
c          *                     *
c          *       kbdy=3        *
c          * * * * * * * * * * * *  y=yc
c
c          x=xa                  x=xb
c
c
c
c    (1)   the kbdy=1 boundary
c
c          this is the edge x=xa where nxa=iparm(2) = 2 flags
c          a mixed boundary condition of the form
c
c             alfxa(y)*px + betxa(y)*py + gamxa(y)*p(xa,y) = gbdxa(y)
c
c          in this case kbdy=1,xory=y will be input to bndyc and
c          alfa,beta,gama,gbdy corresponding to alfxa(y),betxa(y),gamxa(y),
c          gbdxa(y) must be returned.  alfxa(y) = 0. is not allowed for any y.
c          (see ierror = 13)
c
c    (2)   the kbdy=2 boundary
c
c          this is the edge x=xb where nxb=iparm(3) = 2 flags
c          a mixed boundary condition of the form
c
c             alfxb(y)*px + betxb(y)*py + gamxb(y)*p(xb,y) = gbdxb(y)
c
c          in this case kbdy=2,xory=y will be input to bndyc and
c          alfa,beta,gama,gbdy corresponding to alfxb(y),betxb(y),gamxb(y),
c          gbdxb(y) must be returned. alfxb(y) = 0.0 is not allowed for any y.
c          (see ierror = 13)
c
c    (3)   the kbdy=3 boundary
c
c          this is the edge y=yc where nyc=iparm(4) = 2 flags
c          a mixed boundary condition of the form
c
c             alfyc(x)*px + betyc(x)*py + gamyc(x)*p(x,yc) = gbdyc(x)
c
c          in this case kbdy=3,xory=x will be input to bndyc and
c          alfa,beta,gama,gbdy corresponding to alfyc(x),betyc(x),gamyc(x),
c          gbdyc(x) must be returned. betyc(x) = 0.0 is not allowed for any x.
c          (see ierror = 13)
c
c    (4)   the kbdy=4 boundary
c
c          this is the edge y=yd where nyd=iparm(5) = 2 flags
c          a mixed boundary condition of the form
c
c             alfyd(x)*px + betyd(x)*py + gamyd(x)*p(x,yd) = gbdyd(x)
c
c          in this case kbdy=4,xory=x will be input to bndyc and
c          alfa,beta,gama,gbdy corresponding to alfyd(x),betyd(x),gamyd(x),
c          gbdyd(x) must be returned. betyd(x) = 0.0 is not allowed for any x.
c          (see ierror = 13)
c
c                                                                               
c ***      bndyc must provide the mixed boundary condition values
c          in correspondence with those flagged in iparm(2) thru
c          iparm(5).  if all boundaries are specified or periodic
c          cuh2cr will never call bndyc.  even then it must be entered
c          as a dummy subroutine. bndyc must be declared "external"
c          in the routine calling cuh2cr.  the actual name chosen may
c          be different.
c
c
c ... coef
c
c         a subroutine with arguments (x,y,cxx,cxy,cyy,cx,cy,ce) which
c         provides the known complex coefficients for the elliptic pde at
c         any grid point (x,y).  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         "external."
c
c ... rhs                                                                       
c
c          a complex array dimensioned nx by ny which contains the given
c          right hand side values on the uniform 2-d mesh.
c
c              rhs(i,j) = r(xi,yj) for i=1,...,nx and j=1,...,ny
c
c ... phi                                                                       
c
c          a complex array dimensioned nx by ny.  on input phi must contain
c          specified boundary values. for example, if nyd=iparm(5)=1
c          then phi(i,ny) must be set equal to p(xi,yd) for i=1,...nx
c          prior to calling cuh2cr.  these values are preserved by cuh2cr.
c          if an initial guess is provided (iguess=iparm(11)=1) it must
c          be input thru phi.
c
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at all grid points (this is not checked).  these
c          values will serve as an initial guess to the pde at the coarsest
c          grid level after a transfer from the fine solution grid.  set phi
c          equal to to 0.0 at all internal and non-specified boundaries
c          grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid arguments (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the arguments
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).  all version 5.0.1
c     mudpack solvers use only fully weighted residual restriction
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---3-----3-----------3-----------------3---------------     level 1
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --6---6-------6---6-----------6---6-------6---6--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c
c **********************************************************************
c *** output arguments ************************************************
c **********************************************************************
c
c
c ... iparm(16)  *** set for intl=0 calls only
c
c          on output iparm(16) contains the actual work space length
c          required.  this will usually be less than that given by the
c          simplified formula for length=iparm(15) (see as input argument)
c
c
c ... iparm(17)  *** set for intl=1 calls only
c
c          on output iparm(17) contains the actual number of multigrid cycles
c          between the finest and coarsest grid levels used to obtain the
c          approximation when error control (tolmax > 0.0) is set.
c
c
c ... fparm(6)   *** set for intl=1 calls with fparm(5) > 0. only
c
c          on output fparm(6) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(6) is computed only if there is error control (tolmax > 0.0)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c               phdif = max(abs(phi2(i,j)-phi1(i,j))) over all i,j
c
c          and
c
c               phmax = max(abs(phi2(i,j)) over all i,j
c
c          then
c
c               fparm(6) = phdif/phmax
c
c          is returned whenever phmax > 0.0. in the degenerate case
c          phmax = 0.0, fparm(6) = phdif is returned.
c
c
c ... work
c
c          on output work contains intermediate values that must not
c          be destroyed if cuh2cr is to be called again with intl=1
c
c
c ... phi   *** for intl=1 calls only
c
c          on output phi(i,j) contains the approximation to p(xi,yj)
c          for all mesh points i = 1,...,nx and j=1,...,ny.  the last
c          computed iterate in phi is returned even if convergence is
c          not obtained
c
c
c ... ierror
c
c          for intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  argument checking and discretization
c          is bypassed for intl=1 calls which can only return
c          ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              abs(cx)*dlx > 2.*abs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              abs(cy)*dly > 2.*abs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c
c             cxx = amax1(cxx,0.5*abs(cx)*dx)
c
c                          (and)
c
c             cyy = amax1(cyy,0.5*abs(cy)*dy)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made to preserve convergence of multigrid iteration. if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-3  if the continuous elliptic pde is singular.  this means the
c          boundary conditions are periodic or pure derivative at all
c          boundaries and ce(x,y) = 0.0 for all x,y.  a solution is still
c          attempted but convergence may not occur due to ill-conditioning
c          of the linear system coming from the discretization.  the
c          ierror = -3 flag overrides the ierror=-4 and ierror=-5 nonfatal
c          flags.
c
c
c     =-2  if the pde is not elliptic (i.e., cxx*cyy.le.0.0 for some (xi,yj))
c          in this case a solution is still attempted although convergence
c          may not occur due to ill-conditioning of the linear system.
c          the ierror = -2 flag overrides the ierror=-5,-4,-3 nonfatal
c          flags.
c
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd
c         in iparm(2),iparm(3),iparm(4),iparm(5) are not 0,1 or 2
c         or if nxa,nxb or nyc,nyd are not pairwise zero.
c
c     = 3 if mino(ixp,jyq) < 2 (ixp = iparm(6), jyq = iparm(7))
c
c     = 4 if min0(iex,jey) < 1 (iex = iparm(8), jey = iparm(9)) or
c         if max0(iex,jey) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or ny.ne.jyq*2**(jey-1)+1
c         (nx = iparm(10), ny = iparm(11))
c
c     = 6 if iguess = iparm(12) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(13) < 1
c
c     = 8 if method = iparm(14) is not 0,1,2, or 3
c
c     = 9 if length = iparm(15) is too small (see iparm(16) on output
c         for minimum required work space length)
c
c     =10 if xa >= xb or yc >= yd
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4))
c
c     =11 if tolmax = fparm(5) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(1) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c     =13 if there is a pure tangential derivative along a mixed derivative
c         boundary (e.g., nyd = 2 and betyd(x) = 0.0 for some
c         grid point x along y = yd)
c
c     =14 if there is the "singular" condition described below at a
c         cornor which is the intersection of two derivative boundaries.
c
c         (1) the cornor (xa,yc) if nxa=nyc=2 and
c             alfxa(yc)*betyc(xa)-alfyc(xa)*betxa(yc) = 0.0.
c
c         (2) the cornor (xa,yd) if nxa=nyd=2 and
c             alfxa(yd)*betyd(xa)-alfyd(xa)*betxa(yd) = 0.0.
c
c         (3) the cornor (xb,yc) if nxb=nyc=2 and
c             alfxb(yc)*betyc(xb)-alfyc(xb)*betxb(yc) = 0.0.
c
c         (4) the cornor (xb,yd) if nxb=nyd=2 and
c             alfxb(yd)*betyd(xb)-alfyd(xb)*betxb(yd) = 0.0.
c
c *** the conditions described in ierror = 13 or 14 will lead to division
c     by zero during discretization if undetected.
c
c
c *********************************************************
c *********************************************************
c
c     end of cuh2cr documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="cuh3.txt"><b>CUH3</b></a>
<PRE>
c
c     file cuh3.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file cuh3.d
c
c     contains documentation for:
c     subroutine cuh3(iparm,fparm,wk,iw,coef,bndyc,rhs,phi,mgopt,ierror)
c     a sample fortran driver is file "tcuh3.f".
c
c ... required mudpack files
c
c     cudcom.f, cud3ln.f, cud3pn.f
c
c ... purpose
c
c     the complex "hybrid" multigrid/direct method code cuh3 approximates
c     the same 3-d nonseparable elliptic pde as the mudpack solver cud3.
c     the basic algorithm is modified by using block banded gaussian
c     elimination in place of relaxation whenever the coarsest subgrid is
c     encountered within multigrid cycling.  use of the direct method at
c     the coarsest grid level gives cuh3 at least two advantages over cud3:
c
c     (1) improved convergence rates
c
c         the use of a direct method at the coarsest grid level can
c         improve convergence rates at a small additional computational
c         cost if the coarse grid parameters ixp=iparm(8),jyq=iparm(9),
c         kzr=iparm(10) are small relative to the fine grid parameters
c         nx=iparm(14),ny=iparm(15),nz=iparm(16).  this is especially true
c         in the presence of certain boundary conditions.  for example,
c         if all boundary conditions are neuman (pure derivative) and/or
c         periodic then cud3 may fail to converge.  cuh3 should handle
c         these boundary conditions with the expected multigrid efficiency
c         (see tcuh3.f).  in all cases, cuh3 should give convergence
c         rates which equal or exceed cud3.
c
c
c     (2) more resolution choices
c
c         cuh3 allows more grid size flexibility by "relaxing" the
c         constraint on the coarse grid parameters that ixp,jyq,kzr
c         be "very" small (2 or 3 for cud3) for effective error
c         error reduction within multigrid cycling.  convergence
c         rates will not deteoriate with larger values for ixp,
c         jyq,kzr.
c
c *** caution
c
c     because of the very large computational and storage
c     requirements, the three-dimensional dimensional direct
c     method costs can overwhelm the multigrid cycling costs
c     if the coarsest grid is not small relative to the finest
c     solution grid.  this is a user decision set by the choice
c     of coarse and fine grid parameters (see iparm(8) through
c     iparm(16) and iparm(21) descriptions)
c
c     subroutine cuh3 automatically discretizes and attempts to compute
c     the second order finite difference approximation to a three-
c     dimensional linear nonseparable elliptic partial differential
c     equation on a box.  the approximation is generated on a uniform
c     grid covering the box (see mesh description below).  boundary
c     conditions may be any combination of mixed, specified (Dirchlet)
c     or periodic.  the form of the pde solved is . . .
c
c          cxx(x,y,z)*pxx + cyy(x,y,z)*pyy + czz(z,y,z)*pzz +
c
c          cx(x,y,z)*px + cy(x,y,z)*py + cz(x,y,z)*pz +
c
c          ce(x,y,z)*p(x,y,z) = r(x,y,z)
c
c     here cxx,cyy,czz,cx,cy,cz,ce are the known complex coefficients
c     of the pde; pxx,pyy,pzz,px,py,pz are the second and first partial
c     derivatives of the unknown complex solution function p(x,y,z)
c     with respect to the independent variables x,y,z; r(x,y,z) is
c     is the known complex right hand side of the elliptic pde.  cxx,cyy
c     and czz should have real or imaginary parts positive for all (x,y,z)
c                                                                               
c
c ... argument differences with cud3.f
c
c     the input and output arguments of cuh3 are almost identical to the
c     arguments of cud3 (see cud3.d) with the following exceptions:
c
c     (1) let mx=ixp+1, my=jyq+1, mz=kzr+1 (the coarsest grid
c         resolutions, ixp=iparm(8), jyq=iparm(9), kzr=iparm(10))
c         then the work space vector "wk" requires
c
c               mx*my*mz*(2*mx*my+1))           (nze.ne.0)
c
c         additional words of storage if periodic boundary conditions
c         are not flagged in the z direction or
c
c               mx*my*(mz*(4*mx*my+1))          (nze=0)
c
c         additional words of storage if periodic boundary conditions are
c         flagged in the z direction (nze = 0).  the extra work space is
c         used for a direct solution with gaussian elimination whenever the
c         coarsest grid is encountered within multigrid cycling.
c
c     (2) an integer work space iwk of length at least mx*my*mz words
c         must be provided.  the length of iwk is not checked!
c
c     (3) kzr > 2 if nze=0, jyq > 2 if nyc=0, ixp > 2 if nxe = 0 are
c         required (i.e., the coarsest grid must contain at least four
c         points in any direction with periodic boundary conditions,
c         see the expanded meaning of ierror=3).
c
c *** (4) it is no longer necessary that ixp,jyq,kzr be 2 or 3 for
c         effective error reduction with multigrid iteration.  there
c         is no reduction in convergence rates when larger values for
c         ixp,jyq,kzr are used .  this provides additional flexibility
c         in choosing grid size.  in many cases cuh3 provides more
c         robust convergence than cud3.  it can be used in place of
c         cud3 for all nonsingular problems (see (5) below).
c
c     (5) iguess = iparm(17) = 1 (flagging an initial guess) or
c         maxcy = iparm(18) > 1 (setting more than one multigrid
c         cycle) are not allowed if cuh3 becomes a full direct method
c         by choosing iex=jey=kez=1.  this conflicting combination
c         of input arguments for multigrid iteration and a full
c         direct method set the fatal error flag
c
c              ierror = 13
c
c         iguess = 0 and maxcy = 1 are required when cuh3 becomes a
c         full direct method.  ordinarily (see *** caution above) this
c         should not happen except when testing with very coarse resolution.
c
c
c     (6) if a "singular" pde is detected (see ierror=-3 description in
c         cud3.d, ce(x,y) = 0.0 for all x,y and the boundary conditions
c         are a combination of periodic and/or pure derivatives) then cuh3
c         sets the fatal error flag
c
c              ierror = 14
c
c         the direct method utilized by cuh3 would likely cause a near
c         division by zero in the singular case.  cud3 can be tried for
c         singular problems.
c
c ... grid size considerations
c
c     (1) flexibility
c
c         cuh3 should be used in place of cud3 whenever grid size
c         requirements do not allow choosing ixp,jyq,kzr to be 2 or 3.
c
c     (2) additional work space (see (1) under "arguments differences") is
c         required by cuh3 to implement gaussian elimination at the coarsest
c         grid level.  this may limit the size of ixp,jyq,kzr.
c
c     (3) operation counts
c                                                              k
c         for simplicity, assume p=ixp=jyq=kzr and n=nx=ny=nz=2 *p.
c         gaussian elimination requires o(p**7) operations for solution
c         on the coarsest subgrid while multigrid iteration is a o(n**3)
c         algorithm.  consequently the storage and computational
c         requirements for the 3-d direct method will dominate the
c         calculation if p is "large."  note that  o(p**7)=:o(n**3)
c         whenever k =: (4/3)*log2(p) grid levels are used in cycling.
c         larger values mean the direct method will dominate the
c         calculation.  smaller values for k mean the direct method
c         will only marginally add to the cost of multigrid iteration
c         alone.
c
c *** the remaining documentation is almost identical to cud3.d
c     except for the modifications already indicated.
c
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny by nz grid.
c     the grid is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd] x [ze,zf].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1), dlz = (zf-ze)/(nz-1)
c
c     be the uniform grid increments in the x,y,z  directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly, zk = ze+(k-1)*dlz
c
c     for i=1,...,nx; j=1,...,ny; k=1,...,nz  denote the x,y,z uniform
c     mesh points.
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 23 used to efficiently pass
c          integer arguments.  iparm is set internally in cuh3
c          and defined as follows . . .                                         
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      an approximation is not generated after an intl=0 call!
c          cuh3 should be called with intl=1 to approximate the elliptic
c          pde discretized by the intl=0 call.  intl=1 should also
c          be input if cuh3 has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  this will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) cuh3 is being recalled for additional accuracy.  in
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) cuh3 is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) cuh3 is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to cuh3

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by coef (see below) have
c              changed since the previous call
c
c          (e) any of the "alfa" coefficients input by bndyc (see below)
c              have changed since the previous call.
c
c          if any of (a) through (e) are true then the elliptic pde
c          must be discretized or rediscretized.  if none of (a)
c          through (e) holds, calls can be made with intl=1.
c          incorrect calls with intl=1 will produce erroneous results.
c  ***     the values set in the saved work space "wk" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the (y,z) plane x=xa                    
c
c        = 0 if p(x,y,z) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y,z) = p(x,y,z) for all x,y,z)
c
c        = 1 if p(xa,y,z) is specified  (this must be input thru phi(1,j,k))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see "bndyc" description below where kbdy = 1)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the (y,z) plane x=xb                    
c
c        = 0 if p(x,y,z) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y,z) = p(x,y,z) for all x,y,z)
c
c        = 1 if p(xb,y,z) is specified (this must be input thru phi(nx,j,k))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see "bndyc" description below where kbdy = 2)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the (x,z) plane y=yc                    
c
c        = 0 if p(x,y,z) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc,z) = p(x,y,z) for all x,y,z)

c        = 1 if p(x,yc,z) is specified (this must be input thru phi(i,1,k))

c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see "bndyc" description below where kbdy = 3)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the (x,z) plane y=yd                    
c
c        = 0 if p(x,y,z) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc,z) = p(x,y,z) for all x,y,z)

c        = 1 if p(x,yd,z) is specified (this must be input thru phi(i,ny,k))

c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see "bndyc" description below where kbdy = 4)
c
c
c ... nze=iparm(6)
c
c          flags boundary conditions on the (x,y) plane z=ze                    
c
c        = 0 if p(x,y,z) is periodic in z on [ze,zf]
c            (i.e., p(x,y,z+zf-ze) = p(x,y,z) for all x,y,z

c        = 1 if p(x,y,ze) is specified (this must be input thru phi(i,j,1))

c        = 2 if there are mixed derivative boundary conditions at z=ze
c            (see "bndyc" description below where kbdy = 5)
c
c
c ... nzf=iparm(7)
c
c          flags boundary conditions on the (x,y) plane z=zf                    
c
c        = 0 if p(x,y,z) is periodic in z on [ze,zf]
c            (i.e., p(x,y,z+zf-ze) = p(x,y,z) for all x,y,z

c        = 1 if p(x,y,zf) is specified (this must be input thru phi(i,j,nz))

c        = 2 if there are mixed derivative boundary conditions at z=zf
c            (see "bndyc" description below where kbdy = 6)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(8)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(14)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible
c          within grid size requirements.
c
c
c ... jyq = iparm(9)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(15)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible
c          within grid size requirements.
c
c
c ... kzr = iparm(10)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the z direction (see nz = iparm(16)).  "kzr+1"
c          is the number of points on the coarsest z grid visited during
c          multigrid cycling.  kzr should be chosen as small as possible
c          within grid size requirements.
c
c
c ... iex = iparm(11)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(14)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx = iparm(14).
c
c
c ... jey = iparm(12)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(15)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(9)
c          as small as possible within grid size constraints when
c          defining ny = iparm(15).
c
c
c ... kez = iparm(13)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the z direction (see nz = iparm(16)).
c          kez .le. 50 is required.  for efficient multigrid cycling,
c          kez should be chosen as large as possible and kzr=iparm(10)
c          as small as possible within grid size constraints when
c          defining nz = iparm(16).
c
c
c ... nx = iparm(14)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(8), iex = iparm(11).
c
c
c ... ny = iparm(15)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(9), jey = iparm(12).
c
c
c ... nz = iparm(16)
c
c          the number of equally spaced grid points in the interval [ze,zf]
c          (including the boundaries).  nz must have the form
c
c               nz = kzr*(2**(kez-1)) + 1
c
c          where kzr = iparm(10), kez = iparm(13)
c
c
c *** note
c
c     let g be the nx by ny by nz fine grid on which the approximation is
c     generated and let n = max0(iex,jey,kez).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         g(1) < ... < g(k) < ... < g(n) = g.
c
c     each g(k) (k=1,...,n) has mx(k) by my(k) by mz(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c         mz(k) = kzr*[2**(max0(kez+k-n,1)-1)] + 1
c
c     additionally cuh3 implements a direct method whenever g(1) is
c     encountered.
c
c ... iguess=iparm(17)
c
c          = 0 if no initial guess to the pde is provided
c              and/or full multigrid cycling beginning at the
c              coarsest grid level is desired.
c
c          = 1 if an initial guess to the pde at the finest grid
c              level is provided in phi (see below).  in this case
c              cycling beginning or restarting at the finest grid
c              is initiated.
c
c *** comments on iguess = 0 or 1 . . .
c
c
c     setting iguess=0 forces full multigrid or "fmg" cycling.  phi
c     must be initialized at all grid points.  it can be set to zero at
c     non-Dirchlet grid points if nothing better is available.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c *** time dependent problems . . .
c
c     assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at non-Dirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(18)
c
c          the exact number of cycles executed between the finest
c          (nx by ny by nz) and the coarsest ((ixp+1) by (jyq+1) by
c          (kzr+1)) grid levels when tolmax=fparm(7)=0.0 (no error
c          control). when tolmax=fparm(7).gt.0.0 is input (error control)
c          then maxcy is a limit on the number of cycles between the
c          finest and coarsest grid levels.  in any case, at most
c          maxcy*(iprer+ipost) relaxation sweeps are performed at the
c          finest grid level (see iprer=mgopt(2),ipost=mgopt(3) below)
c          when multigrid iteration is working "correctly" only a few
c          cycles are required for convergence.  large values for maxcy
c          should not be required.
c
c
c ... method = iparm(19)
c
c          this sets the method of relaxation (all relaxation
c          schemes in mudpack use red/black type ordering)
c
c          = 0 for gauss-seidel pointwise relaxation
c
c          = 1 for line relaxation in the x direction
c
c          = 2 for line relaxation in the y direction
c
c          = 3 for line relaxation in the z direction
c
c          = 4 for line relaxation in the x and y direction
c
c          = 5 for line relaxation in the x and z direction
c
c          = 6 for line relaxation in the y and z direction
c
c          = 7 for line relaxation in the x,y and z direction
c
c          = 8 for x,y planar relaxation
c
c          = 9 for x,z planar relaxation
c
c          =10 for y,z planar relaxation
c
c ***  choice of method
c
c      this is very important for efficient convergence.  in some cases
c      experimentation may be required.
c
c      let fx represent the quantity cxx(x,y,z)/dlx**2 over the solution box
c
c      let fy represent the quantity cyy(x,y,z)/dly**2 over the solution box
c
c      let fz represent the quantity czz(x,y,z)/dlz**2 over the solution box
c
c      (0) if fx,fy,fz are roughly the same size and do not vary too
c          much choose method = 0.  if this fails try method = 7.
c
c      (1) if fx is much greater then fy,fz and fy,fz are roughly the same
c          size choose method = 1
c
c      (2) if fy is much greater then fx,fz and fx,fz are roughly the same
c          size choose method = 2
c
c      (3) if fz is much greater then fx,fy and fx,fy are roughly the same
c          size choose method = 3
c
c      (4) if fx,fy are roughly the same and both are much greater then fz
c          try method = 4.  if this fails try method = 8
c
c      (5) if fx,fz are roughly the same and both are much greater then fy
c          try method = 5.  if this fails try method = 9
c
c      (6) if fy,fz are roughly the same and both are much greater then fx
c          try method = 6.  if this fails try method = 10
c
c      (7) if fx,fy,fz vary considerably with none dominating try method = 7
c
c      (8) if fx and fy are considerably greater then fz but not necessarily
c          the same size and method=4 fails try method = 8
c
c      (9) if fx and fz are considerably greater then fy but not necessarily
c          the same size and method=5 fails try method = 9
c
c      (10)if fy and fz are considerably greater then fx but not necessarily
c          the same size and method=6 fails try method = 10
c
c
c ... meth2 = iparm(20) determines the method of relaxation used in the planes
c             when method = 8 or 9 or 10.
c
c
c          as above, let fx,fy,fz represent the quantities cxx/dlx**2,
c          cyy/dly**2,czz/dlz**2 over the box.
c
c          (if method = 8)
c
c          = 0 for gauss-seidel pointwise relaxation
c              in the x,y plane for each fixed z
c          = 1 for line relaxation in the x direction
c              in the x,y plane for each fixed z
c          = 2 for line relaxation in the y direction
c              in the x,y plane for each fixed z
c          = 3 for line relaxation in the x and y direction
c              in the x,y plane for each fixed z
c
c          (1) if fx,fy are roughly the same and vary little choose meth2 = 0
c          (2) if fx is much greater then fy choose meth2 = 1
c          (3) if fy is much greater then fx choose meth2 = 2
c          (4) if none of the above or meth2 = 0 fails choose meth2 = 3
c
c          (if method = 9)
c
c          = 0 for gauss-seidel pointwise relaxation with red/black ordering
c              in the x,z plane for each fixed y
c          = 1 for simultaneous line relaxation in the x direction
c              of the x,z plane for each fixed y
c          = 2 for simultaneous line relaxation in the z direction
c              of the x,z plane for each fixed y
c          = 3 for simultaneous line relaxation in the x and z direction
c              of the x,z plane for each fixed y
c
c          (1) if fx,fz are roughly the same and vary little choose meth2 = 0
c          (2) if fx is much greater then fz choose meth2 = 1
c          (3) if fz is much greater then fx choose meth2 = 2
c          (4) if none of the above or meth2 = 0 fails choose meth2 = 3
c
c          (if method = 10)
c
c          = 0 for gauss-seidel pointwise relaxation with red/black ordering
c              in the y,z plane for each fixed x
c          = 1 for simultaneous line relaxation in the y direction
c              of the y,z plane for each fixed x
c          = 2 for simultaneous line relaxation in the z direction
c              of the y,z plane for each fixed x
c          = 3 for simultaneous line relaxation in the y and z direction
c              of the y,z plane for each fixed x
c
c          (1) if fy,fz are roughly the same and vary little choose meth2 = 0
c          (2) if fy is much greater then fz choose meth2 = 1
c          (3) if fz is much greater then fy choose meth2 = 2
c          (4) if none of the above or meth2 = 0 fails choose meth2 = 3
c
c
c ***  note that planar relaxation implements full two-dimensional multigrid
c      cycling for each plane visited during three dimensional multigrid
c      cycling.  Consequently it can be computationally expensive.
c
c ... length = iparm(21)
c
c          the length of the work space provided in vector wk.
c
c          let isx = 3 if method = 1,4,5 or 7 and nxa.ne.0
c          let isx = 5 if method = 1,4,5 or 7 and nxa.eq.0
c          let isx = 0 if method has any other value
c
c          let jsy = 3 if method = 2,4,6 or 7 and nyc.ne.0
c          let jsy = 5 if method = 2,4,6 or 7 and nyc.eq.0
c          let jsy = 0 if method has any other value
c
c          let ksz = 3 if method = 3,5,6 or 7 and nze.ne.0
c          let ksz = 5 if method = 3,5,6 or 7 and nze.eq.0
c          let ksz = 0 if method has any other value
c
c
c
c          let ls = (nx+2)*(ny+2)*(nz+2)*(10+isx+jsy+ksz)
c
c          let mx = ixp+1; my = jyq+1; mz = kzr+1.  the block gaussian
c          elimination at the coarsest mx by my by mz grid level requires
c
c             ld = mx*my*mz*(2*mx*my+1))           (nze.ne.0)
c
c          words of storage if z boundary conditions are not periodic or
c
c             ld = mx*my*(mz*(4*mx*my+1))          (nze=0)
c
c          words of storage if z boundary conditions are periodic.
c          if ixp,jyq,kzr are not the same, this quantity is
c          minimized if they are chosen so that kzr > max0(ixp,jyq).
c
c          finally
c
c             length = ls + ld

c          will usually but not always suffice.  the exact minimal length depends,
c          in a complex way, on the grid size arguments and method chosen.
c  ***     it can be predetermined for the current input arguments by calling
c          cuh3 with length=iparm(21)=0 and printing iparm(22) or (in f90)
c          dynamically allocating the work space using the value in iparm(22)
c          in a subsequent cuh3 call.
c
c ... fparm                                                                     
c
c          a floating point vector of length 8 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in cuh3 and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... ze=fparm(5), zf=fparm(6)
c
c          the range of the z independent variable. ze must                     
c          be less than zf.                                                     
c
c
c ... tolmax = fparm(7)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j,k)
c          and phi2(i,j,k) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(abs(phi2(i,j,k)-phi1(i,j,k))) for all i,j,k
c
c          and
c
c              phmax = max(abs(phi2(i,j,k))) for all i,j,k
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(7)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible DO NOT use error control!).
c
c
c ... wk
c
c          a one dimensional array that must be provided for work space.        
c          see length = iparm(21). the values in wk must be preserved
c          if cuh3 is called again with intl=iparm(1).ne.0 or if cuh34
c          is called to improve accuracy.
c
c
c ... iwk
c
c          an integer vector dimensioned of length at least
c
c             (ixp+1)*(jyq+1)*(kzr+1)
c
c          in the routine calling cuh3. the length of iwk is not
c          checked!  if iwk has length too small then undetectable
c          undetectable errors will result.
c
c
c ... bndyc                                                                     
c
c          a subroutine with arguments (kbdy,xory,yorz,alfa,gbdy).
c          which are used to input mixed boundary conditions to cuh3.
c          the boundaries are numbered one thru six and the form of
c          conditions are described below.
c                                                                               
c
c     (1) the kbdy=1 boundary
c
c     this is the (y,z) plane x=xa where nxa=iparm(2) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dx + alfxa(y,z)*p(xa,y,z) = gbdxa(y,z)
c
c     in this case kbdy=1,xory=y,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfxa(y,z),gbdxa(y,z) must be returned.
c
c
c     (2) the kbdy=2 boundary
c
c     this is the (y,z) plane x=xb where nxb=iparm(3) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dx + alfxb(y,z)*p(xb,y,z) = gbdxb(y,z)
c
c     in this case kbdy=2,xory=y,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfxb(y,z),gbdxb(y,z) must be returned.
c
c
c     (3) the kbdy=3 boundary
c
c     this is the (x,z) plane y=yc where nyc=iparm(4) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dy + alfyc(x,z)*p(x,yc,z) = gbdyc(x,z)
c
c     in this case kbdy=3,xory=x,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfyc(x,z),gbdyc(x,z) must be returned.
c
c
c     (4) the kbdy=4 boundary
c
c     this is the (x,z) plane y=yd where nyd=iparm(5) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dy + alfyd(x,z)*p(x,yd,z) = gbdyd(x,z)
c
c     in this case kbdy=4,xory=x,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfyd(x,z),gbdyd(x,z) must be returned.
c
c                                                                               
c     (5) the kbdy=5 boundary
c
c     this is the (x,y) plane z=ze where nze=iparm(6) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dz + alfze(x,y)*p(x,y,ze) = gbdze(x,y)
c
c     in this case kbdy=5,xory=x,yorz=y will be input to bndyc and
c     alfa,gbdy corresponding to alfze(x,y),gbdze(x,y) must be returned.
c
c
c     (6) the kbdy=6 boundary
c
c     this is the (x,y) plane z=zf where nzf=iparm(7) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dz + alfzf(x,y)*p(x,y,zf) = gbdzf(x,y)
c
c     in this case kbdy=6,xory=x,yorz=y will be input to bndyc and
c     alfa,gbdy corresponding to alfzf(x,y),gbdzf(x,y) must be returned.
c
c                                                                               
c *** alfxa,alfyc,alfze nonpositive and alfxb,alfyd,alfze nonnegative
c     will help maintain matrix diagonal dominance during discretization
c     aiding convergence.
c
c *** bndyc must provide the mixed boundary condition
c     values in correspondence with those flagged in iparm(2)
c     thru iparm(7).  if all boundaries are specified then
c     cuh3 will never call bndyc.  even then it must be entered
c     as a dummy subroutine. bndyc must be declared
c     external in the routine calling cuh3.  the actual
c     name chosen may be different.
c
c
c ... coef
c
c         a subroutine with arguments (x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
c         which provides the known complex coefficients for the elliptic pde
c         at any grid point (x,y,z).  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         external.
c
c ... rhs                                                                       
c
c          a complex array dimensioned nx by ny by nz which contains
c          the given right hand side values on the uniform 3-d mesh.            
c          rhs(i,j,k) = r(xi,yj,zk) for i=1,...,nx and j=1,...,ny               
c          and k=1,...,nz.
c
c ... phi                                                                       
c
c          a complex array dimensioned nx by ny by nz .  on input phi must
c          contain specified boundary values and an initial guess
c          to the solution if flagged (see iguess=iparm(17)=1).  for
c          example, if nyd=iparm(5)=1 then phi(i,ny,k) must be set
c          equal to p(xi,yd,zk) for i=1,...,nx and k=1,...,nz prior to
c          calling cuh3.  the specified values are preserved by cuh3.
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at non-Dirchlet grid points (this is not
c          checked). these values are projected down and serve as an initial
c          guess to the pde at the coarsest grid level.  set phi to 0.0 at
c          nonDirchlet grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid arguments (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the arguments
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).  the "d" at level 1
c     indicates a direct method is used
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---d-----d-----------d-----------------d---------------     level 1
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --d---d-------d---d-----------d---d-------d---d--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c *** this algorithim is modified with the hybrid solvers which use
c     a direct method whenever grid level 1 is encountered.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c ***********************************************************************
c ****output arguments**************************************************
c ***********************************************************************
c
c
c ... iparm(22)
c
c          on output iparm(22) contains the actual work space length
c          required for the current grid sizes and method.  this value
c          will be computed and returned even if iparm(21) is less then
c          iparm(22) (see ierror=9).
c
c
c ... iparm(23)
c
c          if error control is selected (tolmax = fparm(7) .gt. 0.0) then
c          on output iparm(23) contains the actual number of cycles executed
c          between the coarsest and finest grid levels in obtaining the
c          approximation in phi.  the quantity (iprer+ipost)*iparm(23) is
c          the number of relaxation sweeps performed at the finest grid level.
c
c
c ... fparm(8)                                                                  
c
c          on output fparm(8) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(8) is computed only if there is error control (tolmax.gt.0.)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c             phdif = max(abs(phi2(i,j,k)-phi1(i,j,k))) for all i,j,k
c
c          and
c
c             phmax = max(abs(phi2(i,j,k))) for all i,j,k
c
c          then
c
c             fparm(8) = phdif/phmax
c
c          is returned whenever phmax.gt.0.0.  in the degenerate case
c          phmax = 0.0, fparm(8) = phdif is returned.
c
c
c
c ... wk
c
c          on output wk contains intermediate values that must not be
c          destroyed if cuh3 is to be called again with iparm(1)=1 or
c          if cuh34 is to be called to improve the estimate to fourth
c          order.
c
c ... phi
c
c          on output phi(i,j,k) contains the approximation to
c          p(xi,yj,zk) for all mesh points i=1,...,nx; j=1,...,ny;
c          k=1,...,nz.  the last computed iterate in phi is returned
c          even if convergence is not obtained (ierror=-1)
c
c ... ierror
c
c          for intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  argument checking and discretization
c          is bypassed for intl=1 calls which can only return
c          ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              abs(cx)*dlx > 2.*abs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              abs(cy)*dly > 2.*abs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c
c             cxx = amax1(cxx,0.5*abs(cx)*dx)
c
c                          (and)
c
c             cyy = amax1(cyy,0.5*abs(cy)*dy)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made to preserve convergence of multigrid iteration. if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-3  if the continuous elliptic pde is singular.  this means the
c          boundary conditions are periodic or pure derivative at all
c          boundaries and ce(x,y) = 0.0 for all x,y.  a solution is still
c          attempted but convergence may not occur due to ill-conditioning
c          of the linear system coming from the discretization.  the
c          ierror = -3 flag overrides the ierror=-4 and ierror=-5 nonfatal
c          flags.
c
c
c     =-2  if the pde is not elliptic (i.e., cxx*cyy.le.0.0 for some (xi,yj))
c          in this case a solution is still attempted although convergence
c          may not occur due to ill-conditioning of the linear system.
c          the ierror = -2 flag overrides the ierror=-5,-4,-3 nonfatal
c          flags.
c
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd,nze,nzf
c         in iparm(2) through iparm(7)is not 0,1 or 2 or if
c         (nxa,nxb) or (nyc,nyd) or (nze,nzf) are not pairwise zero.
c
c     = 3 if mino(ixp,jyq,kzr) < 2 (ixp=iparm(8),jyq=iparm(9),kzr=iparm(10))
c         or if ixp<3 when nxa=0 or jyq<3 when nyc=0 or kzr<3 when nze=0.
c
c     = 4 if min0(iex,jey,kez) < 1 (iex=iparm(11),jey=iparm(12),kez=iparm(13))
c         or if max0(iex,jey,kez) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or if ny.ne.jyq*2**(jey-1)+1 or
c         if nz.ne.kzr*2**(kez-1)+1 (nx=iparm(14),ny=iparm(15),nz=iparm(16))
c
c     = 6 if iguess = iparm(17) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(18) < 1 (large values for maxcy should not be used)
c
c     = 8 if method = iparm(19) is less than 0 or greater than 10
c
c     = 9 if length = iparm(20) is too small (see iparm(21) on output
c         for minimum required work space length)
c
c     =10 if xa > xb or yc > yd or ze > zf
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4),ze=fparm(5),zf=fparm(6))
c
c     =11 if tolmax = fparm(7) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(2) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c     =13 if iex=jey=kez=1 (full direct method) and iguess=1 or maxcy > 1
c
c     =14 if the elliptic pde is singular (see ierror=-3 in cud3.d)
c
c
c *********************************************************
c *********************************************************
c
c     end of cuh3 documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="cuh34.txt"><b>CUH34</b></a>
<PRE>
c
c     file cuh34.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file cuh34.d
c
c     contains documentation for:
c     subroutine cuh34(wk,iwk,phi,ierror)
c     A sample fortran driver is file "tcuh34.f".
c
c ... required MUDPACK files
c
c     cuh3.f, cudcom.f, cud3ln.f, cud3pn.f
c
c ... purpose
c
c     cuh34 attempts to improve the estimate in phi, obtained by calling
c     cuh3,  from second to fourth order accuracy.  see the file "cuh3.d"
c     for a detailed discussion of the elliptic pde approximated and
c     arguments "wk,iwk,phi" which are also part of the argument list for
c     cuh3.
c
c ... assumptions
c
c     *  phi contains a second-order approximation from an earlier cuh3 call
c
c     *  arguments "wk,iwk,phi" are the same used in calling cuh3
c
c     *  "wk,iwk,phi" have not changed since the last call to cuh3
c
c     *  the finest grid level contains at least 6 points in each direction
c
c
c *** warning
c
c     if the first assumption is not true then a fourth order approximation
c     cannot be produced in phi.  the last assumption (adequate grid size)
c     is the only one checked. failure in any of the others can result in
c     in an undetectable error.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections"
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... error parameter
c
c     = 0 if no error is detected
c
c     = 30 if min0(nx,ny,nz) < 6 where nx,ny,nz are the fine grid sizes
c          in the x,y,z directions.
c                                                                               
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of cuh34 documentation
c
c  ***********************************************************************
c  ***********************************************************************
c
</PRE>
<HR>
 
<a name="mud2.txt"><b>MUD2</b></a>
<PRE>
c
c     file mud2.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file mud2.d
c
c     contains documentation for:
c     subroutine mud2(iparm,fparm,work,coef,bndyc,rhs,phi,mgopt,ierror)
c     A sample fortran driver is file "tmud2.f".
c
c ... required MUDPACK files
c
c     mudcom.f
c
c ... purpose
c
c     subroutine mud2 automatically discretizes and attempts to compute
c     the second-order difference approximation to the two-dimensional
c     linear nonseparable elliptic partial differential equation on a
c     rectangle.  the approximation is generated on a uniform grid covering
c     the rectangle (see mesh description below).  boundary conditions
c     may be specified (dirchlet), periodic, or mixed derivative in any
c     combination.  the form of the pde solved is:
c
c
c          cxx(x,y)*pxx + cyy(x,y)*pyy + cx(x,y)*px + cy(x,y)*py +
c
c          ce(x,y)*p(x,y) = r(x,y).
c
c
c     pxx,pyy,px,py are second and first partial derivatives of the
c     unknown real solution function p(x,y) with respect to the
c     independent variables x,y.  cxx,cyy,cx,cy,ce are the known
c     real coefficients of the elliptic pde and r(x,y) is the known
c     real right hand side of the equation.  cxx and cyy should be
c     positive for all x,y in the solution region.  Nonseparability
c     means some of the coefficients depend on both x and y.  If
c     the PDE is separable subroutine mud2sp should be used instead
c     of mud2 or muh2.
c                                                                               
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny grid.  the grid
c     is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1)
c
c     be the uniform grid increments in the x,y directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly
c
c     for i=1,...,nx and j=1,...,ny  denote the x,y uniform mesh points
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with Fortran77
c     and Fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 17 used to pass integer
c          arguments.  iparm is set internally and defined as
c          follows:
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      An approximation is NOT generated after an intl=0 call!
c          mud2 should be called with intl=1 to approximate the elliptic
c          PDE discretized by the intl=0 call.  intl=1 should also
c          be input if mud2 has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  This will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  Some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) mud2 is being recalled for additional accuracy.  In
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) mud2 is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) mud2 is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to mud2

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by coef (see below) have
c              changed since the previous call
c
c          (e) any of the "alfa" coefficients input by bndyc (see below)
c              have changed since the previous call.
c
c          If any of (a) through (e) are true then the elliptic PDE
c          must be discretized or rediscretized.  If none of (a)
c          through (e) holds, calls can be made with intl=1.
c          Incorrect calls with intl=1 will produce erroneous results.
c  ***     The values set in the saved work space "work" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the edge x=xa
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y
c            (if nxa=0 then nxb=0 is required, see ierror = 2)
c
c        = 1 if p(xa,y) is specified (this must be input thru phi(1,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see bndyc)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the edge x=xb
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y)
c            (if nxb=0 then nxa=0 is required, see ierror = 2)
c
c        = 1 if p(xb,y) is specified (this must be input thru phi(nx,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see bndyc)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the edge y=yc
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c            (if nyc=0 then nyd=0 is required, see ierror = 2)
c
c        = 1 if p(x,yc) is specified (this must be input thru phi(i,1))
c
c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see bndyc)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the edge y=yd
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c             (if nyd=0 then nyc=0 is required, see ierror = 2)
c
c        = 1 if p(x,yd) is specified (this must be input thru phi(i,ny))
c
c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see bndyc)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(6)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the x direction is not used.
c          if ixp > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of ixp can be removed by increasing iex = iparm(8)
c          without changing nx = iparm(10).
c
c
c ... jyq = iparm(7)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the y direction is not used.
c          if jyq > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of jyq can be removed by increasing jey = iparm(9)
c          without changing ny = iparm(11).
c
c
c ... iex = iparm(8)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx.
c
c
c ... jey = iparm(9)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(7)
c          as small as possible within grid size constraints when
c          defining ny.
c
c
c
c ... nx = iparm(10)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(6), iex = iparm(8).
c
c
c ... ny = iparm(11)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(7), jey = iparm(9).
c
c
c *** example
c
c         suppose a solution is wanted on a 33 by 97 grid.  then
c         ixp=2, jyq=6 and iex=jey=5 could be used.  a better
c         choice would be ixp=2, jyq=3, and iex=5, jey=6.
c
c *** grid size flexibility considerations:
c
c     the hybrid multigrid/direct method code muh2 provides more grid size
c     flexibility than mud2 by removing the constraint that ixp and jyq are
c     2 or 3.  This is accomplished by using a direct method whenever the
c     coarsest (ixp+1) X (jyq+1) grid is encountered in multigrid cycling.
c     If nx = ixp+1 and ny = jyq+1 then muh2 becomes a full direct method.
c     muh2 is roughly equivalent to mud2 in efficiency as long as ixp and
c     jyq remain "small" (see muh2.d).  If the problem to be approximated
c     requires a grid neither mud2 por muh2 can exactly fit then another option
c     is to generate an approximation on a "close grid" using mud2 or muh2.
c     Then transfer the result to the required grid using cubic interpolation
c     via the package "regridpack"(contact John Adams about this software)
c
c *** note
c
c     let G be the nx by ny fine grid on which the approximation is
c     generated and let n = max0(iex,jey).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         G(1) < ... < G(k) < ... < G(n) = G.
c
c     each G(k) (k=1,...,n) has mx(k) by my(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c
c
c ... iguess=iparm(12)
c
c          = 0 if no initial guess to the pde is provided
c
c          = 1 if an initial guess to the pde is at the finest grid
c              level is provided in phi (see below)
c
c     comments on iguess = 0 or 1 . . .
c
c     even if iguess = 0, phi must be initialized at all grid points (this
c     is not checked).  phi can be set to 0.0 at non-dirchlet grid points
c     if nothing better is available.  the values set in phi when iguess = 0
c     are passed down and serve as an initial guess to the pde at the coarsest
c     grid level where cycling commences.  in this sense, values input in
c     phi always serve as an initial guess.  setting iguess = 0 forces full
c     multigrid cycling beginning at the coarsest and finishing at the finest
c     grid level.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c     time dependent problems . . .
c
c *** assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at nondirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(13)
c
c          the exact number of cycles executed between the finest (nx by
c          ny) and the coarsest ((ixp+1) by (jyq+1)) grid levels when
c          tolmax=fparm(5)=0.0 (no error control).  when tolmax > 0.0
c          is input (error control) then maxcy is a limit on the number
c          of cycles between the finest and coarsest grid levels.  in
c          any case, at most maxcy*(iprer+ipost) relaxation sweeps are
c          are performed at the finest grid level (see iprer=mgopt(2),
c          ipost=mgopt(3) below).  when multigrid iteration is working
c          "correctly" only a few are required for convergence.  large
c          values for maxcy should not be necessary.
c
c
c ... method = iparm(14) determines the method of relaxation
c              (gauss-seidel based on alternating points or lines)
c
c          = 0 for  point relaxation
c
c          = 1 for line relaxation in the x direction
c
c          = 2 for line relaxation in the y direction
c
c          = 3 for line relaxation in both the x and y direction
c
c
c *** choice of method. . .
c
c     let fx represent the quantity cxx(x,y)/dlx**2 over the solution region.
c
c     let fy represent the quantity cyy(x,y)/dly**2 over the solution region
c
c     if fx,fy are roughly the same size and do not vary too much over
c     the solution region choose method = 0.  if this fails try method=3.
c
c     if fx is much greater than fy choose method = 1.
c
c     if fy is much greater than fx choose method = 2
c
c     if neither fx or fy dominates over the solution region and they
c     both vary considerably choose method = 3.
c
c
c ... length = iparm(15)
c
c          the length of the work space provided in vector work (see below).
c          let isx = 0 if method = 0 or method = 2
c          let isx = 3 if method = 1 or method = 3 and nxa.ne.0
c          let isx = 5 if method = 1 or method = 3 and nxa.eq.0
c          let jsy = 0 if method = 0 or method = 1
c          let jsy = 3 if method = 2 or method = 3 and nyc.ne.0
c          let jsy = 5 if method = 2 or method = 3 and nyc.eq.0
c          then . . .
c
c               length = 4*[nx*ny*(10+isx+jsy)+8*(nx+ny+2)]/3
c
c          will suffice in most cases.  the exact minimal work space
c          length required for the current nx,ny and method is output
c          in iparm(16) (even if iparm(15) is too small).  this will be
c          less then the value given by the simplified formula above
c          in most cases.
c
c
c ... fparm                                                                     
c
c          a floating point vector of length 6 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in mud2 and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... tolmax = fparm(5)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j)
c          and phi2(i,j) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(abs(phi2(i,j)-phi1(i,j))) for all i,j
c
c          and
c
c              phmax = max(abs(phi2(i,j))) for all i,j
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(5)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible DO NOT use error control!).
c
c ... work                                                                      
c
c          a one dimensional real saved work space (see iparm(15) for
c          length) which must be preserved from the previous call when
c          calling with intl=iparm(1)=1.
c
c ... bndyc                                                                     
c
c          a subroutine with  arguments (kbdy,xory,alfa,gbdy) which
c          are used to input mixed boundary conditions to mud2. bndyc
c          must be declared "external" in the program calling mud2.
c          the boundaries are numbered one thru four and the mixed
c          derivative boundary conditions are described below (see the
c          sample driver code "tmud2.f" for an example of how bndyc is
c          can beset up).
c                                                                               
c          * * * * * * * * * * * *  y=yd
c          *       kbdy=4        *
c          *                     *
c          *                     *
c          *                     *
c          * kbdy=1       kbdy=2 *
c          *                     *
c          *                     *
c          *                     *
c          *       kbdy=3        *
c          * * * * * * * * * * * *  y=yc
c
c          x=xa                  x=xb
c
c
c          (1) the kbdy=1 boundary
c
c          this is the edge x=xa where nxa=iparm(2)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dx + alfxa(y)*p(xa,y) = gbdxa(y)
c
c          in this case kbdy=1,xory=y will be input to bndyc and
c          alfa,gbdy corresponding to alfxa(y),gbdxa(y) must be returned.
c
c
c          (2) the kbdy=2 boundary
c
c          this is the edge x=xb where nxb=iparm(3)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dx + alfxb(y)*p(xb,y) = gbdxb(y)
c
c          in this case kbdy=2,xory=y, will be input to bndyc and
c          alfa,gbdy corresponding to alfxb(y),gbdxb(y) must be returned.
c
c
c          (3) the kbdy=3 boundary
c
c          this is the edge y=yc where nyc=iparm(4)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dy + alfyc(x)*p(x,yc) = gbdyc(x)
c
c          in this case kbdy=3,xory=x will be input to bndyc and
c          alfa,gbdy corresponding to alfyc(x),gbdyc(x) must be returned.
c
c
c          (4) the kbdy=4 boundary
c
c          this is the edge y=yd where nyd=iparm(5)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dy + alfyd(x)*p(x,yd) = gbdyd(x)
c
c          in this case kbdy=4,xory=x will be input to bndyc and
c          alfa,gbdy corresponding to alfyd(x),gbdyd(x) must be returned.
c
c                                                                               
c ***      bndyc must provide the mixed boundary condition values
c          in correspondence with those flagged in iparm(2) thru
c          iparm(5).  if all boundaries are specified or periodic
c          mud2 will never call bndyc.  even then it must be entered
c          as a dummy subroutine. bndyc must be declared "external"
c          in the routine calling mud2.  the actual name chosen may
c          be different.
c
c
c ... coef
c
c         a subroutine with arguments (x,y,cxx,cyy,cx,cy,ce) which
c         provides the known real coefficients for the elliptic pde at
c         any grid point (x,y).  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         "external."
c
c ... rhs                                                                       
c
c          an array dimensioned nx by ny which contains the given
c          right hand side values on the uniform 2-d mesh.
c
c              rhs(i,j) = r(xi,yj) for i=1,...,nx and j=1,...,ny
c
c ... phi                                                                       
c
c          an array dimensioned nx by ny.  on input phi must contain
c          specified boundary values. for example, if nyd=iparm(5)=1
c          then phi(i,ny) must be set equal to p(xi,yd) for i=1,...nx
c          prior to calling mud2.  these values are preserved by mud2.
c          if an initial guess is provided (iguess=iparm(11)=1) it must
c          be input thru phi.
c
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at all grid points (this is not checked).  these
c          values will serve as an initial guess to the pde at the coarsest
c          grid level after a transfer from the fine solution grid.  set phi
c          equal to to 0.0 at all internal and non-specified boundaries
c          grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid arguments (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the arguments
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).  all version 5.0.1
c     mudpack solvers use only fully weighted residual restriction
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---3-----3-----------3-----------------3---------------     level 1
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --6---6-------6---6-----------6---6-------6---6--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c
c **********************************************************************
c *** output arguments ************************************************
c **********************************************************************
c
c
c ... iparm(16)  *** set for intl=0 calls only
c
c          on output iparm(16) contains the actual work space length
c          required.  this will usually be less than that given by the
c          simplified formula for length=iparm(15) (see as input argument)
c
c
c ... iparm(17)  *** set for intl=1 calls only
c
c          on output iparm(17) contains the actual number of multigrid cycles
c          between the finest and coarsest grid levels used to obtain the
c          approximation when error control (tolmax > 0.0) is set.
c
c
c ... fparm(6)   *** set for intl=1 calls with fparm(5) > 0. only
c
c          on output fparm(6) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(6) is computed only if there is error control (tolmax > 0.0)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c               phdif = max(abs(phi2(i,j)-phi1(i,j))) over all i,j
c
c          and
c
c               phmax = max(abs(phi2(i,j)) over all i,j
c
c          then
c
c               fparm(6) = phdif/phmax
c
c          is returned whenever phmax > 0.0. in the degenerate case
c          phmax = 0.0, fparm(6) = phdif is returned.
c
c
c ... work
c
c          on output work contains intermediate values that must not
c          be destroyed if mud2 is to be called again with intl=1
c
c
c ... phi   *** for intl=1 calls only
c
c          on output phi(i,j) contains the approximation to p(xi,yj)
c          for all mesh points i = 1,...,nx and j=1,...,ny.  the last
c          computed iterate in phi is returned even if convergence is
c          not obtained
c
c
c ... ierror
c
c          For intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  Argument checking and discretization
c          is bypassed for intl=1 calls which can only return
c          ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              abs(cx)*dlx > 2.*abs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              abs(cy)*dly > 2.*abs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c
c             cxx = amax1(cxx,0.5*abs(cx)*dx)
c
c                          (and)
c
c             cyy = amax1(cyy,0.5*abs(cy)*dy)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made to preserve convergence of multigrid iteration. if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-3  if the continuous elliptic pde is singular.  this means the
c          boundary conditions are periodic or pure derivative at all
c          boundaries and ce(x,y) = 0.0 for all x,y.  a solution is still
c          attempted but convergence may not occur due to ill-conditioning
c          of the linear system coming from the discretization.  the
c          ierror = -3 flag overrides the ierror=-4 and ierror=-5 nonfatal
c          flags.
c
c
c     =-2  if the pde is not elliptic (i.e., cxx*cyy.le.0.0 for some (xi,yj))
c          in this case a solution is still attempted although convergence
c          may not occur due to ill-conditioning of the linear system.
c          the ierror = -2 flag overrides the ierror=-5,-4,-3 nonfatal
c          flags.
c
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd
c         in iparm(2),iparm(3),iparm(4),iparm(5) are not 0,1 or 2
c         or if nxa,nxb or nyc,nyd are not pairwise zero.
c
c     = 3 if mino(ixp,jyq) < 2 (ixp = iparm(6), jyq = iparm(7))
c
c     = 4 if min0(iex,jey) < 1 (iex = iparm(8), jey = iparm(9)) or
c         if max0(iex,jey) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or ny.ne.jyq*2**(jey-1)+1
c         (nx = iparm(10), ny = iparm(11))
c
c     = 6 if iguess = iparm(12) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(13) < 1
c
c     = 8 if method = iparm(14) is not 0,1,2, or 3
c
c     = 9 if length = iparm(15) is too small (see iparm(16) on output
c         for minimum required work space length)
c
c     =10 if xa >= xb or yc >= yd
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4))
c
c     =11 if tolmax = fparm(5) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(2) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c *********************************************************
c *********************************************************
c
c     end of mud2 documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="mud24.txt"><b>MUD24</b></a>
<PRE>
c
c     file mud24.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file mud24.d
c
c     contains documentation for subroutine mud24(work,phi,ierror)
c     A sample fortran driver is file "tmud24.f".
c
c ... required MUDPACK files
c
c     mud2.f, mudcom.f
c
c ... purpose
c
c     mud24 attempts to improve the estimate in phi, obtained by calling
c     mud2,  from second to fourth order accuracy.  see the file "mud2.d"
c     for a detailed discussion of the elliptic pde approximated and
c     arguments "work,phi" which are also part of the argument list for
c     mud2.
c
c ... assumptions
c
c     *  phi contains a second-order approximation from an earlier mud2 call
c
c     *  arguments "work,phi" are the same used in calling mud2
c
c     *  "work,phi" have not changed since the last call to mud2
c
c     *  the finest grid level contains at least 6 points in each direction
c
c
c *** warning
c
c     if the first assumption is not true then a fourth order approximation
c     cannot be produced in phi.  the last assumption (adequate grid size)
c     is the only one checked. failure in any of the others can result in
c     in an undetectable error.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections"
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... error argument
c
c     = 0 if no error is detected
c
c     = 30 if min0(nx,ny) < 6 where nx,ny are the fine grid sizes
c          in the x,y directions.
c                                                                               
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of mud24 documentation
c
c  ***********************************************************************
c  ***********************************************************************
c
</PRE>
<HR>
 
<a name="mud24cr.txt"><b>MUD24CR</b></a>
<PRE>
c
c     file mud24cr.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file mud24cr.d
c
c     contains documentation for:
c     subroutine mud24cr(work,coef,bndyc,phi,ierror)
c     A sample fortran driver is file "tmud24cr.f".
c
c ... required MUDPACK files
c
c     mud2cr.f, mudcom.f
c
c ... purpose
c
c     mud24cr attempts to improve the estimate in phi, obtained by calling
c     mud2cr,  from second to fourth order accuracy.  see the file "mud2cr.d"
c     for a detailed discussion of the elliptic pde approximated and
c     arguments "work,coef,bndyc,phi" which are also part of the argument
c     list for mud2cr
c
c ... assumptions
c
c     *  phi contains a second-order approximation from an earlier mud2cr call
c
c     *  arguments "work,coef,bndyc,phi" are the same used in calling mud2cr
c
c     *  "work,coef,bndyc,phi" have not changed since the last call to mud2cr
c
c     *  the finest grid level contains at least 6 points in each direction
c
c
c *** warning
c
c     if the first assumption is not true then a fourth order approximation
c     cannot be produced in phi.  the last assumption (adequate grid size)
c     is the only one checked. failure in any of the others can result in
c     in an undetectable error.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections"
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... error argument
c
c     = 0 if no error is detected
c
c     = 30 if min0(nx,ny) < 6 where nx,ny are the fine grid sizes
c          in the x,y directions.
c                                                                               
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of mud24cr documentation
c
c  ***********************************************************************
c  ***********************************************************************
c
</PRE>
<HR>
 
<a name="mud24sp.txt"><b>MUD24SP</b></a>
<PRE>
c
c     file mud24sp.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file mud24sp.d
c
c     contains documentation for subroutine mud24sp(work,phi,ierror)
c     A sample fortran driver is file "tmud24sp.f".
c
c ... required MUDPACK files
c
c     mud2sp.f, mudcom.f
c
c ... purpose
c
c     mud24sp attempts to improve the estimate in phi, obtained by calling
c     mud2sp,  from second to fourth order accuracy.  see the file "mud2sp.d"
c     for a detailed discussion of the elliptic pde approximated and
c     arguments "work,phi" which are also part of the argument list for
c     mud2sp.
c
c ... assumptions
c
c     *  phi contains a second-order approximation from an earlier mud2sp call
c
c     *  arguments "work,phi" are the same used in calling mud2sp
c
c     *  "work,phi" have not changed since the last call to mud2sp
c
c     *  the finest grid level contains at least 6 points in each direction
c
c
c *** warning
c
c     if the first assumption is not true then a fourth order approximation
c     cannot be produced in phi.  the last assumption (adequate grid size)
c     is the only one checked. failure in any of the others can result in
c     in an undetectable error.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections"
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... error argument
c
c     = 0 if no error is detected
c
c     = 30 if min0(nx,ny) < 6 where nx,ny are the fine grid sizes
c          in the x,y directions.
c                                                                               
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of mud24sp documentation
c
c  ***********************************************************************
c  ***********************************************************************
c
</PRE>
<HR>
 
<a name="mud2cr.txt"><b>MUD2CR</b></a>
<PRE>
c
c     file mud2cr.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file mud2cr.d
c
c     contains documentation for:
c     subroutine mud2cr(iparm,fparm,work,coef,bndyc,rhs,phi,mgopt,ierror)
c     a sample fortran driver is file "tmud2cr.f".
c
c ... required mudpack files
c
c     mudcom.f
c
c ... purpose
c
c     subroutine mud2cr automatically discretizes and attempts to compute
c     the second-order difference approximation to the two-dimensional
c     linear nonseparable elliptic partial differential equation with cross
c     derivative term on a rectangle.  the approximation is generated on a
c     uniform grid covering the rectangle (see mesh description below).
c     boundary conditions may be specified (dirchlet), periodic, or mixed
c     oblique derivative (see bndyc) in any combination.  the form of the pde
c     approximated is:
c
c
c          cxx(x,y)*pxx + cxy(x,y)*pxy + cyy(x,y)*pyy + cx(x,y)*px +
c
c          cy(x,y)*py + ce(x,y)*p(x,y) = r(x,y).
c
c
c     pxx,pxy,pyy,px,py are second and first partial derivatives of the
c     unknown real solution function p(x,y) with respect to the
c     independent variables x,y.  cxx,cxy,cyy,cx,cy,ce are the known
c     real coefficients of the elliptic pde and r(x,y) is the known
c     real right hand side of the equation.  cxx and cyy should be
c     positive for all x,y in the solution region and
c
c          4*cxx(x,y)*cyy(x,y) .le. cxy(x,y)**2
c
c     for ellipticity (see ierror=-2).  nonseparability means some
c     of the coefficients depend on both x and y and cxy.ne.0.  if
c     the pde is separable and cxy = 0 then subroutine mud2sp should
c     be used.
c                                                                               
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny grid.  the grid
c     is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1)
c
c     be the uniform grid increments in the x,y directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly
c
c     for i=1,...,nx and j=1,...,ny  denote the x,y uniform mesh points
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 17 used to pass integer
c          arguments.  iparm is set internally and defined as
c          follows:
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      an approximation is not generated after an intl=0 call!
c          mud2cr should be called with intl=1 to approximate the elliptic
c          pde discretized by the intl=0 call.  intl=1 should also
c          be input if mud2cr has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  this will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) mud2cr is being recalled for additional accuracy.  in
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) mud2cr is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) mud2cr is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to mud2cr

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by coef (see below) have
c              changed since the previous call
c
c          (e) any of the "alfa" coefficients input by bndyc (see below)
c              have changed since the previous call.
c
c          if any of (a) through (e) are true then the elliptic pde
c          must be discretized or rediscretized.  if none of (a)
c          through (e) holds, calls can be made with intl=1.
c          incorrect calls with intl=1 will produce erroneous results.
c  ***     the values set in the saved work space "work" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the edge x=xa
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y
c            (if nxa=0 then nxb=0 is required, see ierror = 2)
c
c        = 1 if p(xa,y) is specified (this must be input thru phi(1,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see bndyc)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the edge x=xb
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y)
c            (if nxb=0 then nxa=0 is required, see ierror = 2)
c
c        = 1 if p(xb,y) is specified (this must be input thru phi(nx,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see bndyc)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the edge y=yc
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c            (if nyc=0 then nyd=0 is required, see ierror = 2)
c
c        = 1 if p(x,yc) is specified (this must be input thru phi(i,1))
c
c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see bndyc)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the edge y=yd
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c             (if nyd=0 then nyc=0 is required, see ierror = 2)
c
c        = 1 if p(x,yd) is specified (this must be input thru phi(i,ny))
c
c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see bndyc)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(6)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the x direction is not used.
c          if ixp > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of ixp can be removed by increasing iex = iparm(8)
c          without changing nx = iparm(10).
c
c
c ... jyq = iparm(7)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the y direction is not used.
c          if jyq > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of jyq can be removed by increasing jey = iparm(9)
c          without changing ny = iparm(11).
c
c
c ... iex = iparm(8)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx.
c
c
c ... jey = iparm(9)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(7)
c          as small as possible within grid size constraints when
c          defining ny.
c
c
c
c ... nx = iparm(10)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(6), iex = iparm(8).
c
c
c ... ny = iparm(11)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(7), jey = iparm(9).
c
c
c *** example
c
c         suppose a solution is wanted on a 33 by 97 grid.  then
c         ixp=2, jyq=6 and iex=jey=5 could be used.  a better
c         choice would be ixp=2, jyq=3, and iex=5, jey=6.
c
c *** grid size flexibility considerations:
c
c     the hybrid multigrid/direct method code muh2cr provides more grid size
c     flexibility than mud2cr by removing the constraint that ixp and jyq are
c     2 or 3.  this is accomplished by using a direct method whenever the
c     coarsest (ixp+1) x (jyq+1) grid is encountered in multigrid cycling.
c     if nx = ixp+1 and ny = jyq+1 then muh2cr becomes a full direct method.
c     muh2cr is roughly equivalent to mud2cr in efficiency as long as ixp and
c     jyq remain "small" (see muh2cr.d).  if the problem to be approximated
c     requires a grid neither mud2cr or muh2cr can exactly fit then another option
c     is to generate an approximation on a "close grid" using mud2cr or muh2cr.
c     then transfer the result to the required grid using cubic interpolation
c     via the package "regridpack"(contact john adams about this software)
c
c *** note
c
c     let g be the nx by ny fine grid on which the approximation is
c     generated and let n = max0(iex,jey).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         g(1) < ... < g(k) < ... < g(n) = g.
c
c     each g(k) (k=1,...,n) has mx(k) by my(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c
c
c ... iguess=iparm(12)
c
c          = 0 if no initial guess to the pde is provided
c
c          = 1 if an initial guess to the pde is at the finest grid
c              level is provided in phi (see below)
c
c     comments on iguess = 0 or 1 . . .
c
c     even if iguess = 0, phi must be initialized at all grid points (this
c     is not checked).  phi can be set to 0.0 at non-dirchlet grid points
c     if nothing better is available.  the values set in phi when iguess = 0
c     are passed down and serve as an initial guess to the pde at the coarsest
c     grid level where cycling commences.  in this sense, values input in
c     phi always serve as an initial guess.  setting iguess = 0 forces full
c     multigrid cycling beginning at the coarsest and finishing at the finest
c     grid level.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c     time dependent problems . . .
c
c *** assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at nondirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(13)
c
c          the exact number of cycles executed between the finest (nx by
c          ny) and the coarsest ((ixp+1) by (jyq+1)) grid levels when
c          tolmax=fparm(5)=0.0 (no error control).  when tolmax > 0.0
c          is input (error control) then maxcy is a limit on the number
c          of cycles between the finest and coarsest grid levels.  in
c          any case, at most maxcy*(iprer+ipost) relaxation sweeps are
c          are performed at the finest grid level (see iprer=mgopt(2),
c          ipost=mgopt(3) below).  when multigrid iteration is working
c          "correctly" only a few are required for convergence.  large
c          values for maxcy should not be necessary.
c
c
c ... method = iparm(14) determines the method of relaxation
c              (gauss-seidel based on alternating points or lines)
c
c          = 0 for  point relaxation
c
c          = 1 for line relaxation in the x direction
c
c          = 2 for line relaxation in the y direction
c
c          = 3 for line relaxation in both the x and y direction
c
c
c *** choice of method. . .
c
c     let fx represent the quantity cxx(x,y)/dlx**2 over the solution region.
c
c     let fy represent the quantity cyy(x,y)/dly**2 over the solution region
c
c     if fx,fy are roughly the same size and do not vary too much over
c     the solution region choose method = 0.  if this fails try method=3.
c
c     if fx is much greater than fy choose method = 1.
c
c     if fy is much greater than fx choose method = 2
c
c     if neither fx or fy dominates over the solution region and they
c     both vary considerably choose method = 3.
c
c
c ... length = iparm(15)
c
c          the length of the work space provided in vector work (see below).
c          let isx = 0 if method = 0 or method = 2
c          let isx = 3 if method = 1 or method = 3 and nxa.ne.0
c          let isx = 5 if method = 1 or method = 3 and nxa.eq.0
c          let jsy = 0 if method = 0 or method = 1
c          let jsy = 3 if method = 2 or method = 3 and nyc.ne.0
c          let jsy = 5 if method = 2 or method = 3 and nyc.eq.0
c          then . . .
c
c           length = [7*(nx+2)*(ny+2)+4*(11+isx+jsy)*nx*ny]/3
c
c          will suffice in most cases.  the exact minimal work space
c          length required for the current nx,ny and method is output
c          in iparm(16) (even if iparm(15) is too small).  this will be
c          less then the value given by the simplified formula above
c          in most cases.
c
c
c ... fparm                                                                     
c
c          a floating point vector of length 6 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in mud2cr and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... tolmax = fparm(5)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j)
c          and phi2(i,j) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(abs(phi2(i,j)-phi1(i,j))) for all i,j
c
c          and
c
c              phmax = max(abs(phi2(i,j))) for all i,j
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(5)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible do not use error control!).
c
c ... work                                                                      
c
c          a one dimensional real saved work space (see iparm(15) for
c          length) which must be preserved from the previous call when
c          calling with intl=iparm(1)=1.
c
c ... bndyc                                                                     
c
c          a subroutine with  arguments (kbdy,xory,alfa,beta,gama,gbdy) which
c          are used to input mixed boundary conditions to mud2cr. bndyc
c          must be declared "external" in the program calling mud2cr.
c          the boundaries are numbered one thru four and the mixed
c          derivative boundary conditions are described below (see the
c          sample driver code "tmud2cr.f" for an example of how bndyc is
c          can beset up).
c                                                                               
c          * * * * * * * * * * * *  y=yd
c          *       kbdy=4        *
c          *                     *
c          *                     *
c          *                     *
c          * kbdy=1       kbdy=2 *
c          *                     *
c          *                     *
c          *                     *
c          *       kbdy=3        *
c          * * * * * * * * * * * *  y=yc
c
c          x=xa                  x=xb
c
c
c
c    (1)   the kbdy=1 boundary
c
c          this is the edge x=xa where nxa=iparm(2) = 2 flags
c          a mixed boundary condition of the form
c
c             alfxa(y)*px + betxa(y)*py + gamxa(y)*p(xa,y) = gbdxa(y)
c
c          in this case kbdy=1,xory=y will be input to bndyc and
c          alfa,beta,gama,gbdy corresponding to alfxa(y),betxa(y),gamxa(y),
c          gbdxa(y) must be returned.  alfxa(y) = 0. is not allowed for any y.
c          (see ierror = 13)
c
c    (2)   the kbdy=2 boundary
c
c          this is the edge x=xb where nxb=iparm(3) = 2 flags
c          a mixed boundary condition of the form
c
c             alfxb(y)*px + betxb(y)*py + gamxb(y)*p(xb,y) = gbdxb(y)
c
c          in this case kbdy=2,xory=y will be input to bndyc and
c          alfa,beta,gama,gbdy corresponding to alfxb(y),betxb(y),gamxb(y),
c          gbdxb(y) must be returned. alfxb(y) = 0.0 is not allowed for any y.
c          (see ierror = 13)
c
c    (3)   the kbdy=3 boundary
c
c          this is the edge y=yc where nyc=iparm(4) = 2 flags
c          a mixed boundary condition of the form
c
c             alfyc(x)*px + betyc(x)*py + gamyc(x)*p(x,yc) = gbdyc(x)
c
c          in this case kbdy=3,xory=x will be input to bndyc and
c          alfa,beta,gama,gbdy corresponding to alfyc(x),betyc(x),gamyc(x),
c          gbdyc(x) must be returned. betyc(x) = 0.0 is not allowed for any x.
c          (see ierror = 13)
c
c    (4)   the kbdy=4 boundary
c
c          this is the edge y=yd where nyd=iparm(5) = 2 flags
c          a mixed boundary condition of the form
c
c             alfyd(x)*px + betyd(x)*py + gamyd(x)*p(x,yd) = gbdyd(x)
c
c          in this case kbdy=4,xory=x will be input to bndyc and
c          alfa,beta,gama,gbdy corresponding to alfyd(x),betyd(x),gamyd(x),
c          gbdyd(x) must be returned. betyd(x) = 0.0 is not allowed for any x.
c          (see ierror = 13)
c
c                                                                               
c ***      bndyc must provide the mixed boundary condition values
c          in correspondence with those flagged in iparm(2) thru
c          iparm(5).  if all boundaries are specified or periodic
c          mud2cr will never call bndyc.  even then it must be entered
c          as a dummy subroutine. bndyc must be declared "external"
c          in the routine calling mud2cr.  the actual name chosen may
c          be different.
c
c
c ... coef
c
c         a subroutine with arguments (x,y,cxx,cxy,cyy,cx,cy,ce) which
c         provides the known real coefficients for the elliptic pde at
c         any grid point (x,y).  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         "external."
c
c ... rhs                                                                       
c
c          an array dimensioned nx by ny which contains the given
c          right hand side values on the uniform 2-d mesh.
c
c              rhs(i,j) = r(xi,yj) for i=1,...,nx and j=1,...,ny
c
c ... phi                                                                       
c
c          an array dimensioned nx by ny.  on input phi must contain
c          specified boundary values. for example, if nyd=iparm(5)=1
c          then phi(i,ny) must be set equal to p(xi,yd) for i=1,...nx
c          prior to calling mud2cr.  these values are preserved by mud2cr.
c          if an initial guess is provided (iguess=iparm(11)=1) it must
c          be input thru phi.
c
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at all grid points (this is not checked).  these
c          values will serve as an initial guess to the pde at the coarsest
c          grid level after a transfer from the fine solution grid.  set phi
c          equal to to 0.0 at all internal and non-specified boundaries
c          grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid arguments (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the arguments
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).  all version 5.0.1
c     mudpack solvers use only fully weighted residual restriction
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---3-----3-----------3-----------------3---------------     level 1
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --6---6-------6---6-----------6---6-------6---6--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c
c **********************************************************************
c *** output arguments ************************************************
c **********************************************************************
c
c
c ... iparm(16)  *** set for intl=0 calls only
c
c          on output iparm(16) contains the actual work space length
c          required.  this will usually be less than that given by the
c          simplified formula for length=iparm(15) (see as input argument)
c
c
c ... iparm(17)  *** set for intl=1 calls only
c
c          on output iparm(17) contains the actual number of multigrid cycles
c          between the finest and coarsest grid levels used to obtain the
c          approximation when error control (tolmax > 0.0) is set.
c
c
c ... fparm(6)   *** set for intl=1 calls with fparm(5) > 0. only
c
c          on output fparm(6) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(6) is computed only if there is error control (tolmax > 0.0)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c               phdif = max(abs(phi2(i,j)-phi1(i,j))) over all i,j
c
c          and
c
c               phmax = max(abs(phi2(i,j)) over all i,j
c
c          then
c
c               fparm(6) = phdif/phmax
c
c          is returned whenever phmax > 0.0. in the degenerate case
c          phmax = 0.0, fparm(6) = phdif is returned.
c
c
c ... work
c
c          on output work contains intermediate values that must not
c          be destroyed if mud2cr is to be called again with intl=1
c
c
c ... phi   *** for intl=1 calls only
c
c          on output phi(i,j) contains the approximation to p(xi,yj)
c          for all mesh points i = 1,...,nx and j=1,...,ny.  the last
c          computed iterate in phi is returned even if convergence is
c          not obtained
c
c
c ... ierror
c
c          for intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  argument checking and discretization
c          is bypassed for intl=1 calls which can only return
c          ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              abs(cx)*dlx > 2.*abs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              abs(cy)*dly > 2.*abs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c
c             cxx = amax1(cxx,0.5*abs(cx)*dx)
c
c                          (and)
c
c             cyy = amax1(cyy,0.5*abs(cy)*dy)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made to preserve convergence of multigrid iteration. if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-3  if the continuous elliptic pde is singular.  this means the
c          boundary conditions are periodic or pure derivative at all
c          boundaries and ce(x,y) = 0.0 for all x,y.  a solution is still
c          attempted but convergence may not occur due to ill-conditioning
c          of the linear system coming from the discretization.  the
c          ierror = -3 flag overrides the ierror=-4 and ierror=-5 nonfatal
c          flags.
c
c
c     =-2  if the pde is not elliptic (i.e., cxx*cyy.le.0.0 for some (xi,yj))
c          in this case a solution is still attempted although convergence
c          may not occur due to ill-conditioning of the linear system.
c          the ierror = -2 flag overrides the ierror=-5,-4,-3 nonfatal
c          flags.
c
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd
c         in iparm(2),iparm(3),iparm(4),iparm(5) are not 0,1 or 2
c         or if nxa,nxb or nyc,nyd are not pairwise zero.
c
c     = 3 if mino(ixp,jyq) < 2 (ixp = iparm(6), jyq = iparm(7))
c
c     = 4 if min0(iex,jey) < 1 (iex = iparm(8), jey = iparm(9)) or
c         if max0(iex,jey) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or ny.ne.jyq*2**(jey-1)+1
c         (nx = iparm(10), ny = iparm(11))
c
c     = 6 if iguess = iparm(12) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(13) < 1
c
c     = 8 if method = iparm(14) is not 0,1,2, or 3
c
c     = 9 if length = iparm(15) is too small (see iparm(16) on output
c         for minimum required work space length)
c
c     =10 if xa >= xb or yc >= yd
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4))
c
c     =11 if tolmax = fparm(5) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(1) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c     =13 if there is a pure tangential derivative along a mixed derivative
c         boundary (e.g., nyd = 2 and betyd(x) = 0.0 for some
c         grid point x along y = yd)
c
c     =14 if there is the "singular" condition described below at a
c         cornor which is the intersection of two derivative boundaries.
c
c         (1) the cornor (xa,yc) if nxa=nyc=2 and
c             alfxa(yc)*betyc(xa)-alfyc(xa)*betxa(yc) = 0.0.
c
c         (2) the cornor (xa,yd) if nxa=nyd=2 and
c             alfxa(yd)*betyd(xa)-alfyd(xa)*betxa(yd) = 0.0.
c
c         (3) the cornor (xb,yc) if nxb=nyc=2 and
c             alfxb(yc)*betyc(xb)-alfyc(xb)*betxb(yc) = 0.0.
c
c         (4) the cornor (xb,yd) if nxb=nyd=2 and
c             alfxb(yd)*betyd(xb)-alfyd(xb)*betxb(yd) = 0.0.
c
c *** the conditions described in ierror = 13 or 14 will lead to division
c     by zero during discretization if undetected.
c
c
c *********************************************************
c *********************************************************
c
c     end of mud2cr documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="mud2sa.txt"><b>MUD2SA</b></a>
<PRE>
c
c     file mud2sa.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file mud2sa.d
c
c     contains documentation for:
c     subroutine mud2sa(iparm,fparm,work,sigx,sigy,bndyc,rhs,phi,mgopt,ierror)
c     a sample fortran driver is file "tmud2sa.f".
c
c ... required mudpack files
c
c     mudcom.f
c
c
c ... purpose
c
c     subroutine mud2sa automatically discretizes and attempts to
c     compute the second order conservative finite difference approximation
c     to a two dimensional linear nonseparable "self adjoint" elliptic
c     partial differential equation on a rectangle.  the approximation
c     is generated on a uniform grid covering the rectangle.  boundary
c     conditions may be specified (Dirchlet), periodic, or mixed.
c     the form of the pde solved is:
c
c          d(sigx(x,y)*dp/dx)/dx  + d(sigy(x,y)*dp/dy)/dy -
c
c          xlmbda(x,y)*p(x,y) = r(x,y)
c
c     where sigx(x,y),sigy(x,y) (both positive), xlmbda(x,y) (non-negative)
c     r(x,y) (the given right hand side) and p(x,y) (the unknown solution
c     function) are all real valued functions of the real independent
c     variables x,y. the use of the variable names "x,y" is arbitrary and
c     does not imply the cartesian coordinate system underlies the pde.
c     for example, any pde in divergence form in cartesian coordinates can
c     be put in a self-adjoint form suitable for mud2sa after a curvilinear
c     coordinate transform (see tmud2sa.f)
c                                                                               
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny grid.  the grid
c     is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1)
c
c     be the uniform grid increments in the x,y directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly
c
c     for i=1,...,nx and j=1,...,ny  denote the x,y uniform mesh points
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 17 used to pass integer
c          arguments.  iparm is set internally and defined as
c          follows:
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      an approximation is not generated after an intl=0 call!
c          mud2sa should be called with intl=1 to approximate the elliptic
c          pde discretized by the intl=0 call.  intl=1 should also
c          be input if mud2sa has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  this will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) mud2sa is being recalled for additional accuracy.  in
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) mud2sa is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) mud2sa is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to mud2sa

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by coef (see below) have
c              changed since the previous call
c
c          (e) any of the "alfa" coefficients input by bndyc (see below)
c              have changed since the previous call.
c
c          if any of (a) through (e) are true then the elliptic pde
c          must be discretized or rediscretized.  if none of (a)
c          through (e) holds, calls can be made with intl=1.
c          incorrect calls with intl=1 will produce erroneous results.
c  ***     the values set in the saved work space "work" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the edge x=xa
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y
c            (if nxa=0 then nxb=0 is required, see ierror = 2)
c
c        = 1 if p(xa,y) is specified (this must be input thru phi(1,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see bndyc)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the edge x=xb
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y)
c            (if nxb=0 then nxa=0 is required, see ierror = 2)
c
c        = 1 if p(xb,y) is specified (this must be input thru phi(nx,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see bndyc)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the edge y=yc
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c            (if nyc=0 then nyd=0 is required, see ierror = 2)
c
c        = 1 if p(x,yc) is specified (this must be input thru phi(i,1))
c
c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see bndyc)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the edge y=yd
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c             (if nyd=0 then nyc=0 is required, see ierror = 2)
c
c        = 1 if p(x,yd) is specified (this must be input thru phi(i,ny))
c
c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see bndyc)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(6)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the x direction is not used.
c          if ixp > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of ixp can be removed by increasing iex = iparm(8)
c          without changing nx = iparm(10).
c
c
c ... jyq = iparm(7)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the y direction is not used.
c          if jyq > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of jyq can be removed by increasing jey = iparm(9)
c          without changing ny = iparm(11).
c
c
c ... iex = iparm(8)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx.
c
c
c ... jey = iparm(9)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(7)
c          as small as possible within grid size constraints when
c          defining ny.
c
c
c
c ... nx = iparm(10)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(6), iex = iparm(8).
c
c
c ... ny = iparm(11)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(7), jey = iparm(9).
c
c
c *** example
c
c         suppose a solution is wanted on a 33 by 97 grid.  then
c         ixp=2, jyq=6 and iex=jey=5 could be used.  a better
c         choice would be ixp=2, jyq=3, and iex=5, jey=6.
c
c *** grid size flexibility considerations:
c
c     the hybrid multigrid/direct method code muh2 provides more grid size
c     flexibility than mud2sa by removing the constraint that ixp and jyq are
c     2 or 3.  this is accomplished by using a direct method whenever the
c     coarsest (ixp+1) x (jyq+1) grid is encountered in multigrid cycling.
c     if nx = ixp+1 and ny = jyq+1 then muh2 becomes a full direct method.
c     muh2 is roughly equivalent to mud2sa in efficiency as long as ixp and
c     jyq remain "small" (see muh2.d).  if the problem to be approximated
c     requires a grid neither mud2sa por muh2 can exactly fit then another option
c     is to generate an approximation on a "close grid" using mud2sa or muh2.
c     then transfer the result to the required grid using cubic interpolation
c     via the package "regridpack"(contact john adams about this software)
c
c *** note
c
c     let g be the nx by ny fine grid on which the approximation is
c     generated and let n = max0(iex,jey).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         g(1) < ... < g(k) < ... < g(n) = g.
c
c     each g(k) (k=1,...,n) has mx(k) by my(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c
c
c ... iguess=iparm(12)
c
c          = 0 if no initial guess to the pde is provided
c
c          = 1 if an initial guess to the pde is at the finest grid
c              level is provided in phi (see below)
c
c     comments on iguess = 0 or 1 . . .
c
c     even if iguess = 0, phi must be initialized at all grid points (this
c     is not checked).  phi can be set to 0.0 at non-dirchlet grid points
c     if nothing better is available.  the values set in phi when iguess = 0
c     are passed down and serve as an initial guess to the pde at the coarsest
c     grid level where cycling commences.  in this sense, values input in
c     phi always serve as an initial guess.  setting iguess = 0 forces full
c     multigrid cycling beginning at the coarsest and finishing at the finest
c     grid level.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c     time dependent problems . . .
c
c *** assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at nondirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(13)
c
c          the exact number of cycles executed between the finest (nx by
c          ny) and the coarsest ((ixp+1) by (jyq+1)) grid levels when
c          tolmax=fparm(5)=0.0 (no error control).  when tolmax > 0.0
c          is input (error control) then maxcy is a limit on the number
c          of cycles between the finest and coarsest grid levels.  in
c          any case, at most maxcy*(iprer+ipost) relaxation sweeps are
c          are performed at the finest grid level (see iprer=mgopt(2),
c          ipost=mgopt(3) below).  when multigrid iteration is working
c          "correctly" only a few are required for convergence.  large
c          values for maxcy should not be necessary.
c
c
c ... method = iparm(14) determines the method of relaxation
c              (gauss-seidel based on alternating points or lines)
c
c          = 0 for  point relaxation
c
c          = 1 for line relaxation in the x direction
c
c          = 2 for line relaxation in the y direction
c
c          = 3 for line relaxation in both the x and y direction
c
c
c *** choice of method. . .
c
c     let fx represent the quantity sigx(x,y)/dlx**2 over the solution region.
c
c     let fy represent the quantity sigy(x,y)/dly**2 over the solution region
c
c     if fx,fy are roughly the same size and do not vary too much over
c     the solution region choose method = 0.  if this fails try method=3.
c
c     if fx is much greater than fy choose method = 1.
c
c     if fy is much greater than fx choose method = 2
c
c     if neither fx or fy dominates over the solution region and they
c     both vary considerably choose method = 3.
c
c
c ... length = iparm(15)
c
c          the length of the work space provided in vector work (see below).
c          let isx = 0 if method = 0 or method = 2
c          let isx = 3 if method = 1 or method = 3 and nxa.ne.0
c          let isx = 5 if method = 1 or method = 3 and nxa.eq.0
c          let jsy = 0 if method = 0 or method = 1
c          let jsy = 3 if method = 2 or method = 3 and nyc.ne.0
c          let jsy = 5 if method = 2 or method = 3 and nyc.eq.0
c          then . . .
c
c               length = 4*[nx*ny*(10+isx+jsy)+8*(nx+ny+2)]/3
c
c          will suffice in most cases.  the exact minimal work space
c          length required for the current nx,ny and method is output
c          in iparm(16) (even if iparm(15) is too small).  this will be
c          less then the value given by the simplified formula above
c          in most cases.
c
c
c ... fparm                                                                     
c
c          a floating point vector of length 6 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in mud2sa and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... tolmax = fparm(5)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j)
c          and phi2(i,j) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(abs(phi2(i,j)-phi1(i,j))) for all i,j
c
c          and
c
c              phmax = max(abs(phi2(i,j))) for all i,j
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(5)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible do not use error control!).
c
c ... work                                                                      
c
c          a one dimensional real saved work space (see iparm(15) for
c          length) which must be preserved from the previous call when
c          calling with intl=iparm(1)=1.
c
c ... bndyc                                                                     
c
c          a subroutine with  arguments (kbdy,xory,alfa,gbdy) which
c          are used to input mixed boundary conditions to mud2sa. bndyc
c          must be declared "external" in the program calling mud2sa.
c          the boundaries are numbered one thru four and the mixed
c          derivative boundary conditions are described below (see the
c          sample driver code "tmud2sa.f" for an example of how bndyc is
c          can beset up).
c                                                                               
c          * * * * * * * * * * * *  y=yd
c          *       kbdy=4        *
c          *                     *
c          *                     *
c          *                     *
c          * kbdy=1       kbdy=2 *
c          *                     *
c          *                     *
c          *                     *
c          *       kbdy=3        *
c          * * * * * * * * * * * *  y=yc
c
c          x=xa                  x=xb
c
c
c          (1) the kbdy=1 boundary
c
c          this is the edge x=xa where nxa=iparm(2)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dx + alfxa(y)*p(xa,y) = gbdxa(y)
c
c          in this case kbdy=1,xory=y will be input to bndyc and
c          alfa,gbdy corresponding to alfxa(y),gbdxa(y) must be returned.
c
c
c          (2) the kbdy=2 boundary
c
c          this is the edge x=xb where nxb=iparm(3)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dx + alfxb(y)*p(xb,y) = gbdxb(y)
c
c          in this case kbdy=2,xory=y, will be input to bndyc and
c          alfa,gbdy corresponding to alfxb(y),gbdxb(y) must be returned.
c
c
c          (3) the kbdy=3 boundary
c
c          this is the edge y=yc where nyc=iparm(4)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dy + alfyc(x)*p(x,yc) = gbdyc(x)
c
c          in this case kbdy=3,xory=x will be input to bndyc and
c          alfa,gbdy corresponding to alfyc(x),gbdyc(x) must be returned.
c
c
c          (4) the kbdy=4 boundary
c
c          this is the edge y=yd where nyd=iparm(5)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dy + alfyd(x)*p(x,yd) = gbdyd(x)
c
c          in this case kbdy=4,xory=x will be input to bndyc and
c          alfa,gbdy corresponding to alfyd(x),gbdyd(x) must be returned.
c
c                                                                               
c ***      bndyc must provide the mixed boundary condition values
c          in correspondence with those flagged in iparm(2) thru
c          iparm(5).  if all boundaries are specified or periodic
c          mud2sa will never call bndyc.  even then it must be entered
c          as a dummy subroutine. bndyc must be declared "external"
c          in the routine calling mud2sa.  the actual name chosen may
c          be different.
c
c
c ... sigx,sigy
c
c         function subroutines which returns the real value of the
c         coefficients at any point (x,y).  they must be constructed
c         to return values outside the solution region for nonDirchlet
c         boundaries.  Let dx = (xb=xa)/ixp and dy = (yd-yc)/jyq.
c         then sigx,sigy will be invoked for x,y in the intervals
c         [xa-0.5*dx,xa], [xb,xb+0.5*dx], [yc-0.5*dy,yc], [yd,yd+0.5*dy]
c         whenever boundary conditions at x=xa,x=xb,y=yc,y=yd are unspecified.
c         this is necessitated by conservative finite differencing. sigx,
c         sigy will not be invoked outside specified boundaries.  sigx,
c         sigy should be positive for all (x,y) (see ierror = -2). they
c         must be declared "external" in the user constructed program calling
c         mud2sa where their names may be different.
c
c ... xlmbda
c
c         a real valued function subroutine which returns the value
c         of "xlmbda" in the pde at any grid point (xi,yj).  xlmbda should
c         be nonnegative for any (xi,yj) (see ierror = -4). xlmbda must be
c         declared "external" in the user constructed program calling
c         mud2sa where its name may be different.
c
c
c ... rhs                                                                       
c
c          an array dimensioned nx by ny which contains the given
c          right hand side values on the uniform 2-d mesh.
c
c              rhs(i,j) = r(xi,yj) for i=1,...,nx and j=1,...,ny
c
c ... phi                                                                       
c
c          an array dimensioned nx by ny.  on input phi must contain
c          specified boundary values. for example, if nyd=iparm(5)=1
c          then phi(i,ny) must be set equal to p(xi,yd) for i=1,...nx
c          prior to calling mud2sa.  these values are preserved by mud2sa.
c          if an initial guess is provided (iguess=iparm(11)=1) it must
c          be input thru phi.
c
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at all grid points (this is not checked).  these
c          values will serve as an initial guess to the pde at the coarsest
c          grid level after a transfer from the fine solution grid.  set phi
c          equal to to 0.0 at all internal and non-specified boundaries
c          grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid parameters (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the parameters
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).  all version 5.0.1
c     mudpack solvers use only fully weighted residual restriction
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---3-----3-----------3-----------------3---------------     level 1
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --6---6-------6---6-----------6---6-------6---6--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c
c **********************************************************************
c *** output arguments ************************************************
c **********************************************************************
c
c
c ... iparm(16)  *** set for intl=0 calls only
c
c          on output iparm(16) contains the actual work space length
c          required.  this will usually be less than that given by the
c          simplified formula for length=iparm(15) (see as input argument)
c
c
c ... iparm(17)  *** set for intl=1 calls only
c
c          on output iparm(17) contains the actual number of multigrid cycles
c          between the finest and coarsest grid levels used to obtain the
c          approximation when error control (tolmax > 0.0) is set.
c
c
c ... fparm(6)   *** set for intl=1 calls with fparm(5) > 0. only
c
c          on output fparm(6) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(6) is computed only if there is error control (tolmax > 0.0)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c               phdif = max(abs(phi2(i,j)-phi1(i,j))) over all i,j
c
c          and
c
c               phmax = max(abs(phi2(i,j)) over all i,j
c
c          then
c
c               fparm(6) = phdif/phmax
c
c          is returned whenever phmax > 0.0. in the degenerate case
c          phmax = 0.0, fparm(6) = phdif is returned.
c
c
c ... work
c
c          on output work contains intermediate values that must not
c          be destroyed if mud2sa is to be called again with intl=1
c
c
c ... phi   *** for intl=1 calls only
c
c          on output phi(i,j) contains the approximation to p(xi,yj)
c          for all mesh points i = 1,...,nx and j=1,...,ny.  the last
c          computed iterate in phi is returned even if convergence is
c          not obtained
c
c
c ... ierror
c
c          for intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  argument checking and discretization
c          is bypassed for intl=1 calls which can only return
c          ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if xlmbda < 0 for some grid point (xi,yj)
c
c
c     =-3  if the continuous elliptic pde is singular.  this means the
c          boundary conditions are periodic or pure derivative at all
c          boundaries and xlmbda(x,y) = 0.0 for all x,y.  a solution is still
c          attempted but convergence may not occur due to ill-conditioning
c          of the linear system coming from the discretization.  the
c          ierror = -3 flag overrides the ierror=-4,-5 nonfatal flags.
c
c
c     =-2  if the pde is not elliptic (sigx(x,y) or sigy(x,y) .le. 0.0).
c          in this case a solution is still attempted although convergence
c          may not occur due to ill-conditioning of the linear system.
c          the ierror = -2 flag overrides the ierror=-5,-4,-3 nonfatal
c          flags.
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd
c         in iparm(2),iparm(3),iparm(4),iparm(5) are not 0,1 or 2
c         or if nxa,nxb or nyc,nyd are not pairwise zero.
c
c     = 3 if mino(ixp,jyq) < 2 (ixp = iparm(6), jyq = iparm(7))
c
c     = 4 if min0(iex,jey) < 1 (iex = iparm(8), jey = iparm(9)) or
c         if max0(iex,jey) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or ny.ne.jyq*2**(jey-1)+1
c         (nx = iparm(10), ny = iparm(11))
c
c     = 6 if iguess = iparm(12) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(13) < 1
c
c     = 8 if method = iparm(14) is not 0,1,2, or 3
c
c     = 9 if length = iparm(15) is too small (see iparm(16) on output
c         for minimum required work space length)
c
c     =10 if xa >= xb or yc >= yd
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4))
c
c     =11 if tolmax = fparm(5) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(2) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c *********************************************************
c *********************************************************
c
c     end of mud2sa documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="mud2sp.txt"><b>MUD2SP</b></a>
<PRE>
c
c     file mud2sp.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file mud2sp.d
c
c     contains documentation for:
c     subroutine mud2sp(iparm,fparm,work,cofx,cofy,bndyc,rhs,phi,mgopt,ierror)
c     A sample fortran driver is file "tmud2sp.f".
c
c ... required MUDPACK files
c
c     mudcom.f
c
c ... purpose
c
c     subroutine mud2sp automatically discretizes and attempts to compute
c     the second-order difference approximation to the two-dimensional
c     linear separable elliptic partial differential equation on a
c     rectangle.  the approximation is generated on a uniform grid covering
c     the rectangle (see mesh description below).  boundary conditions
c     may be specified (dirchlet), periodic, or mixed derivative in any
c     combination.  the form of the pde solved is:
c
c
c          cxx(x)*pxx + cx(x)*px + cex(x)*p(x,y) +
c
c          cyy(y)*pyy + cy(y)*py + cey(y)*p(x,y) = r(x,y)
c
c     pxx,pyy,px,py are second and first partial derivatives of the
c     unknown real solution function p(x,y) with respect to the
c     independent variables x,y.  cxx,cx,cex,cyy,cy,cey are the known
c     real coefficients of the elliptic pde and r(x,y) is the known
c     real right hand side of the equation.  cxx and cyy should be
c     positive for all x,y in the solution region.  If some of the
c     coefficients depend on both x and y then the PDE is nonseparable.
c     In this case subroutine muh2 or mud2 must be used instead of mud2sp
c     (see the files muh2.d or mud2.d)
c                                                                               
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny grid.  the grid
c     is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1)
c
c     be the uniform grid increments in the x,y directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly
c
c     for i=1,...,nx and j=1,...,ny  denote the x,y uniform mesh points
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with Fortran77
c     and Fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 17 used to pass integer
c          arguments.  iparm is set internally and defined as
c          follows:
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      An approximation is NOT generated after an intl=0 call!
c          mud2sp should be called with intl=1 to approximate the elliptic
c          PDE discretized by the intl=0 call.  intl=1 should also
c          be input if mud2sp has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  This will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  Some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) mud2sp is being recalled for additional accuracy.  In
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) mud2sp is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) mud2sp is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to mud2sp

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by cofx,cofy (see below) have
c              changed since the previous call
c
c          (e) any of the constant "alfa" coefficients input by bndyc
c              (see below) have changed since the previous call.
c
c          If any of (a) through (e) are true then the elliptic PDE
c          must be discretized or rediscretized.  If none of (a)
c          through (e) holds, calls can be made with intl=1.
c          Incorrect calls with intl=1 will produce erroneous results.
c  ***     The values set in the saved work space "work" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the edge x=xa
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y
c            (if nxa=0 then nxb=0 is required, see ierror = 2)
c
c        = 1 if p(xa,y) is specified (this must be input thru phi(1,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see bndyc)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the edge x=xb
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y)
c            (if nxb=0 then nxa=0 is required, see ierror = 2)
c
c        = 1 if p(xb,y) is specified (this must be input thru phi(nx,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see bndyc)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the edge y=yc
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c            (if nyc=0 then nyd=0 is required, see ierror = 2)
c
c        = 1 if p(x,yc) is specified (this must be input thru phi(i,1))
c
c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see bndyc)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the edge y=yd
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c             (if nyd=0 then nyc=0 is required, see ierror = 2)
c
c        = 1 if p(x,yd) is specified (this must be input thru phi(i,ny))
c
c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see bndyc)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(6)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the x direction is not used.
c          if ixp > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of ixp can be removed by increasing iex = iparm(8)
c          without changing nx = iparm(10).
c
c
c ... jyq = iparm(7)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the y direction is not used.
c          if jyq > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of jyq can be removed by increasing jey = iparm(9)
c          without changing ny = iparm(11).
c
c
c ... iex = iparm(8)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx.
c
c
c ... jey = iparm(9)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(7)
c          as small as possible within grid size constraints when
c          defining ny.
c
c
c
c ... nx = iparm(10)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(6), iex = iparm(8).
c
c
c ... ny = iparm(11)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(7), jey = iparm(9).
c
c
c *** example
c
c         suppose a solution is wanted on a 33 by 97 grid.  then
c         ixp=2, jyq=6 and iex=jey=5 could be used.  a better
c         choice would be ixp=2, jyq=3, and iex=5, jey=6.
c
c
c *** note
c
c     let G be the nx by ny fine grid on which the approximation is
c     generated and let n = max0(iex,jey).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         G(1) < ... < G(k) < ... < G(n) = G.
c
c     each G(k) (k=1,...,n) has mx(k) by my(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c
c
c ... iguess=iparm(12)
c
c          = 0 if no initial guess to the pde is provided
c
c          = 1 if an initial guess to the pde is at the finest grid
c              level is provided in phi (see below)
c
c     comments on iguess = 0 or 1 . . .
c
c     even if iguess = 0, phi must be initialized at all grid points (this
c     is not checked).  phi can be set to 0.0 at non-dirchlet grid points
c     if nothing better is available.  the values set in phi when iguess = 0
c     are passed down and serve as an initial guess to the pde at the coarsest
c     grid level where cycling commences.  in this sense, values input in
c     phi always serve as an initial guess.  setting iguess = 0 forces full
c     multigrid cycling beginning at the coarsest and finishing at the finest
c     grid level.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c     time dependent problems . . .
c
c *** assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at nondirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(13)
c
c          the exact number of cycles executed between the finest (nx by
c          ny) and the coarsest ((ixp+1) by (jyq+1)) grid levels when
c          tolmax=fparm(5)=0.0 (no error control).  when tolmax > 0.0
c          is input (error control) then maxcy is a limit on the number
c          of cycles between the finest and coarsest grid levels.  in
c          any case, at most maxcy*(iprer+ipost) relaxation sweeps are
c          are performed at the finest grid level (see iprer=mgopt(2),
c          ipost=mgopt(3) below).  when multigrid iteration is working
c          "correctly" only a few are required for convergence.  large
c          values for maxcy should not be necessary.
c
c
c ... method = iparm(14) determines the method of relaxation
c              (gauss-seidel based on alternating points or lines)
c
c          = 0 for  point relaxation
c
c          = 1 for line relaxation in the x direction
c
c          = 2 for line relaxation in the y direction
c
c          = 3 for line relaxation in both the x and y direction
c
c
c *** choice of method. . .
c
c     let fx represent the quantity cxx(x,y)/dlx**2 over the solution region.
c
c     let fy represent the quantity cyy(x,y)/dly**2 over the solution region
c
c     if fx,fy are roughly the same size and do not vary too much over
c     the solution region choose method = 0.  if this fails try method=3.
c
c     if fx is much greater than fy choose method = 1.
c
c     if fy is much greater than fx choose method = 2
c
c     if neither fx or fy dominates over the solution region and they
c     both vary considerably choose method = 3.
c
c
c ... length = iparm(15)
c
c          the length of the work space provided in vector work (see below).
c          let isx = 0 if method = 0 or method = 2
c          let isx = 3 if method = 1 or method = 3 and nxa.ne.0
c          let isx = 5 if method = 1 or method = 3 and nxa.eq.0
c          let jsy = 0 if method = 0 or method = 1
c          let jsy = 3 if method = 2 or method = 3 and nyc.ne.0
c          let jsy = 5 if method = 2 or method = 3 and nyc.eq.0
c          then . . .
c
c               length = nx*ny*(5+3*(isx+jsy)/2)+ 10*(nx+ny)
c
c          will suffice in all cases but very small nx and ny.
c          the exact minimal work space length required for the
c          current set of input arugments is output in iparm(16).
c          (even if iparm(15) is too small).  this will be usually
c          be less then the value given by the simplified formula
c          above.  * Notice that mud2sp requires considerably less
c          work space than the nonseparable solvers muh2,mud2 if
c          and only if method=0 is chosen.
c
c ... fparm                                                                     
c
c          a floating point vector of length 6 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in mud2sp and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... tolmax = fparm(5)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j)
c          and phi2(i,j) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(abs(phi2(i,j)-phi1(i,j))) for all i,j
c
c          and
c
c              phmax = max(abs(phi2(i,j))) for all i,j
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(5)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible DO NOT use error control!).
c
c ... work                                                                      
c
c          a one dimensional real saved work space (see iparm(15) for
c          length) which must be preserved from the previous call when
c          calling with intl=iparm(1)=1.
c
c ... bndyc                                                                     
c
c          a subroutine with  arguments (kbdy,xory,alfa,gbdy) which
c          are used to input mixed boundary conditions to mud2sp. bndyc
c          must be declared "external" in the program calling mud2sp.
c          the boundaries are numbered one thru four and the mixed
c          derivative boundary conditions are described below (see the
c          sample driver code "tmud2sp.f" for an example of how bndyc is
c          can beset up).
c                                                                               
c          * * * * * * * * * * * *  y=yd
c          *       kbdy=4        *
c          *                     *
c          *                     *
c          *                     *
c          * kbdy=1       kbdy=2 *
c          *                     *
c          *                     *
c          *                     *
c          *       kbdy=3        *
c          * * * * * * * * * * * *  y=yc
c
c          x=xa                  x=xb
c
c
c          (1) the kbdy=1 boundary
c
c          this is the edge x=xa where nxa=iparm(2)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dx + alfxa*p(xa,y) = gbdxa(y)
c
c          in this case kbdy=1,xory=y will be input to bndyc and
c          alfa,gbdy corresponding to alfxa,gbdxa(y) must be returned
c
c
c          (2) the kbdy=2 boundary
c
c          this is the edge x=xb where nxb=iparm(3)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dx + alfxb*p(xb,y) = gbdxb(y)
c
c          in this case kbdy=2,xory=y, will be input to bndyc and
c          alfa,gbdy corresponding to alfxb,gbdxb(y) must be returned.
c
c
c          (3) the kbdy=3 boundary
c
c          this is the edge y=yc where nyc=iparm(4)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dy + alfyc*p(x,yc) = gbdyc(x)
c
c          in this case kbdy=3,xory=x will be input to bndyc and
c          alfa,gbdy corresponding to alfyc,gbdyc(x) must be returned.
c
c
c          (4) the kbdy=4 boundary
c
c          this is the edge y=yd where nyd=iparm(5)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dy + alfyd*p(x,yd) = gbdyd(x)
c
c          in this case kbdy=4,xory=x will be input to bndyc and
c          alfa,gbdy corresponding to alfyd,gbdyd(x) must be returned.
c
c                                                                               
c ***      alfxa,alfxb,alfyc,alfyd must be constants for mud2sp.
c          Use muh2 or mud2 if any of these depend on x or y.
c          bndyc must provide the mixed boundary condition values
c          in correspondence with those flagged in iparm(2) thru
c          iparm(5).  if all boundaries are specified or periodic
c          mud2sp will never call bndyc.  even then it must be entered
c          as a dummy subroutine. bndyc must be declared "external"
c          in the routine calling mud2sp the actual name chosen may
c          be different.
c
c
c ... cofx
c
c         a subroutine with arguments (x,cxx,cx,cex) which provides
c         the known real x dependent coefficients for the separable
c         elliptic pde at any x grid point.  the name chosen in the calling
c         routine may be different where the coefficient routine must be declared
c         "external."
c
c ... cofy
c
c         a subroutine with arguments (y,cyy,cy,cey) which provides
c         the known real y dependent coefficients for the separable
c         elliptic pde at any y grid point.  the name chosen in the calling
c         routine may be different where the coefficient routine must be declared
c         "external."
c
c ... rhs                                                                       
c
c          an array dimensioned nx by ny which contains the given
c          right hand side values on the uniform 2-d mesh.
c
c              rhs(i,j) = r(xi,yj) for i=1,...,nx and j=1,...,ny
c
c ... phi                                                                       
c
c          an array dimensioned nx by ny.  on input phi must contain
c          specified boundary values. for example, if nyd=iparm(5)=1
c          then phi(i,ny) must be set equal to p(xi,yd) for i=1,...nx
c          prior to calling mud2sp.  these values are preserved by mud2sp.
c          if an initial guess is provided (iguess=iparm(11)=1) it must
c          be input thru phi.
c
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at all grid points (this is not checked).  these
c          values will serve as an initial guess to the pde at the coarsest
c          grid level after a transfer from the fine solution grid.  set phi
c          equal to to 0.0 at all internal and non-specified boundaries
c          grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid arguments (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the arguments
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).  all version 5.0.1
c     mudpack solvers use only fully weighted residual restriction
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---3-----3-----------3-----------------3---------------     level 1
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --6---6-------6---6-----------6---6-------6---6--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c
c **********************************************************************
c *** output arguments ************************************************
c **********************************************************************
c
c
c ... iparm(16)  *** set for intl=0 calls only
c
c          on output iparm(16) contains the actual work space length
c          required.  this will usually be less than that given by the
c          simplified formula for length=iparm(15) (see as input argument)
c
c
c ... iparm(17)  *** set for intl=1 calls only
c
c          on output iparm(17) contains the actual number of multigrid cycles
c          between the finest and coarsest grid levels used to obtain the
c          approximation when error control (tolmax > 0.0) is set.
c
c
c ... fparm(6)   *** set for intl=1 calls with fparm(5) > 0. only
c
c          on output fparm(6) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(6) is computed only if there is error control (tolmax > 0.0)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c               phdif = max(abs(phi2(i,j)-phi1(i,j))) over all i,j
c
c          and
c
c               phmax = max(abs(phi2(i,j)) over all i,j
c
c          then
c
c               fparm(6) = phdif/phmax
c
c          is returned whenever phmax > 0.0. in the degenerate case
c          phmax = 0.0, fparm(6) = phdif is returned.
c
c
c ... work
c
c          on output work contains intermediate values that must not
c          be destroyed if mud2sp is to be called again with intl=1
c
c
c ... phi   *** for intl=1 calls only
c
c          on output phi(i,j) contains the approximation to p(xi,yj)
c          for all mesh points i = 1,...,nx and j=1,...,ny.  the last
c          computed iterate in phi is returned even if convergence is
c          not obtained
c
c
c ... ierror
c
c          For intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  Argument checking and discretization
c          is bypassed for intl=1 calls which can only return
c          ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              abs(cx)*dlx > 2.*abs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              abs(cy)*dly > 2.*abs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c
c             cxx = amax1(cxx,0.5*abs(cx)*dx)
c
c                          (and)
c
c             cyy = amax1(cyy,0.5*abs(cy)*dy)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made to preserve convergence of multigrid iteration. if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-3  if the continuous elliptic pde is singular.  this means the
c          boundary conditions are periodic or pure derivative at all
c          boundaries and ce(x,y) = 0.0 for all x,y.  a solution is still
c          attempted but convergence may not occur due to ill-conditioning
c          of the linear system coming from the discretization.  the
c          ierror = -3 flag overrides the ierror=-4 and ierror=-5 nonfatal
c          flags.
c
c
c     =-2  if the pde is not elliptic (i.e., cxx*cyy.le.0.0 for some (xi,yj))
c          in this case a solution is still attempted although convergence
c          may not occur due to ill-conditioning of the linear system.
c          the ierror = -2 flag overrides the ierror=-5,-4,-3 nonfatal
c          flags.
c
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on the first call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd
c         in iparm(2),iparm(3),iparm(4),iparm(5) are not 0,1 or 2
c         or if nxa,nxb or nyc,nyd are not pairwise zero.
c
c     = 3 if mino(ixp,jyq) < 2 (ixp = iparm(6), jyq = iparm(7))
c
c     = 4 if min0(iex,jey) < 1 (iex = iparm(8), jey = iparm(9)) or
c         if max0(iex,jey) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or ny.ne.jyq*2**(jey-1)+1
c         (nx = iparm(10), ny = iparm(11))
c
c     = 6 if iguess = iparm(12) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(13) < 1
c
c     = 8 if method = iparm(14) is not 0,1,2, or 3
c
c     = 9 if length = iparm(15) is too small (see iparm(16) on output
c         for minimum required work space length)
c
c     =10 if xa >= xb or yc >= yd
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4))
c
c     =11 if tolmax = fparm(5) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(1) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c *********************************************************
c *********************************************************
c
c     end of mud2sp documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="mud3.txt"><b>MUD3</b></a>
<PRE>
c
c     file mud3.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file mud3.d
c
c     contains documentation for:
c     subroutine mud3(iparm,fparm,work,coef,bndyc,rhs,phi,mgopt,ierror)
c     A sample fortran driver is file "tmud3.f".
c
c ... required MUDPACK files
c
c     mudcom.f, mud3ln.f, mud3pn.f
c
c ... purpose
c
c     subroutine mud3 automatically discretizes and attempts to compute
c     the second order finite difference approximation to a three-
c     dimensional linear nonseparable elliptic partial differential
c     equation on a box.  the approximation is generated on a uniform
c     grid covering the box (see mesh description below).  boundary
c     conditions may be any combination of mixed, specified (Dirchlet)
c     or periodic.  the form of the pde solved is . . .
c
c          cxx(x,y,z)*pxx + cyy(x,y,z)*pyy + czz(z,y,z)*pzz +
c
c          cx(x,y,z)*px + cy(x,y,z)*py + cz(x,y,z)*pz +
c
c          ce(x,y,z)*p(x,y,z) = r(x,y,z)
c
c     here cxx,cyy,czz,cx,cy,cz,ce are the known real coefficients
c     of the pde; pxx,pyy,pzz,px,py,pz are the second and first
c     partial derivatives of the unknown solution function p(x,y,z)
c     with respect to the independent variables x,y,z; r(x,y,z) is
c     is the known real right hand side of the elliptic pde.  cxx,cyy
c     and czz should be positive for all (x,y,z) in the solution region.
c                                                                               
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny by nz grid.
c     the grid is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd] x [ze,zf].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1), dlz = (zf-ze)/(nz-1)
c
c     be the uniform grid increments in the x,y,z  directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly, zk = ze+(k-1)*dlz
c
c     for i=1,...,nx; j=1,...,ny; k=1,...,nz  denote the x,y,z uniform
c     mesh points.
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with Fortran77
c     and Fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 23 used to efficiently pass
c          integer arguments.  iparm is set internally in mud3
c          and defined as follows . . .                                         
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      An approximation is NOT generated after an intl=0 call!
c          mud3 should be called with intl=1 to approximate the elliptic
c          PDE discretized by the intl=0 call.  intl=1 should also
c          be input if mud3 has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  This will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  Some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) mud3 is being recalled for additional accuracy.  In
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) mud3 is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) mud3 is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to mud3

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by coef (see below) have
c              changed since the previous call
c
c          (e) any of the "alfa" coefficients input by bndyc (see below)
c              have changed since the previous call.
c
c          If any of (a) through (e) are true then the elliptic PDE
c          must be discretized or rediscretized.  If none of (a)
c          through (e) holds, calls can be made with intl=1.
c          Incorrect calls with intl=1 will produce erroneous results.
c  ***     The values set in the saved work space "work" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the (y,z) plane x=xa                    
c
c        = 0 if p(x,y,z) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y,z) = p(x,y,z) for all x,y,z)
c
c        = 1 if p(xa,y,z) is specified  (this must be input thru phi(1,j,k))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see "bndyc" description below where kbdy = 1)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the (y,z) plane x=xb                    
c
c        = 0 if p(x,y,z) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y,z) = p(x,y,z) for all x,y,z)
c
c        = 1 if p(xb,y,z) is specified (this must be input thru phi(nx,j,k))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see "bndyc" description below where kbdy = 2)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the (x,z) plane y=yc                    
c
c        = 0 if p(x,y,z) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc,z) = p(x,y,z) for all x,y,z)

c        = 1 if p(x,yc,z) is specified (this must be input thru phi(i,1,k))

c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see "bndyc" description below where kbdy = 3)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the (x,z) plane y=yd                    
c
c        = 0 if p(x,y,z) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc,z) = p(x,y,z) for all x,y,z)

c        = 1 if p(x,yd,z) is specified (this must be input thru phi(i,ny,k))

c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see "bndyc" description below where kbdy = 4)
c
c
c ... nze=iparm(6)
c
c          flags boundary conditions on the (x,y) plane z=ze                    
c
c        = 0 if p(x,y,z) is periodic in z on [ze,zf]
c            (i.e., p(x,y,z+zf-ze) = p(x,y,z) for all x,y,z

c        = 1 if p(x,y,ze) is specified (this must be input thru phi(i,j,1))

c        = 2 if there are mixed derivative boundary conditions at z=ze
c            (see "bndyc" description below where kbdy = 5)
c
c
c ... nzf=iparm(7)
c
c          flags boundary conditions on the (x,y) plane z=zf                    
c
c        = 0 if p(x,y,z) is periodic in z on [ze,zf]
c            (i.e., p(x,y,z+zf-ze) = p(x,y,z) for all x,y,z

c        = 1 if p(x,y,zf) is specified (this must be input thru phi(i,j,nz))

c        = 2 if there are mixed derivative boundary conditions at z=zf
c            (see "bndyc" description below where kbdy = 6)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(8)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(14)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible.
c          recommended values are the small primes 2 or 3 or (possibly) 5.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the x direction is not used.
c          if ixp > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of ixp can be removed by increasing iex = iparm(11)
c          without changing nx = iparm(14)
c
c
c ... jyq = iparm(9)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(15)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible.
c          recommended values are the small primes 2 or 3 or (possibly) 5.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the y direction is not used.
c          if jyq > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of jyq can be removed by increasing jey = iparm(12)
c          without changing ny = iparm(15)
c
c
c ... kzr = iparm(10)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the z direction (see nz = iparm(16)).  "kzr+1"
c          is the number of points on the coarsest z grid visited during
c          multigrid cycling.  kzr should be chosen as small as possible.
c          recommended values are the small primes 2 or 3 or (possibly) 5.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the z direction is not used.
c          if kzr > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of kzr can be removed by increasing kez = iparm(13)
c          without changing nz = iparm(16)
c
c
c ... iex = iparm(11)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(14)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx = iparm(14).
c
c
c ... jey = iparm(12)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(15)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(9)
c          as small as possible within grid size constraints when
c          defining ny = iparm(15).
c
c
c ... kez = iparm(13)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the z direction (see nz = iparm(16)).
c          kez .le. 50 is required.  for efficient multigrid cycling,
c          kez should be chosen as large as possible and kzr=iparm(10)
c          as small as possible within grid size constraints when
c          defining nz = iparm(16).
c
c
c ... nx = iparm(14)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(8), iex = iparm(11).
c
c
c ... ny = iparm(15)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(9), jey = iparm(12).
c
c
c ... nz = iparm(16)
c
c          the number of equally spaced grid points in the interval [ze,zf]
c          (including the boundaries).  nz must have the form
c
c               nz = kzr*(2**(kez-1)) + 1
c
c          where kzr = iparm(10), kez = iparm(13)
c
c
c *** example
c
c         suppose a solution is wanted on a 33 by 65 by 97 grid.  then
c         ixp=2, jyq=4, kzr=6 and iex=jey=kez=5 could be used.  a better
c         choice would be ixp=jyq=2, kzr=3, and iex=5, jey=kez=6.
c
c *** note
c
c     let G be the nx by ny by nz fine grid on which the approximation is
c     generated and let n = max0(iex,jey,kez).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         G(1) < ... < G(k) < ... < G(n) = G.
c
c     each g(k) (k=1,...,n) has mx(k) by my(k) by mz(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c         mz(k) = kzr*[2**(max0(kez+k-n,1)-1)] + 1
c
c
c
c ... iguess=iparm(17)
c
c          = 0 if no initial guess to the pde is provided
c              and/or full multigrid cycling beginning at the
c              coarsest grid level is desired.
c
c          = 1 if an initial guess to the pde at the finest grid
c              level is provided in phi (see below).  in this case
c              cycling beginning or restarting at the finest grid
c              is initiated.
c
c *** comments on iguess = 0 or 1 . . .
c
c
c     setting iguess=0 forces full multigrid or "fmg" cycling.  phi
c     must be initialized at all grid points.  it can be set to zero at
c     non-Dirchlet grid points if nothing better is available.  the
c     values set in phi when iguess = 0 are passed and down and serve
c     as an initial guess to the pde at the coarsest grid level where
c     multigrid cycling commences.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c *** time dependent problems . . .
c
c     assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at non-Dirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(18)
c
c          the exact number of cycles executed between the finest
c          (nx by ny by nz) and the coarsest ((ixp+1) by (jyq+1) by
c          (kzr+1)) grid levels when tolmax=fparm(7)=0.0 (no error
c          control). when tolmax=fparm(7).gt.0.0 is input (error control)
c          then maxcy is a limit on the number of cycles between the
c          finest and coarsest grid levels.  in any case, at most
c          maxcy*(iprer+ipost) relaxation sweeps are performed at the
c          finest grid level (see iprer=mgopt(2),ipost=mgopt(3) below)
c          when multigrid iteration is working "correctly" only a few
c          cycles are required for convergence.  large values for maxcy
c          should not be required.
c
c
c ... method = iparm(19)
c
c          this sets the method of relaxation (all relaxation
c          schemes in mudpack use red/black type ordering)
c
c          = 0 for gauss-seidel pointwise relaxation
c
c          = 1 for line relaxation in the x direction
c
c          = 2 for line relaxation in the y direction
c
c          = 3 for line relaxation in the z direction
c
c          = 4 for line relaxation in the x and y direction
c
c          = 5 for line relaxation in the x and z direction
c
c          = 6 for line relaxation in the y and z direction
c
c          = 7 for line relaxation in the x,y and z direction
c
c          = 8 for x,y planar relaxation
c
c          = 9 for x,z planar relaxation
c
c          =10 for y,z planar relaxation
c
c ***  if nxa = 0 and nx = 3 at a grid level where line relaxation in the x
c      direction is flagged then it will be replaced by gauss-seidel point
c      relaxation at that grid level.
c
c ***  if nyc = 0 and ny = 3 at a grid level where line relaxation in the y
c      direction is flagged then it will be replaced by gauss-seidel point
c      relaxation at that grid level.
c
c ***  if nze = 0 and nz = 3 at a grid level where line relaxation in the z
c      direction is flagged then it will be replaced by gauss-seidel point
c      relaxation at that grid level.
c
c      these adjustments are necessary since the simultaneous tri-diagonal
c      solvers used with line periodic relaxation must have n > 2 where n
c      is number of unknowns (excluding the periodic point).

c ***  choice of method
c
c      this is very important for efficient convergence.  in some cases
c      experimentation may be required.
c
c      let fx represent the quantity cxx(x,y,z)/dlx**2 over the solution box
c
c      let fy represent the quantity cyy(x,y,z)/dly**2 over the solution box
c
c      let fz represent the quantity czz(x,y,z)/dlz**2 over the solution box
c
c      (0) if fx,fy,fz are roughly the same size and do not vary too
c          much choose method = 0.  if this fails try method = 7.
c
c      (1) if fx is much greater then fy,fz and fy,fz are roughly the same
c          size choose method = 1
c
c      (2) if fy is much greater then fx,fz and fx,fz are roughly the same
c          size choose method = 2
c
c      (3) if fz is much greater then fx,fy and fx,fy are roughly the same
c          size choose method = 3
c
c      (4) if fx,fy are roughly the same and both are much greater then fz
c          try method = 4.  if this fails try method = 8
c
c      (5) if fx,fz are roughly the same and both are much greater then fy
c          try method = 5.  if this fails try method = 9
c
c      (6) if fy,fz are roughly the same and both are much greater then fx
c          try method = 6.  if this fails try method = 10
c
c      (7) if fx,fy,fz vary considerably with none dominating try method = 7
c
c      (8) if fx and fy are considerably greater then fz but not necessarily
c          the same size (e.g., fx=1000.,fy=100.,fz=1.) try method = 8
c
c      (9) if fx and fz are considerably greater then fy but not necessarily
c          the same size (e.g., fx=10.,fy=1.,fz=1000.) try method = 9
c
c      (10)if fy and fz are considerably greater then fx but not necessarily
c          the same size (e.g., fx=1.,fy=100.,fz=10.) try method = 10
c
c
c ... meth2 = iparm(20) determines the method of relaxation used in the planes
c             when method = 8 or 9 or 10.
c
c
c          as above, let fx,fy,fz represent the quantities cxx/dlx**2,
c          cyy/dly**2,czz/dlz**2 over the box.
c
c          (if method = 8)
c
c          = 0 for gauss-seidel pointwise relaxation
c              in the x,y plane for each fixed z
c          = 1 for line relaxation in the x direction
c              in the x,y plane for each fixed z
c          = 2 for line relaxation in the y direction
c              in the x,y plane for each fixed z
c          = 3 for line relaxation in the x and y direction
c              in the x,y plane for each fixed z
c
c          (1) if fx,fy are roughly the same and vary little choose meth2 = 0
c          (2) if fx is much greater then fy choose meth2 = 1
c          (3) if fy is much greater then fx choose meth2 = 2
c          (4) if none of the above or meth2 = 0 fails choose meth2 = 3
c
c          (if method = 9)
c
c          = 0 for gauss-seidel pointwise relaxation with red/black ordering
c              in the x,z plane for each fixed y
c          = 1 for simultaneous line relaxation in the x direction
c              of the x,z plane for each fixed y
c          = 2 for simultaneous line relaxation in the z direction
c              of the x,z plane for each fixed y
c          = 3 for simultaneous line relaxation in the x and z direction
c              of the x,z plane for each fixed y
c
c          (1) if fx,fz are roughly the same and vary little choose meth2 = 0
c          (2) if fx is much greater then fz choose meth2 = 1
c          (3) if fz is much greater then fx choose meth2 = 2
c          (4) if none of the above or meth2 = 0 fails choose meth2 = 3
c
c          (if method = 10)
c
c          = 0 for gauss-seidel pointwise relaxation with red/black ordering
c              in the y,z plane for each fixed x
c          = 1 for simultaneous line relaxation in the y direction
c              of the y,z plane for each fixed x
c          = 2 for simultaneous line relaxation in the z direction
c              of the y,z plane for each fixed x
c          = 3 for simultaneous line relaxation in the y and z direction
c              of the y,z plane for each fixed x
c
c          (1) if fy,fz are roughly the same and vary little choose meth2 = 0
c          (2) if fy is much greater then fz choose meth2 = 1
c          (3) if fz is much greater then fy choose meth2 = 2
c          (4) if none of the above or meth2 = 0 fails choose meth2 = 3
c
c
c ... length = iparm(21)
c
c          the length of the work space provided in vector work.
c
c          let isx = 3 if method = 1,4,5 or 7 and nxa.ne.0
c          let isx = 5 if method = 1,4,5 or 7 and nxa.eq.0
c          let isx = 0 if method has any other value
c
c          let jsy = 3 if method = 2,4,6 or 7 and nyc.ne.0
c          let jsy = 5 if method = 2,4,6 or 7 and nyc.eq.0
c          let jsy = 0 if method has any other value
c
c          let ksz = 3 if method = 3,5,6 or 7 and nze.ne.0
c          let ksz = 5 if method = 3,5,6 or 7 and nze.eq.0
c          let ksz = 0 if method has any other value
c
c
c          then (for method .le.7)
c
c         (1)   length = (nx+2)*(ny+2)*(nz+2)*(10+isx+jsy+ksz)
c
c          or (for method.gt.7)
c
c         (2)   length = 14*(nx+2)*(ny+2)*(nz+2)
c
c          will usually but not always suffice.  The exact minimal length depends,
c          in a complex way, on the grid size arguments and method chosen.
c  ***     It can be predetermined for the current input arguments by calling
c          mud3 with length=iparm(21)=0 and printing iparm(22) or (in f90)
c          dynamically allocating the work space using the value in iparm(22)
c          in a subsequent mud3 call.
c
c ... fparm                                                                     
c
c          a floating point vector of length 8 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in mud3 and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... ze=fparm(5), zf=fparm(6)
c
c          the range of the z independent variable. ze must                     
c          be less than zf.                                                     
c
c
c ... tolmax = fparm(7)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j,k)
c          and phi2(i,j,k) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(abs(phi2(i,j,k)-phi1(i,j,k))) for all i,j,k
c
c          and
c
c              phmax = max(abs(phi2(i,j,k))) for all i,j,k
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(7)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible DO NOT use error control!).
c
c
c ... work                                                                      
c
c          a one dimensional array that must be provided for work space.        
c          see length = iparm(21). the values in work must be preserved
c          if mud3 is called again with intl=iparm(1).ne.0 or if mud34
c          is called to improve accuracy.
c
c
c ... bndyc                                                                     
c
c          a subroutine with arguments (kbdy,xory,yorz,alfa,gbdy).
c          which are used to input mixed boundary conditions to mud3.
c          the boundaries are numbered one thru six and the form of
c          conditions are described below.
c                                                                               
c
c     (1) the kbdy=1 boundary
c
c     this is the (y,z) plane x=xa where nxa=iparm(2) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dx + alfxa(y,z)*p(xa,y,z) = gbdxa(y,z)
c
c     in this case kbdy=1,xory=y,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfxa(y,z),gbdxa(y,z) must be returned.
c
c
c     (2) the kbdy=2 boundary
c
c     this is the (y,z) plane x=xb where nxb=iparm(3) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dx + alfxb(y,z)*p(xb,y,z) = gbdxb(y,z)
c
c     in this case kbdy=2,xory=y,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfxb(y,z),gbdxb(y,z) must be returned.
c
c
c     (3) the kbdy=3 boundary
c
c     this is the (x,z) plane y=yc where nyc=iparm(4) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dy + alfyc(x,z)*p(x,yc,z) = gbdyc(x,z)
c
c     in this case kbdy=3,xory=x,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfyc(x,z),gbdyc(x,z) must be returned.
c
c
c     (4) the kbdy=4 boundary
c
c     this is the (x,z) plane y=yd where nyd=iparm(5) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dy + alfyd(x,z)*p(x,yd,z) = gbdyd(x,z)
c
c     in this case kbdy=4,xory=x,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfyd(x,z),gbdyd(x,z) must be returned.
c
c                                                                               
c     (5) the kbdy=5 boundary
c
c     this is the (x,y) plane z=ze where nze=iparm(6) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dz + alfze(x,y)*p(x,y,ze) = gbdze(x,y)
c
c     in this case kbdy=5,xory=x,yorz=y will be input to bndyc and
c     alfa,gbdy corresponding to alfze(x,y),gbdze(x,y) must be returned.
c
c
c     (6) the kbdy=6 boundary
c
c     this is the (x,y) plane z=zf where nzf=iparm(7) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dz + alfzf(x,y)*p(x,y,zf) = gbdzf(x,y)
c
c     in this case kbdy=6,xory=x,yorz=y will be input to bndyc and
c     alfa,gbdy corresponding to alfzf(x,y),gbdzf(x,y) must be returned.
c
c                                                                               
c *** alfxa,alfyc,alfze nonpositive and alfxb,alfyd,alfze nonnegative
c     will help maintain matrix diagonal dominance during discretization
c     aiding convergence.
c
c *** bndyc must provide the mixed boundary condition
c     values in correspondence with those flagged in iparm(2)
c     thru iparm(7).  if all boundaries are specified then
c     mud3 will never call bndyc.  even then it must be entered
c     as a dummy subroutine. bndyc must be declared
c     external in the routine calling mud3.  the actual
c     name chosen may be different.
c
c
c ... coef
c
c         a subroutine with arguments (x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
c         which provides the known real coefficients for the elliptic pde
c         at any grid point (x,y,z).  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         external.
c
c ... rhs                                                                       
c
c          an array dimensioned nx by ny by nz which contains
c          the given right hand side values on the uniform 3-d mesh.            
c          rhs(i,j,k) = r(xi,yj,zk) for i=1,...,nx and j=1,...,ny               
c          and k=1,...,nz.
c
c ... phi                                                                       
c
c          an array dimensioned nx by ny by nz .  on input phi must
c          contain specified boundary values and an initial guess
c          to the solution if flagged (see iguess=iparm(17)=1).  for
c          example, if nyd=iparm(5)=1 then phi(i,ny,k) must be set
c          equal to p(xi,yd,zk) for i=1,...,nx and k=1,...,nz prior to
c          calling mud3.  the specified values are preserved by mud3.
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at non-Dirchlet grid points (this is not
c          checked). these values are projected down and serve as an initial
c          guess to the pde at the coarsest grid level.  set phi to 0.0 at
c          nonDirchlet grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid arguments (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the arguments
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---3-----3-----------3-----------------3---------------     level 1
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --6---6-------6---6-----------6---6-------6---6--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c ***********************************************************************
c ****output arguments**************************************************
c ***********************************************************************
c
c
c ... iparm(22)
c
c          on output iparm(22) contains the actual work space length
c          required for the current grid sizes and method.  This value
c          will be computed and returned even if iparm(21) is less then
c          iparm(22) (see ierror=9).
c
c
c ... iparm(23)
c
c          if error control is selected (tolmax = fparm(7) .gt. 0.0) then
c          on output iparm(23) contains the actual number of cycles executed
c          between the coarsest and finest grid levels in obtaining the
c          approximation in phi.  the quantity (iprer+ipost)*iparm(23) is
c          the number of relaxation sweeps performed at the finest grid level.
c
c
c ... fparm(8)                                                                  
c
c          on output fparm(8) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(8) is computed only if there is error control (tolmax.gt.0.)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c             phdif = max(abs(phi2(i,j,k)-phi1(i,j,k))) for all i,j,k
c
c          and
c
c             phmax = max(abs(phi2(i,j,k))) for all i,j,k
c
c          then
c
c             fparm(8) = phdif/phmax
c
c          is returned whenever phmax.gt.0.0.  in the degenerate case
c          phmax = 0.0, fparm(8) = phdif is returned.
c
c
c
c ... work
c
c          on output work contains intermediate values that must not be
c          destroyed if mud3 is to be called again with iparm(1)=1 or
c          if mud34 is to be called to improve the estimate to fourth
c          order.
c
c ... phi
c
c          on output phi(i,j,k) contains the approximation to
c          p(xi,yj,zk) for all mesh points i=1,...,nx; j=1,...,ny;
c          k=1,...,nz.  the last computed iterate in phi is returned
c          even if convergence is not obtained (ierror=-1)
c
c ... ierror
c
c          For intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  Argument checking and discretization
c          is bypassed for intl=1 calls which can only return
c          ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              abs(cx)*dlx > 2.*abs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              abs(cy)*dly > 2.*abs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c
c             cxx = amax1(cxx,0.5*abs(cx)*dx)
c
c                          (and)
c
c             cyy = amax1(cyy,0.5*abs(cy)*dy)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made to preserve convergence of multigrid iteration. if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-3  if the continuous elliptic pde is singular.  this means the
c          boundary conditions are periodic or pure derivative at all
c          boundaries and ce(x,y) = 0.0 for all x,y.  a solution is still
c          attempted but convergence may not occur due to ill-conditioning
c          of the linear system coming from the discretization.  the
c          ierror = -3 flag overrides the ierror=-4 and ierror=-5 nonfatal
c          flags.
c
c
c     =-2  if the pde is not elliptic (i.e., cxx*cyy.le.0.0 for some (xi,yj))
c          in this case a solution is still attempted although convergence
c          may not occur due to ill-conditioning of the linear system.
c          the ierror = -2 flag overrides the ierror=-5,-4,-3 nonfatal
c          flags.
c
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd,nze,nzf
c         in iparm(2) through iparm(7)is not 0,1 or 2 or if
c         (nxa,nxb) or (nyc,nyd) or (nze,nzf) are not pairwise zero.
c
c     = 3 if mino(ixp,jyq,kzr) < 2 (ixp=iparm(8),jyq=iparm(9),kzr=iparm(10))
c
c     = 4 if min0(iex,jey,kez) < 1 (iex=iparm(11),jey=iparm(12),kez=iparm(13))
c         or if max0(iex,jey,kez) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or if ny.ne.jyq*2**(jey-1)+1 or
c         if nz.ne.kzr*2**(kez-1)+1 (nx=iparm(14),ny=iparm(15),nz=iparm(16))
c
c     = 6 if iguess = iparm(17) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(18) < 1 (large values for maxcy should not be used)
c
c     = 8 if method = iparm(19) is less than 0 or greater than 10 or
c         if meth2 = iparm(20) is not 0 or 1 or 2 or 3 when method > 7.
c
c     = 9 if length = iparm(20) is too small (see iparm(21) on output
c         for minimum required work space length)
c
c     =10 if xa >= xb or yc >= yd or ze >= zf
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4),ze=fparm(5),zf=fparm(6))
c
c     =11 if tolmax = fparm(7) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(2) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c *********************************************************
c *********************************************************
c
c     end of mud3 documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="mud34.txt"><b>MUD34</b></a>
<PRE>
c
c     file mud34.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file mud34.d
c
c     contains documentation for subroutine mud34(work,phi,ierror)
c     A sample fortran driver is file "tmud34.f".
c
c ... required MUDPACK files
c
c     mud3.f, mudcom.f, mud3ln.f, mud3pn.f
c
c ... purpose
c
c     mud34 attempts to improve the estimate in phi, obtained by calling
c     mud3,  from second to fourth order accuracy.  see the file "mud3.d"
c     for a detailed discussion of the elliptic pde approximated and
c     arguments "work,phi" which are also part of the argument list for
c     mud3.
c
c ... assumptions
c
c     *  phi contains a second-order approximation from an earlier mud3 call
c
c     *  arguments "work,phi" are the same used in calling mud3
c
c     *  "work,phi" have not changed since the last call to mud3
c
c     *  the finest grid level contains at least 6 points in each direction
c
c
c *** warning
c
c     if the first assumption is not true then a fourth order approximation
c     cannot be produced in phi.  the last assumption (adequate grid size)
c     is the only one checked. failure in any of the others can result in
c     in an undetectable error.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections"
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... error argument
c
c     = 0 if no error is detected
c
c     = 30 if min0(nx,ny) < 6 where nx,ny are the fine grid sizes
c          in the x,y directions.
c                                                                               
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of mud34 documentation
c
c  ***********************************************************************
c  ***********************************************************************
c
</PRE>
<HR>
 
<a name="mud34sp.txt"><b>MUD34SP</b></a>
<PRE>
c
c     file mud34sp.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file mud34sp.d
c
c     contains documentation for subroutine mud34sp(work,phi,ierror)
c     A sample fortran driver is file "tmud34sp.f".
c
c ... required MUDPACK files
c
c     mud3sp.f, mudcom.f
c
c ... purpose
c
c     mud34sp attempts to improve the estimate in phi, obtained by calling
c     mud3sp,  from second to fourth order accuracy.  see the file "mud3sp.d"
c     for a detailed discussion of the elliptic pde approximated and
c     arguments "work,phi" which are also part of the argument list for
c     mud3sp.
c
c ... assumptions
c
c     *  phi contains a second-order approximation from an earlier mud3sp call
c
c     *  arguments "work,phi" are the same used in calling mud3sp
c
c     *  "work,phi" have not changed since the last call to mud3sp
c
c     *  the finest grid level contains at least 6 points in each direction
c
c
c *** warning
c
c     if the first assumption is not true then a fourth order approximation
c     cannot be produced in phi.  the last assumption (adequate grid size)
c     is the only one checked. failure in any of the others can result in
c     in an undetectable error.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections"
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... error argument
c
c     = 0 if no error is detected
c
c     = 30 if min0(nx,ny) < 6 where nx,ny are the fine grid sizes
c          in the x,y directions.
c                                                                               
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of mud34sp documentation
c
c  ***********************************************************************
c  ***********************************************************************
c
</PRE>
<HR>
 
<a name="mud3cr.txt"><b>MUD3CR</b></a>
<PRE>
c
c     file mud3cr.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file mud3cr.d
c
c     contains documentation for:
c     subroutine mud3cr(iparm,fparm,work,coef,bnd3cr,rhs,phi,mgopt,
c    +icros,crsxy,crsxz,crsyz,tol,maxit,iouter,rmax,ierror)
c     A sample fortran driver is file "tmud3cr.f".
c
c ... required MUDPACK files
c
c     mudcom.f
c
c
c ... purpose
c
c     subroutine mud3cr automatically discretizes and attempts to compute
c     the second order finite difference approximation to a three-
c     dimensional linear nonseparable elliptic partial differential
c     equation with cross derivative terms on a box.  the approximation
c     is generated on a uniform grid covering the box (see mesh description
c     below).  boundary conditions may be any combination of oblique mixed
c     derivative (see bnd3cr description below), specified (Dirchlet) or
c     periodic.  the form of the pde in operator notation is
c
c          l(p) + lxyz(p) = r(x,y,z)
c
c     where
c
c          l(p) = cxx(x,y,z)*pxx + cyy(x,y,z)*pyy + czz(z,y,z)*pzz +
c
c                 cx(x,y,z)*px + cy(x,y,z)*py + cz(x,y,z)*pz +
c
c                 ce(x,y,z)*p(x,y,z) = r(x,y,z)
c
c     and
c
c       lxyz(p) = cxy(x,y,z)*pxy + cxz(x,y,z)*pxz + cyz(x,y,z)*pyz
c
c     here cxx,cyy,czz,cx,cy,cz,ce,cxy,cxz,cyz  are the known real
c     coefficients of the pde; pxx,pyy,pzz,px,py,pz are the second and
c     first partial derivatives of the unknown solution function p(x,y,z)
c     with respect to the independent variables x,y,z; pxy,pxz, and pyz
c     are the second order mixed partial derivatives of p with respect
c     to xy,xz, and yz.  r(x,y,z) is the known right hand side of the pde.
c
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny by nz grid.
c     the grid is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd] x [ze,zf].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1), dlz = (zf-ze)/(nz-1)
c
c     be the uniform grid increments in the x,y,z  directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly, zk = ze+(k-1)*dlz
c
c     for i=1,...,nx; j=1,...,ny; k=1,...,nz  denote the x,y,z uniform
c     mesh points.
c
c
c
c ... methods
c
c
c     subroutine mud3cr is a recent addition to mudpack.  details
c     of the methods employeed by the other solvers in mudpack are in
c     [1,9,10].  [1,2,7,9,10] contain performance measurements on a variety
c     of elliptic pdes (see "references" in the file "readme").  the multi-
c     grid methods are described in documentation for the other solvers.
c *** mud3cr differs fundamentally from the other solvers in mudpack.
c     the full pde including cross derivative terms is discretized on
c     the INTERIOR of the solution region:
c
c       xa < x < xb, yc < y < yd, ze < z < zf
c
c     however, on nonspecified (nondirchlet) boundaries only l(p) is
c     discretized and the cross derivative term lxyz(p) is moved to the
c     right hand side of the pde and approximated by second order finite
c     finite difference formula applied to a previous estimate in p(k-1).
c     similarly, oblique mixed derivative boundary conditions (see bnd3cr)
c     are converted to a "mud3" type mixed normal form using second-order
c     finite difference formula applied to a previous estimate p(k-1) to
c     approximate non-normal derivative components.  for example if
c     the mixed derivative condition
c
c       py + a(x,z)*px + b(x,z)*pz + c(x,z)*p(x,yd,z) = gyd(y,z)
c
c     is specifed on the (x,z) plane of the upper y=yd boundary (see
c     bnd3cr for kbdy=4 below) then mud3cr converts this to the mixed
c     normal derivative form
c
c       py + c(x,z)*p(x,yd,z) = h(k,x,z)
c
c     where the modified right hand side h(k,x,z) is given by
c
c       h(k,x,z) = gyd(x,z) - [a(x,z)*dx(p(k-1)) + b(x,z)*dz(p(k-1)].
c
c     dx(p(k-1)) and dz(p(k-1)) are second order finite difference
c     approximations to the nonnormal partial derivatives px,pz using the
c     previous estimate in p(k-1).
c
c     the result of full discretization on interior grid points and partial
c     discretization with right hand side modifications on boundaries,
c     is a linear system which we denote by
c
c       D(p(k)) = r - Dxyz(p(k-1)).
c
c     D is the coefficient matrix coming from the discretization and
c     Dxyz(p(k-1)) stands for the right hand side modification obtained
c     by approximating boundary cross derivative terms and/or nonnormal
c     derivative components from mixed derivative boundary conditions
c     with second order finite difference formula applied to p(k-1).
c     with this notation, we formally describe the outer iteration employeed
c     by mud3cr:
c
c     algorithm mud3cr
c     .
c     set k = 0
c     .
c     set p(0) = 0.0 for all nonspecified grid points
c     .
c     repeat
c
c     .. k = k+1
c
c     .. solve D(p(k)) = r - Dxyz(p(k-1)) using multigrid iteration
c
c     .. set rmax(k) = ||p(k) - p(k-1)|| / ||p(k)||
c
c     until (rmax(k) < tol or k = maxit)
c     .
c     end mud3cr
c
c     tol is an error tolerance for convergence and maxit is a limit on
c     the number of outer iterations.  both are user prescribed input
c     arguments to mud3cr.  the maximum vector norm || || is used in
c     computing the relative difference between successive estimates in
c     rmax(k).  large values for maxit should not be used.
c
c *** note
c
c     originally a code, mud3cr0, was designed by moving all cross terms
c     to the right hand side and solving
c
c        l(p(k)) = r - lxyz(p(k-1)) for k=1,...
c
c     over the entire solution region including the interior.  in this
c     relatively straightforward approach, the standard mudpack solver
c     mud3 is used iteratively at each step.  however, convergence with
c     mud3cro is slow and unreliable.  an attempt was then made to
c     discretize the complete pde including cross terms and boundary
c     conditions over the entire region like the other solvers in mudpack.`
c     undoubtedly, this would have the most efficient and robust convergence
c     properties.  the main difficulty with this approach is the
c     unmanageable code complexity required to discretize all possible
c     combinations of nonzero cross derivative terms and oblique derivative
c     conditions.  for example, in the presence of nonzero cross terms,
c     cornors which are at the intersections of oblique derivative boundary
c     conditions become too complex (for this person) to discretize.
c     detection of combinations of oblique derivative conditions at cornors
c     which are singular (i.e., for which discretization leads to division
c     by 0.0) is a logical nightmare.
c
c     the present mud3cr is a middle ground between these two approaches.
c     it is an attempt to include as much of the pde cross terms as possible
c     in the discretization while bypassing the code complexity required to
c     include all possible boundary situations in the discretization.
c
c     by including the (manageable) discretization of cross terms on the
c     interior, the unfavorable convergence properties of the first approach
c     are (hopefully) avoided and the favorable convergence properties
c     of the second approach are (hopefully) obtained.  by moving nonzero
c     boundary cross terms and nonnormal components of mixed derivative
c     boundary conditions to the right hand side, the problems of too much
c     code complexity with discretization in the second approach are bypassed.
c
c     extensive numerical testing indicates for most problems mud3cr is more
c     robust than mud3cro.  convergence is more "iffy" and computationally
c     expensive than with the other solvers in mudpack.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with Fortran77
c     and Fortran90 on a variety of platforms.
c                                                                               
c
c ... references (partial list)
c
c     for a complete list see "references" in the mudpack information and
c     directory file "readme"
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c **********************************************************************
c *** arguments ********************************************************
c **********************************************************************
c
c     arguments iparm,fparm,work,rhs,phi,coef,mgopt are the same as
c     those input to mud3 (see mud3.d for a detailed description) with the
c     following provisions:
c
c     (1) the minimum required work space length for mud3cr is increased
c         by approximately
c
c              nx*ny*nz*(1+8*(icros(1)+icros(2)+icros(3))/7 +
c
c              2*(icros(1)+icros(2)+icros(3))*(nx*ny+nx*nz+ny*nz)
c
c         words over the minimum work space required by mud3 (see icros
c         description below).  the exact minimal work space required
c         by mud3cr for the current set of input arguments is output
c         in iparm(22). * The exact minimal work length required
c         for the current method and grid size arguments can be
c         predetermined by calling mud3cr with iparm(21)=0 and
c         printout of iparm(22) or (in fortran 90 codes) dynamically
c         allocating work using the the value in iparm(22) in subsequent
c         calls to mud3cr.
c
c     (2) at least two calls to mud3cr are necessary to generate an
c         approximation. intl=iparm(1)=0 is required on the first
c         call.  this call will do "once only" discretization, and
c         set intermediate values in work which must be preserved
c         for noninitial calls.
c
c     (3) maxcy = iparm(18) must be 1 or 2 (see ierror = 13).
c
c     (4) tolmax = fparm(5) = 0.0 is required.  no "internal" error control
c         is allowed within multigrid cycling (see mud3.d)
c
c     (5) mgopt(1) = 0 is required.  only the default multigrid
c         options (W(2,1) cycles with cubic prolongation) can be used
c         with mud3cr
c
c *** new arguments
c
c      the arguments: bnd3cr,icros,crsxy,crsxz,crsyz,tol,maxit,iouter,rmax
c      are all new to mud3cr.  the error argument, ierror, has been expanded.
c      these are all described below:
c
c
c ... bnd3cr(kbdy,xory,yorz,a,b,c,g)
c
c      a subroutine with input arguments kbdy,xory,yorz and output
c      arguments a,b,c,g.  bnd3cr inputs OBLIQUE mixed derivative
c      conditions at any of the six x,y,z boundaries to mud3cr as
c      described below:
c
c         (1) the kbdy=1 boundary
c
c         this is the (y,z) plane x=xa where nxa=iparm(2)=2 flags
c         an oblique mixed boundary condition of the form
c
c           px + axa(y,z)*py + bxa(y,z)*pz +cxa(y,z)*p(xa,y,z) = gxa(y,z)
c
c         in this case kbdy=1,xory=y,yorz=z will be input to bnd3cr and
c         a,b,c,g corresponding to the known coefficients axa(y,z),bxa(y,z),
c         cxa(y,z),gxa(y,z) must be returned
c
c
c         (2) the kbdy=2 boundary
c
c         this is the (y,z) plane x=xb where nxb=iparm(3)=2 flags
c         an oblique mixed boundary condition of the form
c
c           px + axb(y,z)*py + bxb(y,z)*pz +cxb(y,z)*p(xb,y,z) = gxb(y,z)
c
c         in this case kbdy=2,xory=y,yorz=z will be input to bnd3cr and
c         a,b,c,g corresponding to the known coefficients axb(y,z),bxb(y,z),
c         cxb(y,z),gxb(y,z) must be returned
c
c         (3) the kbdy=3 boundary
c
c         this is the (x,z) plane y=yc where nyc=iparm(4)=2 flags
c         an oblique mixed boundary condition of the form
c
c           py + ayc(x,z)*px + byc(x,z)*pz +cyc(x,z)*p(x,yc,z) = gyc(x,z)
c
c         in this case kbdy=3,xory=x,yorz=z will be input to bnd3cr and
c         a,b,c,g corresponding to the known coefficients ayc(x,z),byc(x,z),
c         cyc(x,z),gyc(x,z) must be returned
c
c
c         (4) the kbdy=4 boundary
c
c         this is the (x,z) plane y=yd where nyd=iparm(5)=2 flags
c         an oblique mixed boundary condition of the form
c
c           py + ayd(x,z)*px  + byd(x,z)*pz +cyd(x,z)*p(x,yd,z) = gyd(x,z)
c
c         in this case kbdy=4,xory=x,yorz=z will be input to bnd3cr and
c         a,b,c,g corresponding to the known coefficients ayd(x,z),byd(x,z),
c         cyd(x,z),gyd(x,z) must be returned
c
c         (5) the kbdy=5 boundary
c
c         this is the (x,y) plane z=ze where nze=iparm(6)=2 flags
c         an oblique mixed boundary condition of the form
c
c           pz + aze(x,y)*px + bze(x,y)*py + cze(x,y)*p(x,y,ze) = gze(x,y)
c
c         in this case kbdy=5,xory=x,yorz=y will be input to bnd3cr and
c         a,b,c,g corresponding to the known coefficients aze(x,y),bze(x,y),
c         cze(x,y),gze(x,y) must be returned
c
c         (6) the kbdy=6 boundary
c
c         this is the (x,y) plane z=zf where nzf=iparm(7)=2 flags
c         an oblique mixed boundary condition of the form
c
c           pz + azf(x,y)*px + bzf(x,y)*py + czf(x,y)*p(x,y,zf) = gzf(x,y)
c
c         in this case kbdy=6,xory=x,yorz=y will be input to bnd3cr and
c         a,b,c,g corresponding to the known coefficients azf(x,y),bzf(x,y),
c         czf(x,y),gzf(x,y) must be returned
c
c
c     bnd3cr must be delcared "external" in the routine calling mud3cr
c     where its name may be different.  bnd3cr must be entered as a
c     dummy subroutine even if there are no derivative boundary conditions.
c     for an example of how to set up a subroutine to input derivative
c     boundary conditions, see the test program tmud3cr.f
c
c ... icros
c
c     an integer vector argument dimensioned 3 which flags the presence
c     or absence of cross derivative terms in the pde as follows:
c
c       icros(1) = 1 if cxy(x,y,z) is nonzero for any grid point (x,y,z)
c       icros(1) = 0 if cxy(x,y,z) = 0.0 for all grid points (x,y,z)
c
c       icros(2) = 1 if cxz(x,y,z) is nonzero for any grid point (x,y,z)
c       icros(2) = 0 if cxz(x,y,z) = 0.0 for all grid points (x,y,z)
c
c       icros(3) = 1 if cyz(x,y,z) is nonzero for any grid point (x,y,z)
c       icros(3) = 0 if cyz(x,y,z) = 0.0 for all grid points (x,y,z)
c
c
c ... crsxy(x,y,z,cxy)
c
c     if icros(1) = 1 then crsxy is a subroutine with arguments
c     (x,y,z,cxy) which supplies the xy cross derivative coefficient
c     cxy at the grid point (x,y,z).  if icros(1) = 0 then crsxy
c     is a dummy subroutine argument (i.e., it must be provided but
c     will not be invoked).
c
c
c ... crsxz(x,y,z,cxz)
c
c     if icros(2) = 1 then crsxz is a subroutine with arguments
c     (x,y,z,cxz) which supplies the xz cross derivative coefficient
c     cxz at the grid point (x,y,z).  if icros(2) = 0 then crsxz
c     is a dummy subroutine argument (i.e., it must be provided but
c     will not be invoked).
c
c
c ... crsyz(x,y,z,cyz)
c
c     if icros(3) = 1 then crsyz is a subroutine with arguments
c     (x,y,z,cyz) which supplies the yz cross derivative coefficient
c     cxy at the grid point (x,y,z).  if icros(3) = 0 then crsyz
c     is a dummy subroutine argument (i.e., it must be provided but
c     will not be invoked).
c
c     crsxy,crsxz,crsyz must be declared "external" in the routine
c     calling mud3cr.  the names chosen for these routines can be
c     different (see tmud3cr.f for an example)
c
c ... tol
c
c     tol is an error control argument for the outer iteration employed
c     by mud3cr (see "methods" description above).  if tol > 0.0 is input
c     then tol is a relative error tolerance for convergence.  the outer
c     iteration terminates and convergence is deemed to have occurred at the
c     k(th) iterate if the maximum relative difference, rmax(k), satisfies
c
c                  def
c           rmax(k) = ||p(k) - p(k-1)||/ ||p(k)|| < tol.
c
c     the last approximation p(maxit) is returned in phi even if
c     convergence does not occurr.  the maximum norm || || is used.
c     when tol = 0.0 is input, error control is not implemented and
c     exactly maxit (see below) outer iterations are executed in mud3cr.
c     the tol = 0.0 option eliminates unnecessary computation when
c     the user is certain of the required value for maxit.
c
c
c ... maxit
c
c     a limit on the outer iteration loop (see "method" description)
c     used to approximate the 3-d pde with cross derivative terms when
c     tol > 0.0.  if tol = 0.0 is entered then exactly maxit outer
c     iterations are performed and only rmax(maxit) is computed.  the
c     total number of relaxation sweeps performed at the finest grid
c     level is bounded by 3*maxcy*maxit.  large values for maxit should
c     not be used.
c
c
c ***********************************************************************
c ****output arguments**************************************************
c ***********************************************************************
c
c
c ... iparm(22)
c
c          on output iparm(22) contains the actual work space length
c          required by mud3cr for the current grid sizes and method.
c          this will be approximately

c              nx*ny*nz*(1+8*(icros(1)+icros(2)+icros(3))/7 +
c
c              2*(icros(1)+icros(2)+icros(3))*(nx*ny+nx*nz+ny*nz)
c
c          words longer than the space required by mud3 (see mud3.d)
c
c
c ... work
c
c          on output work contains intermediate values that must not be
c          destroyed if mud3cr is to be called again with iparm(1)=1
c          and iparm(17)=1.
c
c
c ... phi
c
c          on output phi(i,j,k) contains the approximation to
c          p(xi,yj,zk) for all mesh points i=1,...,nx; j=1,...,ny;
c          k=1,...,nz.  the last computed iterate in phi is returned
c          even if convergence is not obtained.
c
c
c ... iouter
c
c          the number of outer iterations (see "method" description above)
c          executed by mud3cr for the current call. maxit is an upper bound
c          for iouter
c
c
c ... rmax (see tol,maxit descriptions above)
c
c          a maxit dimensioned real vector.  if tol > 0.0 is input then
c          rmax(k) for k=1,...,iouter contain the maximum relative
c          difference between successive estimates.  rmax(k) is
c          given by
c
c               rmax(k) = ||p(k) - p(k-1)||/ ||p(k)||
c
c          for k=1,...,iouter.  the maximum norm || || is used.  either
c          iouter < maxit (convergence) or iouter = maxit is possible.
c          if tol = 0.0 input then exactly maxit outer iterations are
c          executed and only rmax(maxit) is computed.  in this case
c          rmax(1),...,rmax(maxit-1) are set to 0.0.  the tol = 0.0
c          option eliminates unnecessary computation when the user is
c          certain of the required value for maxit.
c
c
c ... ierror
c
c          an integer error argument which indicates fatal errors when
c          returned positive.  the negative values -5,-4,-3,-2,-1  and
c          ierror = 2,3,4,5,6,9,10 have the same meaning as described for
c          for mud3 (see mud3.d).  in addition:
c
c ***      new nonfatal error
c
c          ierror = -10 if tol > 0.0 is input (error control) and convergence
c          fails in maxit outer iterations.  in this case the latest
c          approximation p(maxit) is returned in phi (mud3cr can be recalled
c          with iparm(1)=iparm(17)=1 to improve the approximation as long
c          as all other arguments are unchanged)
c
c ***      new fatal errors
c
c ... ierror
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls of if intl=0 and iguess=iparm(17)=1
c
c     = 7 if maxcy = iparm(18) is not 1 or 2
c
c     = 8 if method = iparm(19) is less than 0 or greater than 7
c         mud3cr does not allow planar relaxation.  meth2=iparm(20)
c         is not used or checked.
c
c     =11 if tolmax = fparm(7) is not 0.0
c
c     =12 if kcycle = mgopt(1) is not 0
c
c     =13 if icros(1) or icros(2) or icros(3) is not 0 or 1
c
c     =14 if tol < 0.0
c
c     =15 if maxit < 1
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of mud3cr documentation
c
c  ***********************************************************************
c  ***********************************************************************
c

</PRE>
<HR>
 
<a name="mud3sa.txt"><b>MUD3SA</b></a>
<PRE>
c
c     file mud3sa.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file mud3sa.d
c
c     contains documentation for:
c     subroutine mud3sa(iparm,fparm,work,sgx,sgy,sgz,xlmbda,bndyc,rhs,phi,
c     +                 mgopt,ierror)
c     A sample fortran driver is file "tmud3sa.f".
c
c ... required MUDPACK files
c
c     mudcom.f, mud3ln.f, mud3pn.f
c
c ... purpose
c
c     subroutine mud3sa automatically discretizes and attempts to compute
c     the second order conservative finite difference approximation
c     to a three dimensional linear nonseparable "self adjoint" elliptic
c     partial differential equation on a rectangle.  the approximation
c     is generated on a uniform grid covering the rectangle.  boundary
c     conditions may be specified (Dirichlet), periodic, or mixed.
c     the form of the pde solved is:
c
c         d(sgx(x,y,z)*dp/dx)/dx + d(sgy(x,y,z)*dp/dy)/dy +
c
c         d(sgz(x,y,z)*dp/dz)/dz - xlmbda(x,y,z)*p(x,y,z) = r(x,y,z)
c
c     where sgx(x,y,z),sgy(x,y,z),sgz(x,y,z) (all positive), xlmbda(x,y,z)
c     (nonnegative), r(x,y,z) (the given right hand side) and p(x,y,z) (the
c     unknown solution function) are all real valued functions of the real
c     independent variables x,y,z. the use of the variable names "x,y,z"
c     does not imply the cartesian coordinate system underlies the pde.
c     for example, any pde in divergence form in cartesian coordinates can
c     be put in a self-adjoint form suitable for mud3sa after a curvilinear
c     coordinate transform (see tmud3sa.f)
c                                                                               
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny by nz grid.
c     the grid is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd] x [ze,zf].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1), dlz = (zf-ze)/(nz-1)
c
c     be the uniform grid increments in the x,y,z  directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly, zk = ze+(k-1)*dlz
c
c     for i=1,...,nx; j=1,...,ny; k=1,...,nz  denote the x,y,z uniform
c     mesh points.
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with Fortran77
c     and Fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 23 used to efficiently pass
c          integer parameters.  iparm is set internally in mud3sa
c          and defined as follows . . .                                         
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      An approximation is NOT generated after an intl=0 call!
c          mud3sa should be called with intl=1 to approximate the elliptic
c          PDE discretized by the intl=0 call.  intl=1 should also
c          be input if mud3sa has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  This will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  Some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) mud3sa is being recalled for additional accuracy.  In
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) mud3sa is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) mud3sa is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to mud3sa

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by coef (see below) have
c              changed since the previous call
c
c          (e) any of the "alfa" coefficients input by bndyc (see below)
c              have changed since the previous call.
c
c          If any of (a) through (e) are true then the elliptic PDE
c          must be discretized or rediscretized.  If none of (a)
c          through (e) holds, calls can be made with intl=1.
c          Incorrect calls with intl=1 will produce erroneous results.
c  ***     The values set in the saved work space "work" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the (y,z) plane x=xa                    
c
c        = 0 if p(x,y,z) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y,z) = p(x,y,z) for all x,y,z)
c
c        = 1 if p(xa,y,z) is specified  (this must be input thru phi(1,j,k))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see "bndyc" description below where kbdy = 1)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the (y,z) plane x=xb                    
c
c        = 0 if p(x,y,z) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y,z) = p(x,y,z) for all x,y,z)
c
c        = 1 if p(xb,y,z) is specified (this must be input thru phi(nx,j,k))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see "bndyc" description below where kbdy = 2)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the (x,z) plane y=yc                    
c
c        = 0 if p(x,y,z) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc,z) = p(x,y,z) for all x,y,z)

c        = 1 if p(x,yc,z) is specified (this must be input thru phi(i,1,k))

c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see "bndyc" description below where kbdy = 3)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the (x,z) plane y=yd                    
c
c        = 0 if p(x,y,z) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc,z) = p(x,y,z) for all x,y,z)

c        = 1 if p(x,yd,z) is specified (this must be input thru phi(i,ny,k))

c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see "bndyc" description below where kbdy = 4)
c
c
c ... nze=iparm(6)
c
c          flags boundary conditions on the (x,y) plane z=ze                    
c
c        = 0 if p(x,y,z) is periodic in z on [ze,zf]
c            (i.e., p(x,y,z+zf-ze) = p(x,y,z) for all x,y,z

c        = 1 if p(x,y,ze) is specified (this must be input thru phi(i,j,1))

c        = 2 if there are mixed derivative boundary conditions at z=ze
c            (see "bndyc" description below where kbdy = 5)
c
c
c ... nzf=iparm(7)
c
c          flags boundary conditions on the (x,y) plane z=zf                    
c
c        = 0 if p(x,y,z) is periodic in z on [ze,zf]
c            (i.e., p(x,y,z+zf-ze) = p(x,y,z) for all x,y,z

c        = 1 if p(x,y,zf) is specified (this must be input thru phi(i,j,nz))

c        = 2 if there are mixed derivative boundary conditions at z=zf
c            (see "bndyc" description below where kbdy = 6)
c
c
c *** grid size parameters
c
c
c ... ixp = iparm(8)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(14)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible.
c          recommended values are the small primes 2 or 3 or (possibly) 5.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the x direction is not used.
c          if ixp > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of ixp can be removed by increasing iex = iparm(11)
c          without changing nx = iparm(14)
c
c
c ... jyq = iparm(9)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(15)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible.
c          recommended values are the small primes 2 or 3 or (possibly) 5.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the y direction is not used.
c          if jyq > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of jyq can be removed by increasing jey = iparm(12)
c          without changing ny = iparm(15)
c
c
c ... kzr = iparm(10)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the z direction (see nz = iparm(16)).  "kzr+1"
c          is the number of points on the coarsest z grid visited during
c          multigrid cycling.  kzr should be chosen as small as possible.
c          recommended values are the small primes 2 or 3 or (possibly) 5.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the z direction is not used.
c          if kzr > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of kzr can be removed by increasing kez = iparm(13)
c          without changing nz = iparm(16)
c
c
c ... iex = iparm(11)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(14)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx = iparm(14).
c
c
c ... jey = iparm(12)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(15)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(9)
c          as small as possible within grid size constraints when
c          defining ny = iparm(15).
c
c
c ... kez = iparm(13)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the z direction (see nz = iparm(16)).
c          kez .le. 50 is required.  for efficient multigrid cycling,
c          kez should be chosen as large as possible and kzr=iparm(10)
c          as small as possible within grid size constraints when
c          defining nz = iparm(16).
c
c
c ... nx = iparm(14)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(8), iex = iparm(11).
c
c
c ... ny = iparm(15)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(9), jey = iparm(12).
c
c
c ... nz = iparm(16)
c
c          the number of equally spaced grid points in the interval [ze,zf]
c          (including the boundaries).  nz must have the form
c
c               nz = kzr*(2**(kez-1)) + 1
c
c          where kzr = iparm(10), kez = iparm(13)
c
c
c *** example
c
c         suppose a solution is wanted on a 33 by 65 by 97 grid.  then
c         ixp=2, jyq=4, kzr=6 and iex=jey=kez=5 could be used.  a better
c         choice would be ixp=jyq=2, kzr=3, and iex=5, jey=kez=6.
c
c *** note
c
c     let G be the nx by ny by nz fine grid on which the approximation is
c     generated and let n = max0(iex,jey,kez).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         G(1) < ... < G(k) < ... < G(n) = G.
c
c     each g(k) (k=1,...,n) has mx(k) by my(k) by mz(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c         mz(k) = kzr*[2**(max0(kez+k-n,1)-1)] + 1
c
c
c
c ... iguess=iparm(17)
c
c          = 0 if no initial guess to the pde is provided
c              and/or full multigrid cycling beginning at the
c              coarsest grid level is desired.
c
c          = 1 if an initial guess to the pde at the finest grid
c              level is provided in phi (see below).  in this case
c              cycling beginning or restarting at the finest grid
c              is initiated.
c
c *** comments on iguess = 0 or 1 . . .
c
c
c     setting iguess=0 forces full multigrid or "fmg" cycling.  phi
c     must be initialized at all grid points.  it can be set to zero at
c     non-Dirchlet grid points if nothing better is available.  the
c     values set in phi when iguess = 0 are passed and down and serve
c     as an initial guess to the pde at the coarsest grid level where
c     multigrid cycling commences.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c *** time dependent problems . . .
c
c     assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at non-Dirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(18)
c
c          the exact number of cycles executed between the finest
c          (nx by ny by nz) and the coarsest ((ixp+1) by (jyq+1) by
c          (kzr+1)) grid levels when tolmax=fparm(7)=0.0 (no error
c          control). when tolmax=fparm(7).gt.0.0 is input (error control)
c          then maxcy is a limit on the number of cycles between the
c          finest and coarsest grid levels.  in any case, at most
c          maxcy*(iprer+ipost) relaxation sweeps are performed at the
c          finest grid level (see iprer=mgopt(2),ipost=mgopt(3) below)
c          when multigrid iteration is working "correctly" only a few
c          cycles are required for convergence.  large values for maxcy
c          should not be required.
c
c
c ... method = iparm(19)
c
c          this sets the method of relaxation (all relaxation
c          schemes in mudpack use red/black type ordering)
c
c          = 0 for gauss-seidel pointwise relaxation
c
c          = 1 for line relaxation in the x direction
c
c          = 2 for line relaxation in the y direction
c
c          = 3 for line relaxation in the z direction
c
c          = 4 for line relaxation in the x and y direction
c
c          = 5 for line relaxation in the x and z direction
c
c          = 6 for line relaxation in the y and z direction
c
c          = 7 for line relaxation in the x,y and z direction
c
c          = 8 for x,y planar relaxation
c
c          = 9 for x,z planar relaxation
c
c          =10 for y,z planar relaxation
c
c ***  if nxa = 0 and nx = 3 at a grid level where line relaxation in the x
c      direction is flagged then it will be replaced by gauss-seidel point
c      relaxation at that grid level.
c
c ***  if nyc = 0 and ny = 3 at a grid level where line relaxation in the y
c      direction is flagged then it will be replaced by gauss-seidel point
c      relaxation at that grid level.
c
c ***  if nze = 0 and nz = 3 at a grid level where line relaxation in the z
c      direction is flagged then it will be replaced by gauss-seidel point
c      relaxation at that grid level.
c
c      these adjustments are necessary since the simultaneous tri-diagonal
c      solvers used with line periodic relaxation must have n > 2 where n
c      is number of unknowns (excluding the periodic point).

c ***  choice of method
c
c      this is very important for efficient convergence.  in some cases
c      experimentation may be required.
c
c      let fx represent the quantity sgx(x,y,z)/dlx**2 over the solution box
c
c      let fy represent the quantity sgy(x,y,z)/dly**2 over the solution box
c
c      let fz represent the quantity sgz(x,y,z)/dlz**2 over the solution box
c
c      (0) if fx,fy,fz are roughly the same size and do not vary too
c          much choose method = 0.  if this fails try method = 7.
c
c      (1) if fx is much greater then fy,fz and fy,fz are roughly the same
c          size choose method = 1
c
c      (2) if fy is much greater then fx,fz and fx,fz are roughly the same
c          size choose method = 2
c
c      (3) if fz is much greater then fx,fy and fx,fy are roughly the same
c          size choose method = 3
c
c      (4) if fx,fy are roughly the same and both are much greater then fz
c          try method = 4.  if this fails try method = 8
c
c      (5) if fx,fz are roughly the same and both are much greater then fy
c          try method = 5.  if this fails try method = 9
c
c      (6) if fy,fz are roughly the same and both are much greater then fx
c          try method = 6.  if this fails try method = 10
c
c      (7) if fx,fy,fz vary considerably with none dominating try method = 7
c
c      (8) if fx and fy are considerably greater then fz but not necessarily
c          the same size (e.g., fx=1000.,fy=100.,fz=1.) try method = 8
c
c      (9) if fx and fz are considerably greater then fy but not necessarily
c          the same size (e.g., fx=10.,fy=1.,fz=1000.) try method = 9
c
c      (10)if fy and fz are considerably greater then fx but not necessarily
c          the same size (e.g., fx=1.,fy=100.,fz=10.) try method = 10
c
c
c ... meth2 = iparm(20) determines the method of relaxation used in the planes
c             when method = 8 or 9 or 10.
c
c
c          (if method = 8)
c
c          = 0 for gauss-seidel pointwise relaxation
c              in the x,y plane for each fixed z
c          = 1 for line relaxation in the x direction
c              in the x,y plane for each fixed z
c          = 2 for line relaxation in the y direction
c              in the x,y plane for each fixed z
c          = 3 for line relaxation in the x and y direction
c              in the x,y plane for each fixed z
c
c          (1) if fx,fy are roughly the same and vary little choose meth2 = 0
c          (2) if fx is much greater then fy choose meth2 = 1
c          (3) if fy is much greater then fx choose meth2 = 2
c          (4) if none of the above or meth2 = 0 fails choose meth2 = 3
c
c          (if method = 9)
c
c          = 0 for gauss-seidel pointwise relaxation with red/black ordering
c              in the x,z plane for each fixed y
c          = 1 for simultaneous line relaxation in the x direction
c              of the x,z plane for each fixed y
c          = 2 for simultaneous line relaxation in the z direction
c              of the x,z plane for each fixed y
c          = 3 for simultaneous line relaxation in the x and z direction
c              of the x,z plane for each fixed y
c
c          (1) if fx,fz are roughly the same and vary little choose meth2 = 0
c          (2) if fx is much greater then fz choose meth2 = 1
c          (3) if fz is much greater then fx choose meth2 = 2
c          (4) if none of the above or meth2 = 0 fails choose meth2 = 3
c
c          (if method = 10)
c
c          = 0 for gauss-seidel pointwise relaxation with red/black ordering
c              in the y,z plane for each fixed x
c          = 1 for simultaneous line relaxation in the y direction
c              of the y,z plane for each fixed x
c          = 2 for simultaneous line relaxation in the z direction
c              of the y,z plane for each fixed x
c          = 3 for simultaneous line relaxation in the y and z direction
c              of the y,z plane for each fixed x
c
c          (1) if fy,fz are roughly the same and vary little choose meth2 = 0
c          (2) if fy is much greater then fz choose meth2 = 1
c          (3) if fz is much greater then fy choose meth2 = 2
c          (4) if none of the above or meth2 = 0 fails choose meth2 = 3
c
c
c ... length = iparm(21)
c
c          the length of the work space provided in vector work.
c
c          let isx = 3 if method = 1,4,5 or 7 and nxa.ne.0
c          let isx = 5 if method = 1,4,5 or 7 and nxa.eq.0
c          let isx = 0 if method has any other value
c
c          let jsy = 3 if method = 2,4,6 or 7 and nyc.ne.0
c          let jsy = 5 if method = 2,4,6 or 7 and nyc.eq.0
c          let jsy = 0 if method has any other value
c
c          let ksz = 3 if method = 3,5,6 or 7 and nze.ne.0
c          let ksz = 5 if method = 3,5,6 or 7 and nze.eq.0
c          let ksz = 0 if method has any other value
c
c
c          then (for method .le.7)
c
c         (1)   length = (nx+2)*(ny+2)*(nz+2)*(10+isx+jsy+ksz)
c
c          or (for method.gt.7)
c
c         (2)   length = 14*(nx+2)*(ny+2)*(nz+2)
c
c          will usually but not always suffice.  The exact minimal length depends,
c          in a complex way, on the grid size arguments and method chosen.
c  ***     It can be predetermined for the current input arguments by calling
c          mud3sa with length=iparm(21)=0 and printing iparm(22) or (in f90)
c          dynamically allocating the work space using the value in iparm(22)
c          in a subsequent mud3sa call.
c
c
c ... fparm                                                                     
c
c          a floating point vector of length 8 used to efficiently
c          pass floating point parameters.  fparm is set internally
c          in mud3sa and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... ze=fparm(5), zf=fparm(6)
c
c          the range of the z independent variable. ze must                     
c          be less than zf.                                                     
c
c
c ... tolmax = fparm(7)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j,k)
c          and phi2(i,j,k) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(abs(phi2(i,j,k)-phi1(i,j,k))) for all i,j,k
c
c          and
c
c              phmax = max(abs(phi2(i,j,k))) for all i,j,k
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(7)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible DO NOT use error control!).
c
c
c ... work                                                                      
c
c          a one dimensional array that must be provided for work space.        
c          see length = iparm(21). the values in work must be preserved
c          if mud3sa is called again with intl=iparm(1).ne.0
c
c
c ... bndyc                                                                     
c
c          a subroutine with  parameters (kbdy,xory,yorz,alfa,gbdy).
c          which are used to input mixed boundary conditions to mud3sa.
c          the boundaries are numbered one thru six and the form of
c          conditions are described below.
c                                                                               
c
c     (1) the kbdy=1 boundary
c
c     this is the (y,z) plane x=xa where nxa=iparm(2) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dx + alfxa(y,z)*p(xa,y,z) = gbdxa(y,z)
c
c     in this case kbdy=1,xory=y,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfxa(y,z),gbdxa(y,z) must be returned.
c
c
c     (2) the kbdy=2 boundary
c
c     this is the (y,z) plane x=xb where nxb=iparm(3) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dx + alfxb(y,z)*p(xb,y,z) = gbdxb(y,z)
c
c     in this case kbdy=2,xory=y,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfxb(y,z),gbdxb(y,z) must be returned.
c
c
c     (3) the kbdy=3 boundary
c
c     this is the (x,z) plane y=yc where nyc=iparm(4) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dy + alfyc(x,z)*p(x,yc,z) = gbdyc(x,z)
c
c     in this case kbdy=3,xory=x,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfyc(x,z),gbdyc(x,z) must be returned.
c
c
c     (4) the kbdy=4 boundary
c
c     this is the (x,z) plane y=yd where nyd=iparm(5) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dy + alfyd(x,z)*p(x,yd,z) = gbdyd(x,z)
c
c     in this case kbdy=4,xory=x,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfyd(x,z),gbdyd(x,z) must be returned.
c
c                                                                               
c     (5) the kbdy=5 boundary
c
c     this is the (x,y) plane z=ze where nze=iparm(6) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dz + alfze(x,y)*p(x,y,ze) = gbdze(x,y)
c
c     in this case kbdy=5,xory=x,yorz=y will be input to bndyc and
c     alfa,gbdy corresponding to alfze(x,y),gbdze(x,y) must be returned.
c
c
c     (6) the kbdy=6 boundary
c
c     this is the (x,y) plane z=zf where nzf=iparm(7) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dz + alfzf(x,y)*p(x,y,zf) = gbdzf(x,y)
c
c     in this case kbdy=6,xory=x,yorz=y will be input to bndyc and
c     alfa,gbdy corresponding to alfzf(x,y),gbdzf(x,y) must be returned.
c
c                                                                               
c *** alfxa,alfyc,alfze nonpositive and alfxb,alfyd,alfze nonnegative
c     will help maintain matrix diagonal dominance during discretization
c     aiding convergence.
c
c *** bndyc must provide the mixed boundary condition
c     values in correspondence with those flagged in iparm(2)
c     thru iparm(7).  if all boundaries are specified then
c     mud3sa will never call bndyc.  even then it must be entered
c     as a dummy subroutine. bndyc must be declared
c     external in the routine calling mud3sa.  the actual
c     name chosen may be different.
c
c
c ... sgx,sgy,sgz
c
c         function subroutines which returns the real value of the
c         coefficients at any point (x,y,z).  they must be constructed
c         to return values outside the solution region.  let dx=(xb-xa)/ixp,
c         dy = (yd-yc)/jyq, dz=(zf-ze)/kzr  (coarse grid increments).
c         then sgx,sgy,sgz will be invoked for x,y,z in the intervals
c
c           [xa-0.5*dx,xa], [xb,xb+0.5*dx]
c           [yc-0.5*dy,yc], [yd,yd+0.5*dy]
c           [ze-0.5*dz,ze], [zf,zf+0.5*dz].
c
c         this is necessitated by conservative finite differencing. values
c         outside specified (Dirichlet) boundaries will not be used in
c         the final discretization (e.g., if nxa = 1 then sgx will be
c         invoked for x.lt.xa but these values will not used).  on the other-
c         hand such values are required outside mixed derivative boundaries.
c         sgx,sgy,sgz should be positive for all (x,y,z) (see ierror = -5). they
c         must be declared "external" in the user constructed program calling
c         mud3sa where their names may be different.
c
c ... xlmbda
c
c         a real valued function subroutine which returns the value of
c         "xlmbda" in the pde at any grid point (xi,yj,zk).  xlmbda should
c         be nonnegative for any (xi,yj,zk) (see ierror = -4). xlmbda must be
c         declared "external" in the user constructed program calling
c         mud3sa where its name may be different.
c
c
c ... rhs                                                                       
c
c          an array dimensioned nx by ny by nz which contains
c          the given right hand side values on the uniform 3-d mesh.            
c          rhs(i,j,k) = r(xi,yj,zk) for i=1,...,nx and j=1,...,ny               
c          and k=1,...,nz.
c
c ... phi                                                                       
c
c          an array dimensioned nx by ny by nz .  on input phi must
c          contain specified boundary values and an initial guess
c          to the solution if flagged (see iguess=iparm(17)=1).  for
c          example, if nyd=iparm(5)=1 then phi(i,ny,k) must be set
c          equal to p(xi,yd,zk) for i=1,...,nx and k=1,...,nz prior to
c          calling mud3sa.  the specified values are preserved by mud3sa.
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at non-Dirchlet grid points (this is not
c          checked). these values are projected down and serve as an initial
c          guess to the pde at the coarsest grid level.  set phi to 0.0 at
c          nonDirchlet grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid parameters (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the parameters
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---3-----3-----------3-----------------3---------------     level 1
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --6---6-------6---6-----------6---6-------6---6--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c ***********************************************************************
c ****output parameters**************************************************
c ***********************************************************************
c
c
c ... iparm(22)
c
c          on output iparm(22) contains the actual work space length
c          required for the current grid sizes and method.
c
c
c ... iparm(23)
c
c          if error control is selected (tolmax = fparm(7) .gt. 0.0) then
c          on output iparm(23) contains the actual number of cycles executed
c          between the coarsest and finest grid levels in obtaining the
c          approximation in phi.  the quantity (iprer+ipost)*iparm(23) is
c          the number of relaxation sweeps performed at the finest grid level.
c
c
c ... fparm(8)                                                                  
c
c          on output fparm(8) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(8) is computed only if there is error control (tolmax.gt.0.)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c             phdif = max(abs(phi2(i,j,k)-phi1(i,j,k))) for all i,j,k
c
c          and
c
c             phmax = max(abs(phi2(i,j,k))) for all i,j,k
c
c          then
c
c             fparm(8) = phdif/phmax
c
c          is returned whenever phmax.gt.0.0.  in the degenerate case
c          phmax = 0.0, fparm(8) = phdif is returned.
c
c
c
c ... work
c
c          on output work contains intermediate values that must not be
c          destroyed if mud3sa is to be called again with intl = iparm(1)=1
c
c ... phi
c
c          on output phi(i,j,k) contains the approximation to
c          p(xi,yj,zk) for all mesh points i=1,...,nx; j=1,...,ny;
c          k=1,...,nz.  the last computed iterate in phi is returned
c          even if convergence is not obtained (ierror=-1)
c
c ... ierror
c
c          For intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  Argument checking and discretization
c          is bypassed for intl=1 calls which can only return
c          ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              abs(cx)*dlx > 2.*abs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              abs(cy)*dly > 2.*abs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c
c             cxx = amax1(cxx,0.5*abs(cx)*dx)
c
c                          (and)
c
c             cyy = amax1(cyy,0.5*abs(cy)*dy)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made to preserve convergence of multigrid iteration. if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-3  if the continuous elliptic pde is singular.  this means the
c          boundary conditions are periodic or pure derivative at all
c          boundaries and ce(x,y) = 0.0 for all x,y.  a solution is still
c          attempted but convergence may not occur due to ill-conditioning
c          of the linear system coming from the discretization.  the
c          ierror = -3 flag overrides the ierror=-4 and ierror=-5 nonfatal
c          flags.
c
c
c     =-2  if the pde is not elliptic (i.e., cxx*cyy.le.0.0 for some (xi,yj))
c          in this case a solution is still attempted although convergence
c          may not occur due to ill-conditioning of the linear system.
c          the ierror = -2 flag overrides the ierror=-5,-4,-3 nonfatal
c          flags.
c
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd,nze,nzf
c         in iparm(2) through iparm(7)is not 0,1 or 2 or if
c         (nxa,nxb) or (nyc,nyd) or (nze,nzf) are not pairwise zero.
c
c     = 3 if mino(ixp,jyq,kzr) < 2 (ixp=iparm(8),jyq=iparm(9),kzr=iparm(10))
c
c     = 4 if min0(iex,jey,kez) < 1 (iex=iparm(11),jey=iparm(12),kez=iparm(13))
c         or if max0(iex,jey,kez) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or if ny.ne.jyq*2**(jey-1)+1 or
c         if nz.ne.kzr*2**(kez-1)+1 (nx=iparm(14),ny=iparm(15),nz=iparm(16))
c
c     = 6 if iguess = iparm(17) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(18) < 1 (large values for maxcy should not be used)
c
c     = 8 if method = iparm(19) is less than 0 or greater than 10 or
c         if meth2 = iparm(20) is not 0 or 1 or 2 or 3 when method > 7.
c
c     = 9 if length = iparm(20) is too small (see iparm(21) on output
c         for minimum required work space length)
c
c     =10 if xa >= xb or yc >= yd or ze >= zf
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4),ze=fparm(5),zf=fparm(6))
c
c     =11 if tolmax = fparm(7) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(2) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c *********************************************************
c *********************************************************
c
c     end of mud3sa documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="mud3sp.txt"><b>MUD3SP</b></a>
<PRE>
c
c     file mud3sp.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file mud3sp.d
c
c     contains documentation for:
c     subroutine mud3sp(iparm,fparm,work,cofx,cofy,cofz,bndyc,rhs,phi,
c    +                   mgopt,ierror)
c     A sample fortran driver is file "tmud3sp.f".
c
c ... required MUDPACK files
c
c     mudcom.f
c
c ... purpose
c
c     subroutine mud3sp automatically discretizes and attempts to compute
c     the second order finite difference approximation to a three-
c     dimensional linear SEPARABLE elliptic partial differential
c     equation on a box.  the approximation is generated on a uniform
c     grid covering the box (see mesh description below).  boundary
c     conditions may be any combination of mixed, specified (Dirchlet)
c     or periodic.  the form of the pde solved is . . .
c
c       cxx(x)*pxx + cx(x)*px + cex(x)*p(x,y,z) +
c
c       cyy(y)*pyy + cy(y)*py + cey(y)*p(x,y,z) +
c
c       czz(z)*pzz + cz(z)*pz + cez(z)*p(x,y,z) = r(x,y,z)
c
c     here cxx,cx,cex,cyy,cy,cey,czz,cz,cez are the known real coefficients
c     of the pde; pxx,pyy,pzz,px,py,pz are the second and first
c     partial derivatives of the unknown solution function p(x,y,z)
c     with respect to the independent variables x,y,z; r(x,y,z) is
c     is the known real right hand side of the elliptic pde.  cxx,cyy
c     and czz should be positive for all (x,y,z) in the solution region.
c                                                                               
c     SEPARABILITY means:
c
c       cxx,cx,cex depend only on x
c       cyy,cy,cey depend only on y
c       czz,cz,cez depend only on z
c
c     For example, LaPlace's equation in Cartesian coordinates is separable.
c     Nonseparable elliptic PDEs can be approximated with muh3 or mud3.
c     mud3sp requires considerably less work space then muh3 or mud3.
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny by nz grid.
c     the grid is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd] x [ze,zf].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1), dlz = (zf-ze)/(nz-1)
c
c     be the uniform grid increments in the x,y,z  directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly, zk = ze+(k-1)*dlz
c
c     for i=1,...,nx; j=1,...,ny; k=1,...,nz  denote the x,y,z uniform
c     mesh points.
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with Fortran77
c     and Fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 22 used to efficiently pass
c          integer arguments.  iparm is set internally in mud3sp
c          and defined as follows . . .                                         
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      An approximation is NOT generated after an intl=0 call!
c          mud3sp should be called with intl=1 to approximate the elliptic
c          PDE discretized by the intl=0 call.  intl=1 should also
c          be input if mud3sp has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  This will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  Some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) mud3sp is being recalled for additional accuracy.  In
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) mud3sp is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) mud3sp is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to mud3sp

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by coef (see below) have
c              changed since the previous call
c
c          (e) any of the "alfa" coefficients input by bndyc (see below)
c              have changed since the previous call.
c
c          If any of (a) through (e) are true then the elliptic PDE
c          must be discretized or rediscretized.  If none of (a)
c          through (e) holds, calls can be made with intl=1.
c          Incorrect calls with intl=1 will produce erroneous results.
c  ***     The values set in the saved work space "work" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the (y,z) plane x=xa                    
c
c        = 0 if p(x,y,z) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y,z) = p(x,y,z) for all x,y,z)
c
c        = 1 if p(xa,y,z) is specified  (this must be input thru phi(1,j,k))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see "bndyc" description below where kbdy = 1)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the (y,z) plane x=xb                    
c
c        = 0 if p(x,y,z) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y,z) = p(x,y,z) for all x,y,z)
c
c        = 1 if p(xb,y,z) is specified (this must be input thru phi(nx,j,k))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see "bndyc" description below where kbdy = 2)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the (x,z) plane y=yc                    
c
c        = 0 if p(x,y,z) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc,z) = p(x,y,z) for all x,y,z)

c        = 1 if p(x,yc,z) is specified (this must be input thru phi(i,1,k))

c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see "bndyc" description below where kbdy = 3)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the (x,z) plane y=yd                    
c
c        = 0 if p(x,y,z) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc,z) = p(x,y,z) for all x,y,z)

c        = 1 if p(x,yd,z) is specified (this must be input thru phi(i,ny,k))

c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see "bndyc" description below where kbdy = 4)
c
c
c ... nze=iparm(6)
c
c          flags boundary conditions on the (x,y) plane z=ze                    
c
c        = 0 if p(x,y,z) is periodic in z on [ze,zf]
c            (i.e., p(x,y,z+zf-ze) = p(x,y,z) for all x,y,z

c        = 1 if p(x,y,ze) is specified (this must be input thru phi(i,j,1))

c        = 2 if there are mixed derivative boundary conditions at z=ze
c            (see "bndyc" description below where kbdy = 5)
c
c
c ... nzf=iparm(7)
c
c          flags boundary conditions on the (x,y) plane z=zf                    
c
c        = 0 if p(x,y,z) is periodic in z on [ze,zf]
c            (i.e., p(x,y,z+zf-ze) = p(x,y,z) for all x,y,z

c        = 1 if p(x,y,zf) is specified (this must be input thru phi(i,j,nz))

c        = 2 if there are mixed derivative boundary conditions at z=zf
c            (see "bndyc" description below where kbdy = 6)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(8)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(14)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible.
c          recommended values are the small primes 2 or 3 or (possibly) 5.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the x direction is not used.
c          if ixp > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of ixp can be removed by increasing iex = iparm(11)
c          without changing nx = iparm(14)
c
c
c ... jyq = iparm(9)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(15)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible.
c          recommended values are the small primes 2 or 3 or (possibly) 5.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the y direction is not used.
c          if jyq > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of jyq can be removed by increasing jey = iparm(12)
c          without changing ny = iparm(15)
c
c
c ... kzr = iparm(10)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the z direction (see nz = iparm(16)).  "kzr+1"
c          is the number of points on the coarsest z grid visited during
c          multigrid cycling.  kzr should be chosen as small as possible.
c          recommended values are the small primes 2 or 3 or (possibly) 5.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the z direction is not used.
c          if kzr > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of kzr can be removed by increasing kez = iparm(13)
c          without changing nz = iparm(16)
c
c
c ... iex = iparm(11)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(14)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx = iparm(14).
c
c
c ... jey = iparm(12)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(15)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(9)
c          as small as possible within grid size constraints when
c          defining ny = iparm(15).
c
c
c ... kez = iparm(13)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the z direction (see nz = iparm(16)).
c          kez .le. 50 is required.  for efficient multigrid cycling,
c          kez should be chosen as large as possible and kzr=iparm(10)
c          as small as possible within grid size constraints when
c          defining nz = iparm(16).
c
c
c ... nx = iparm(14)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(8), iex = iparm(11).
c
c
c ... ny = iparm(15)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(9), jey = iparm(12).
c
c
c ... nz = iparm(16)
c
c          the number of equally spaced grid points in the interval [ze,zf]
c          (including the boundaries).  nz must have the form
c
c               nz = kzr*(2**(kez-1)) + 1
c
c          where kzr = iparm(10), kez = iparm(13)
c
c
c *** example
c
c         suppose a solution is wanted on a 33 by 65 by 97 grid.  then
c         ixp=2, jyq=4, kzr=6 and iex=jey=kez=5 could be used.  a better
c         choice would be ixp=jyq=2, kzr=3, and iex=5, jey=kez=6.
c
c *** note
c
c     let G be the nx by ny by nz fine grid on which the approximation is
c     generated and let n = max0(iex,jey,kez).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         G(1) < ... < G(k) < ... < G(n) = G.
c
c     each g(k) (k=1,...,n) has mx(k) by my(k) by mz(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c         mz(k) = kzr*[2**(max0(kez+k-n,1)-1)] + 1
c
c
c
c ... iguess=iparm(17)
c
c          = 0 if no initial guess to the pde is provided
c              and/or full multigrid cycling beginning at the
c              coarsest grid level is desired.
c
c          = 1 if an initial guess to the pde at the finest grid
c              level is provided in phi (see below).  in this case
c              cycling beginning or restarting at the finest grid
c              is initiated.
c
c *** comments on iguess = 0 or 1 . . .
c
c
c     setting iguess=0 forces full multigrid or "fmg" cycling.  phi
c     must be initialized at all grid points.  it can be set to zero at
c     non-Dirchlet grid points if nothing better is available.  the
c     values set in phi when iguess = 0 are passed and down and serve
c     as an initial guess to the pde at the coarsest grid level where
c     multigrid cycling commences.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c *** time dependent problems . . .
c
c     assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at non-Dirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(18)
c
c          the exact number of cycles executed between the finest
c          (nx by ny by nz) and the coarsest ((ixp+1) by (jyq+1) by
c          (kzr+1)) grid levels when tolmax=fparm(7)=0.0 (no error
c          control). when tolmax=fparm(7).gt.0.0 is input (error control)
c          then maxcy is a limit on the number of cycles between the
c          finest and coarsest grid levels.  in any case, at most
c          maxcy*(iprer+ipost) relaxation sweeps are performed at the
c          finest grid level (see iprer=mgopt(2),ipost=mgopt(3) below)
c          when multigrid iteration is working "correctly" only a few
c          cycles are required for convergence.  large values for maxcy
c          should not be required.
c
c
c ... method = iparm(19)
c
c
c          = 0 for gauss-seidel pointwise relaxation with red/black ordering
C
C           This is the only relaxation method offered with mud3sp.  Line
C           or planar relaxation would "lose" the significant savings in
C           work space length defeating the purpose of mud3sp.  If line
C           or planar relaxation is required then use muh3 or mud3.
C           method is used as an argument only to focus attention on the
C           purpose of mud3sp.
C
c ... length = iparm(20)
c
c          the length of the work space provided in vector work.
c          This is considerably less then the work space required by
c          the nonseparable solvers muh3 or mud3.
c
c            length = 7*(nx+2)*(ny+2)*(nz+2)/2
c
c          will usually but not always suffice.  The exact minimal length
c          depends on the grid size arguments.  It can be predetermined
c  ***     for the current input arguments by calling mud3sp with iparm(20)
c          set equal to zero and printing iparm(21) or (in f90) dynamically
c          allocating the work space using the value in iparm(21) in a
c          subsequent mud3sp call.
c
c ... fparm                                                                     
c
c          a floating point vector of length 8 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in mud3sp and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... ze=fparm(5), zf=fparm(6)
c
c          the range of the z independent variable. ze must                     
c          be less than zf.                                                     
c
c
c ... tolmax = fparm(7)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j,k)
c          and phi2(i,j,k) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(abs(phi2(i,j,k)-phi1(i,j,k))) for all i,j,k
c
c          and
c
c              phmax = max(abs(phi2(i,j,k))) for all i,j,k
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(7)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible DO NOT use error control!).
c
c
c ... work                                                                      
c
c          a one dimensional array that must be provided for work space.        
c          see length = iparm(20). the values in work must be preserved
c          if mud3sp is called again with intl=iparm(1).ne.0 or if mud34sp
c          is called to improve accuracy.
c
c
c ... bndyc                                                                     
c
c          a subroutine with arguments (kbdy,xory,yorz,alfa,gbdy).
c          which are used to input mixed boundary conditions to mud3sp.
c          the boundaries are numbered one thru six and the form of
c          conditions are described below.
c                                                                               
c
c     (1) the kbdy=1 boundary
c
c     this is the (y,z) plane x=xa where nxa=iparm(2) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dx + alfxa*p(xa,y,z) = gbdxa(y,z)
c
c     in this case kbdy=1,xory=y,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfxa,gbdxa(y,z) must be returned.
c
c
c     (2) the kbdy=2 boundary
c
c     this is the (y,z) plane x=xb where nxb=iparm(3) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dx + alfxb*p(xb,y,z) = gbdxb(y,z)
c
c     in this case kbdy=2,xory=y,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfxb,gbdxb(y,z) must be returned.
c
c
c     (3) the kbdy=3 boundary
c
c     this is the (x,z) plane y=yc where nyc=iparm(4) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dy + alfyc*p(x,yc,z) = gbdyc(x,z)
c
c     in this case kbdy=3,xory=x,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfyc,gbdyc(x,z) must be returned.
c
c
c     (4) the kbdy=4 boundary
c
c     this is the (x,z) plane y=yd where nyd=iparm(5) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dy + alfyd*p(x,yd,z) = gbdyd(x,z)
c
c     in this case kbdy=4,xory=x,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfyd,gbdyd(x,z) must be returned.
c
c                                                                               
c     (5) the kbdy=5 boundary
c
c     this is the (x,y) plane z=ze where nze=iparm(6) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dz + alfze*p(x,y,ze) = gbdze(x,y)
c
c     in this case kbdy=5,xory=x,yorz=y will be input to bndyc and
c     alfa,gbdy corresponding to alfze,gbdze(x,y) must be returned.
c
c
c     (6) the kbdy=6 boundary
c
c     this is the (x,y) plane z=zf where nzf=iparm(7) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dz + alfzf*p(x,y,zf) = gbdzf(x,y)
c
c     in this case kbdy=6,xory=x,yorz=y will be input to bndyc and
c     alfa,gbdy corresponding to alfzf,gbdzf(x,y) must be returned.
c
c                                                                               
c *** The constants alfxa,alfyc,alfze nonpositive and alfxb,alfyd,alfze
c     nonnegative will help maintain matrix diagonal dominance during
c     discretization aiding convergence.
c
c *** bndyc must provide the mixed boundary condition
c     values in correspondence with those flagged in iparm(2)
c     thru iparm(7).  if all boundaries are specified then
c     mud3sp will never call bndyc.  even then it must be entered
c     as a dummy subroutine. bndyc must be declared
c     external in the routine calling mud3sp.  the actual
c     name chosen may be different.
c
c
c ... cofx
c
c         a subroutine with arguments (x,cxx,cx,cex) which provides the
c         known real coefficients of the x derivative terms for the pde
c         at any grid point x.  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         external.
c
c ... cofy
c
c         a subroutine with arguments (y,cyy,cy,cey) which provides the
c         known real coefficients of the y derivative terms for the pde
c         at any grid point y.  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         external.
c
c ... cofz
c
c         a subroutine with arguments (z,czz,cz,cez) which provides the
c         known real coefficients of the z derivative terms for the pde
c         at any grid point z.  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         external.
c
c ... rhs                                                                       
c
c          an array dimensioned nx by ny by nz which contains
c          the given right hand side values on the uniform 3-d mesh.            
c          rhs(i,j,k) = r(xi,yj,zk) for i=1,...,nx and j=1,...,ny               
c          and k=1,...,nz.
c
c ... phi                                                                       
c
c          an array dimensioned nx by ny by nz .  on input phi must
c          contain specified boundary values and an initial guess
c          to the solution if flagged (see iguess=iparm(17)=1).  for
c          example, if nyd=iparm(5)=1 then phi(i,ny,k) must be set
c          equal to p(xi,yd,zk) for i=1,...,nx and k=1,...,nz prior to
c          calling mud3sp.  the specified values are preserved by mud3sp.
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at non-Dirchlet grid points (this is not
c          checked). these values are projected down and serve as an initial
c          guess to the pde at the coarsest grid level.  set phi to 0.0 at
c          nonDirchlet grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid arguments (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the arguments
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---3-----3-----------3-----------------3---------------     level 1
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --6---6-------6---6-----------6---6-------6---6--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c ***********************************************************************
c ****output arguments**************************************************
c ***********************************************************************
c
c
c ... iparm(21)
c
c          on output iparm(21) contains the actual work space length
c          required for the current grid sizes and method.  This value
c          will be computed and returned even if iparm(20) is less then
c          iparm(21) (see ierror=9).
c
c
c ... iparm(22)
c
c          if error control is selected (tolmax = fparm(7) .gt. 0.0) then
c          on output iparm(22) contains the actual number of cycles executed
c          between the coarsest and finest grid levels in obtaining the
c          approximation in phi.  the quantity (iprer+ipost)*iparm(22) is
c          the number of relaxation sweeps performed at the finest grid level.
c
c
c ... fparm(8)                                                                  
c
c          on output fparm(8) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(8) is computed only if there is error control (tolmax.gt.0.)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c             phdif = max(abs(phi2(i,j,k)-phi1(i,j,k))) for all i,j,k
c
c          and
c
c             phmax = max(abs(phi2(i,j,k))) for all i,j,k
c
c          then
c
c             fparm(8) = phdif/phmax
c
c          is returned whenever phmax.gt.0.0.  in the degenerate case
c          phmax = 0.0, fparm(8) = phdif is returned.
c
c
c
c ... work
c
c          on output work contains intermediate values that must not be
c          destroyed if mud3sp is to be called again with iparm(1)=1 or
c          if mud34sp is to be called to improve the estimate to fourth
c          order.
c
c ... phi
c
c          on output phi(i,j,k) contains the approximation to
c          p(xi,yj,zk) for all mesh points i=1,...,nx; j=1,...,ny;
c          k=1,...,nz.  the last computed iterate in phi is returned
c          even if convergence is not obtained (ierror=-1)
c
c ... ierror
c
c          For intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  Argument checking and discretization
c          is bypassed for intl=1 calls which can only return
c          ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              abs(cx)*dlx > 2.*abs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              abs(cy)*dly > 2.*abs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c
c             cxx = amax1(cxx,0.5*abs(cx)*dx)
c
c                          (and)
c
c             cyy = amax1(cyy,0.5*abs(cy)*dy)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made to preserve convergence of multigrid iteration. if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-3  if the continuous elliptic pde is singular.  this means the
c          boundary conditions are periodic or pure derivative at all
c          boundaries and ce(x,y) = 0.0 for all x,y.  a solution is still
c          attempted but convergence may not occur due to ill-conditioning
c          of the linear system coming from the discretization.  the
c          ierror = -3 flag overrides the ierror=-4 and ierror=-5 nonfatal
c          flags.
c
c
c     =-2  if the pde is not elliptic (i.e., cxx*cyy.le.0.0 for some (xi,yj))
c          in this case a solution is still attempted although convergence
c          may not occur due to ill-conditioning of the linear system.
c          the ierror = -2 flag overrides the ierror=-5,-4,-3 nonfatal
c          flags.
c
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd,nze,nzf
c         in iparm(2) through iparm(7)is not 0,1 or 2 or if
c         (nxa,nxb) or (nyc,nyd) or (nze,nzf) are not pairwise zero.
c
c     = 3 if mino(ixp,jyq,kzr) < 2 (ixp=iparm(8),jyq=iparm(9),kzr=iparm(10))
c
c     = 4 if min0(iex,jey,kez) < 1 (iex=iparm(11),jey=iparm(12),kez=iparm(13))
c         or if max0(iex,jey,kez) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or if ny.ne.jyq*2**(jey-1)+1 or
c         if nz.ne.kzr*2**(kez-1)+1 (nx=iparm(14),ny=iparm(15),nz=iparm(16))
c
c     = 6 if iguess = iparm(17) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(18) < 1 (large values for maxcy should not be used)
c
c     = 8 if method = iparm(19) is not equat to zero
c
c     = 9 if length = iparm(20) is too small (see iparm(21) on output
c         for minimum required work space length)
c
c     =10 if xa >= xb or yc >= yd or ze >= zf
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4),ze=fparm(5),zf=fparm(6))
c
c     =11 if tolmax = fparm(7) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(2) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c *********************************************************
c *********************************************************
c
c     end of mud3sp documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="muh2.txt"><b>MUH2</b></a>
<PRE>
c
c     file muh2.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file muh2.d
c
c     contains documentation for:
c     subroutine muh2(iparm,fparm,wk,iwk,coef,bndyc,rhs,phi,mgopt,ierror)
c     a sample fortran driver is file "tmuh2.f".
c
c ... required mudpack files
c
c     mudcom.f, muhcom.f
c
c ... purpose
c
c     the "hybrid" multigrid/direct method code muh2 approximates the
c     same 2-d nonseparable elliptic pde as the mudpack solver mud2.
c     muh2 combines the efficiency of multigrid iteration with the certainty
c     a direct method.  the basic algorithm is modified by using banded
c     gaussian elimination in place of relaxation whenever the coarsest
c     subgrid is encountered within multigrid cycling.  this provides
c     additional grid size flexibility by eliminating the usual multigrid
c     constraint that the coarsest grid consist of "few" points for effective
c     error reduction with multigrid cycling.  In many cases the hybrid method
c     provides more robust convergence characteristics than multigrid cycling
c     alone.
c
c     The form of the pde solved is:
c
c
c          cxx(x,y)*pxx + cyy(x,y)*pyy + cx(x,y)*px + cy(x,y)*py +
c
c          ce(x,y)*p(x,y) = r(x,y).
c
c
c     pxx,pyy,px,py are second and first partial derivatives of the
c     unknown real solution function p(x,y) with respect to the
c     independent variables x,y.  cxx,cyy,cx,cy,ce are the known
c     real coefficients of the elliptic pde and r(x,y) is the known
c     real right hand side of the equation.  cxx and cyy should be
c     positive for all x,y in the solution region.  nonseparability
c     means some of the coefficients depend on both x and y.  if
c     the pde is separable subroutine mud2sp should be used instead
c     of mud2 or muh2.
c
c *** muh2 becomes a full direct method if grid size arguments are chosen
c     so that the coarsest and finest grids coincide.  choosing iex=jey=1
c     and ixp=nx-1, jyq=ny-1 (iex=iparm(6),jey=iparm(7),ixp=iparm(8),
c     jyq=iparm(9),nx=iparm(10),ny=iparm(11)) will set gaussian elimination
c     on the nx by ny grid.  in this case, muh2 produces a direct solution
c     to the same nonseparable elliptic pde as the direct solver liptic [5,6].
c     muh2 is more general than liptic since it allows periodic boundary
c     conditions in the y direction.
c
c
c ... argument differences with mud2.f
c
c     the input and output arguments of muh2 are almost identical to the
c     arguments of mud2 (see mud2.d) with the following exceptions:
c
c     (1) the work space vector "wk" requires
c
c              (ixp+1)*(jyq+1)*(2*ixp+3)
c
c         additional words of storage (ixp = iparm(6), jyq = iparm(7))
c         if periodic boundary conditions are not flagged in the y direction
c         (nyc .ne. 0 where nyc = iparm(4)) or
c
c              (ixp+1)*[2*(ixp+1)*(2*jyq-1)+jyq+1]
c
c         additional words of storage if periodic boundary conditions are
c         flagged in the y direction (nyc = 0).  the extra work space is
c         used for a direct solution with gaussian elimination whenever the
c         coarsest grid is encountered within multigrid cycling.
c
c     (2) An integer work space iwk of length at least (ixp+1)*(jyq+1)
c         must be provided.
c
c     (3) jyq must be greater than 2 if periodic boundary conditions
c         are flagged in the y direction and ixp must be greater than
c         2 if periodic boundary conditions are flagged in the x direction.
c         inputting jyq = 2 when nyc = 0 or inputting ixp = 2 when nxa = 0
c         will set the fatal error flag ierror=3
c
c *** (4) it is no longer necessary that ixp and jyq be "small" for
c         effective error reduction with multigrid iteration.  there
c         is no reduction in convergence rates when larger values for
c         ixp or jyq are used .  this provides additional flexibility
c         in choosing grid size.  in many cases muh2 provides more
c         robust convergence than mud2.  it can be used in place of
c         mud2 for all nonsingular problems (see (5) below).
c
c     (5) iguess = iparm(11) = 1 (flagging an initial guess) or
c         maxcy = iparm(14) > 1 (setting more than one multigrid
c         cycle) are not allowed if muh2 becomes a full direct method
c         by choosing iex = jey = 1 (iex = iparm(8),jey = iparm(9)).
c         this conflicting combination of input arguments for multigrid
c         iteration and a full direct method set the fatal error flag
c
c              ierror = 13
c
c         iguess = 0 and maxcy = 1 are required when muh2 becomes a
c         full direct method.
c
c     (6) if a "singular" pde is detected (see ierror=-3 description in mud2.d;
c         ce(x,y) = 0.0 for all x,y and the boundary conditions are a combination
c         of periodic and/or pure derivatives) then muh2 sets the fatal error
c         flag
c
c              ierror = 14
c
c         The direct method utilized by muh2 would likely cause a division
c         by zero in the singular case.  mud2 can be tried for singular problems
c
c
c ... grid size considerations
c
c     (1) flexibility
c
c         muh2 should be used in place of mud2 whenever grid size
c         requirements do not allow choosing ixp and jyq to be "small"
c         positive integers (typically less than 4).
c
c         example:
c
c         suppose we wish to solve an elliptic pde on a one degree grid on
c         the full surface of a sphere.  choosing ixp = jyq = 45 and iex = 4
c         and jyq = 3 fits the required 361 by 181 grid exactly.  multigrid
c         cycling will be used on the sequence of subgrid sizes:
c
c           46 x 46  <  91 x 46  <  181 x 91  <  361 x 181
c
c         the 46 x 46 coarsest subgrid has too much resolution for effective
c         error reduction with relaxation only.  muh2 circumvents this
c         difficulty by generating an exact direct solution (modulo roundoff
c         error) whenever the coarsest grid is encountered.
c
c     (2) additional work space (see (1) under "arguments differences") is
c         required by muh2 to implement gaussian elimination at the coarsest
c         grid level.  this may limit the size of ixp and jyq.
c
c     (3) operation counts
c
c         for simplicity, assume p = ixp = jyq and n = nx = ny.  banded
c         gaussian elimination requires o(p**4) operations for solution
c         on the coarsest subgrid while multigrid iteration is a o(n**2)
c         algorithm. these are approximately balanced when
c
c           p**4 =: (n/(2**k))**4 =: n**2
c
c         or
c
c           k =: log2(n)/2
c
c         grid levels are chosen with the hybrid method.  so if
c         p is approximately equal to
c
c           n/(2**(log2(n)/2))
c
c         then the direct method and multigrid parts of the hybrid algorithm
c         require roughly the same amount of computer time.  larger values
c         for p mean the direct method will dominate the computation.  smaller
c         values mean the hybrid method will cost only marginally more than
c         multigrid iteration with coarse grid relaxation.
c
c
c *** the remaining documentation is almost identical to mud2.d
c     except for the modifications already indicated.
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny grid.  the grid
c     is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1)
c
c     be the uniform grid increments in the x,y directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly
c
c     for i=1,...,nx and j=1,...,ny  denote the x,y uniform mesh points
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 17 used to pass integer
c          arguments.  iparm is set internally and defined as
c          follows:
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      an approximation is not generated after an intl=0 call!
c          muh2 should be called with intl=1 to approximate the elliptic
c          pde discretized by the intl=0 call.  intl=1 should also
c          be input if muh2 has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  this will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) muh2 is being recalled for additional accuracy.  in
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) muh2 is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) muh2 is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to muh2

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by coef (see below) have
c              changed since the previous call
c
c          (e) any of the "alfa" coefficients input by bndyc (see below)
c              have changed since the previous call.
c
c          if any of (a) through (e) are true then the elliptic pde
c          must be discretized or rediscretized.  if none of (a)
c          through (e) holds, calls can be made with intl=1.
c          incorrect calls with intl=1 will produce erroneous results.
c  ***     the values set in the saved work space "work" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the edge x=xa
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y
c            (if nxa=0 then nxb=0 is required, see ierror = 2)
c
c        = 1 if p(xa,y) is specified (this must be input thru phi(1,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see bndyc)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the edge x=xb
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y)
c            (if nxb=0 then nxa=0 is required, see ierror = 2)
c
c        = 1 if p(xb,y) is specified (this must be input thru phi(nx,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see bndyc)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the edge y=yc
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c            (if nyc=0 then nyd=0 is required, see ierror = 2)
c
c        = 1 if p(x,yc) is specified (this must be input thru phi(i,1))
c
c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see bndyc)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the edge y=yd
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c             (if nyd=0 then nyc=0 is required, see ierror = 2)
c
c        = 1 if p(x,yd) is specified (this must be input thru phi(i,ny))
c
c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see bndyc)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(6)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the x direction is not used.
c          if ixp > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of ixp can be removed by increasing iex = iparm(8)
c          without changing nx = iparm(10).
c
c
c ... jyq = iparm(7)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the y direction is not used.
c          if jyq > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of jyq can be removed by increasing jey = iparm(9)
c          without changing ny = iparm(11).
c
c
c ... iex = iparm(8)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx.
c
c
c ... jey = iparm(9)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(7)
c          as small as possible within grid size constraints when
c          defining ny.
c
c
c
c ... nx = iparm(10)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(6), iex = iparm(8).
c
c
c ... ny = iparm(11)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(7), jey = iparm(9).
c
c
c *** example
c
c         suppose a solution is wanted on a 33 by 97 grid.  then
c         ixp=2, jyq=6 and iex=jey=5 could be used.  a better
c         choice would be ixp=2, jyq=3, and iex=5, jey=6.
c
c *** grid size flexibility considerations:
c
c     the hybrid multigrid/direct method code muh2 provides more grid size
c     flexibility than mud2 by removing the constraint that ixp and jyq are
c     2 or 3.  this is accomplished by using a direct method whenever the
c     coarsest (ixp+1) x (jyq+1) grid is encountered in multigrid cycling.
c     if nx = ixp+1 and ny = jyq+1 then muh2 becomes a full direct method.
c     muh2 is roughly equivalent to mud2 in efficiency as long as ixp and
c     jyq remain "small".   if the problem to be approximated requires
c     a grid neither mud2 por muh2 can exactly fit then another option
c     is to generate an approximation on a "close grid" using mud2 or muh2.
c     then transfer the result to the required grid using cubic interpolation
c     via the package "regridpack"(contact john adams about this software)
c
c *** note
c
c     let G be the nx by ny fine grid on which the approximation is
c     generated and let n = max0(iex,jey).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         G(1) < ... < G(k) < ... < G(n) = g.
c
c     each G(k) (k=1,...,n) has mx(k) by my(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c     If iex = jey = 1 then G(1) = G(n) and muh2 solves the problem
c     directly with block banded Gaussian elimination.  Otherwise
c     muh2 replaces relaxation with a direct method on G(1).
c
c ... iguess=iparm(12)
c
c          = 0 if no initial guess to the pde is provided
c
c          = 1 if an initial guess to the pde is at the finest grid
c              level is provided in phi (see below)
c
c     comments on iguess = 0 or 1 . . .
c
c     even if iguess = 0, phi must be initialized at all grid points (this
c     is not checked).  phi can be set to 0.0 at non-dirchlet grid points
c     if nothing better is available.  the values set in phi when iguess = 0
c     are passed down and serve as an initial guess to the pde at the coarsest
c     grid level where cycling commences.  in this sense, values input in
c     phi always serve as an initial guess.  setting iguess = 0 forces full
c     multigrid cycling beginning at the coarsest and finishing at the finest
c     grid level.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c     time dependent problems . . .
c
c *** assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at nondirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(13)
c
c          the exact number of cycles executed between the finest (nx by
c          ny) and the coarsest ((ixp+1) by (jyq+1)) grid levels when
c          tolmax=fparm(5)=0.0 (no error control).  when tolmax > 0.0
c          is input (error control) then maxcy is a limit on the number
c          of cycles between the finest and coarsest grid levels.  in
c          any case, at most maxcy*(iprer+ipost) relaxation sweeps are
c          are performed at the finest grid level (see iprer=mgopt(2),
c          ipost=mgopt(3) below).  when multigrid iteration is working
c          "correctly" only a few are required for convergence.  large
c          values for maxcy should not be necessary.
c
c
c ... method = iparm(14) determines the method of relaxation
c              (gauss-seidel based on alternating points or lines)
c
c          = 0 for  point relaxation
c
c          = 1 for line relaxation in the x direction
c
c          = 2 for line relaxation in the y direction
c
c          = 3 for line relaxation in both the x and y direction
c
c
c *** choice of method. . .
c
c     let fx represent the quantity cxx(x,y)/dlx**2 over the solution region.
c
c     let fy represent the quantity cyy(x,y)/dly**2 over the solution region
c
c     if fx,fy are roughly the same size and do not vary too much over
c     the solution region choose method = 0.  if this fails try method=3.
c
c     if fx is much greater than fy choose method = 1.
c
c     if fy is much greater than fx choose method = 2
c
c     if neither fx or fy dominates over the solution region and they
c     both vary considerably choose method = 3.
c
c
c ... length = iparm(15)
c
c          the length of the work space provided in vector work (see below).
c          let isx = 0 if method = 0 or method = 2
c          let isx = 3 if method = 1 or method = 3 and nxa.ne.0
c          let isx = 5 if method = 1 or method = 3 and nxa.eq.0
c          let jsy = 0 if method = 0 or method = 1
c          let jsy = 3 if method = 2 or method = 3 and nyc.ne.0
c          let jsy = 5 if method = 2 or method = 3 and nyc.eq.0
c
c          let ldir = (ixp+1)*(jyq+1)*(2*ixp+3) if nyc.ne.0 or
c          let ldir = (ixp+1)*[2*(ixp+1)*(2*jyq-1)+jyq+1] if nyc=0
c
c          then . . .
c
c            length = 4*[nx*ny*(10+isx+jsy)+8*(nx+ny+2)]/3 + ldir
c
c          will suffice in most cases.  the exact minimal work space
c          length required for the current nx,ny and method is output
c          in iparm(16) (even if iparm(15) is too small).  this will be
c          less then the value given by the simplified formula above
c          in most cases.
c
c
c ... fparm                                                                     
c
c          a floating point vector of length 6 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in muh2 and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... tolmax = fparm(5)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j)
c          and phi2(i,j) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(abs(phi2(i,j)-phi1(i,j))) for all i,j
c
c          and
c
c              phmax = max(abs(phi2(i,j))) for all i,j
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(5)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible DO NOT error control!).
c
c ... wk
c
c          a one dimensional real saved work space (see iparm(15) for
c          length) which must be preserved from the previous call when
c          calling with intl=iparm(1)=1.
c
c ... iwk
c
c          an integer vector dimensioned of length at least (ixp+1)*(jyq+1)
c          (ixp = iparm(6),jyq=iparm(7)) in the routine calling muh2.
c          The length of iwk is not checked!  If iwk has length less than
c          (ixp+1)*(jyq+1) then undetectable errors will result.
c
c ... bndyc                                                                     
c
c          a subroutine with  arguments (kbdy,xory,alfa,gbdy) which
c          are used to input mixed boundary conditions to muh2. bndyc
c          must be declared "external" in the program calling muh2.
c          the boundaries are numbered one thru four and the mixed
c          derivative boundary conditions are described below (see the
c          sample driver code "tmuh2.f" for an example of how bndyc is
c          can beset up).
c                                                                               
c          * * * * * * * * * * * *  y=yd
c          *       kbdy=4        *
c          *                     *
c          *                     *
c          *                     *
c          * kbdy=1       kbdy=2 *
c          *                     *
c          *                     *
c          *                     *
c          *       kbdy=3        *
c          * * * * * * * * * * * *  y=yc
c
c          x=xa                  x=xb
c
c
c          (1) the kbdy=1 boundary
c
c          this is the edge x=xa where nxa=iparm(2)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dx + alfxa(y)*p(xa,y) = gbdxa(y)
c
c          in this case kbdy=1,xory=y will be input to bndyc and
c          alfa,gbdy corresponding to alfxa(y),gbdxa(y) must be returned.
c
c
c          (2) the kbdy=2 boundary
c
c          this is the edge x=xb where nxb=iparm(3)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dx + alfxb(y)*p(xb,y) = gbdxb(y)
c
c          in this case kbdy=2,xory=y, will be input to bndyc and
c          alfa,gbdy corresponding to alfxb(y),gbdxb(y) must be returned.
c
c
c          (3) the kbdy=3 boundary
c
c          this is the edge y=yc where nyc=iparm(4)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dy + alfyc(x)*p(x,yc) = gbdyc(x)
c
c          in this case kbdy=3,xory=x will be input to bndyc and
c          alfa,gbdy corresponding to alfyc(x),gbdyc(x) must be returned.
c
c
c          (4) the kbdy=4 boundary
c
c          this is the edge y=yd where nyd=iparm(5)=2 flags
c          a mixed boundary condition of the form
c
c             dp/dy + alfyd(x)*p(x,yd) = gbdyd(x)
c
c          in this case kbdy=4,xory=x will be input to bndyc and
c          alfa,gbdy corresponding to alfyd(x),gbdyd(x) must be returned.
c
c                                                                               
c ***      bndyc must provide the mixed boundary condition values
c          in correspondence with those flagged in iparm(2) thru
c          iparm(5).  if all boundaries are specified or periodic
c          muh2 will never call bndyc.  even then it must be entered
c          as a dummy subroutine. bndyc must be declared "external"
c          in the routine calling muh2.  the actual name chosen may
c          be different.
c
c
c ... coef
c
c         a subroutine with arguments (x,y,cxx,cyy,cx,cy,ce) which
c         provides the known real coefficients for the elliptic pde at
c         any grid point (x,y).  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         "external."
c
c ... rhs                                                                       
c
c          an array dimensioned nx by ny which contains the given
c          right hand side values on the uniform 2-d mesh.
c
c              rhs(i,j) = r(xi,yj) for i=1,...,nx and j=1,...,ny
c
c ... phi                                                                       
c
c          an array dimensioned nx by ny.  on input phi must contain
c          specified boundary values. for example, if nyd=iparm(5)=1
c          then phi(i,ny) must be set equal to p(xi,yd) for i=1,...nx
c          prior to calling muh2.  these values are preserved by muh2.
c          if an initial guess is provided (iguess=iparm(11)=1) it must
c          be input thru phi.
c
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at all grid points (this is not checked).  these
c          values will serve as an initial guess to the pde at the coarsest
c          grid level after a transfer from the fine solution grid.  set phi
c          equal to to 0.0 at all internal and non-specified boundaries
c          grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid parameters (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the parameters
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).  all version 5.0.1
c     mudpack solvers use only fully weighted residual restriction.  The
c     "D" at grid level 1 indicates a direct method is used.
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---D-----D-----------D-----------------D---------------     level 1
c
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --D---D-------D---D-----------D---D-------D---D--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c *** this algorithim is modified with the hybrid solvers which use
c     a direct method whenever grid level 1 is encountered.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c
c **********************************************************************
c *** output arguments ************************************************
c **********************************************************************
c
c
c ... iparm(16)  *** set for intl=0 calls only
c
c          on output iparm(16) contains the actual work space length
c          required.  this will usually be less than that given by the
c          simplified formula for length=iparm(15) (see as input argument)
c
c
c ... iparm(17)  *** set for intl=1 calls only
c
c          on output iparm(17) contains the actual number of multigrid cycles
c          between the finest and coarsest grid levels used to obtain the
c          approximation when error control (tolmax > 0.0) is set.
c
c
c ... fparm(6)   *** set for intl=1 calls with fparm(5) > 0. only
c
c          on output fparm(6) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(6) is computed only if there is error control (tolmax > 0.0)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c               phdif = max(abs(phi2(i,j)-phi1(i,j))) over all i,j
c
c          and
c
c               phmax = max(abs(phi2(i,j)) over all i,j
c
c          then
c
c               fparm(6) = phdif/phmax
c
c          is returned whenever phmax > 0.0. in the degenerate case
c          phmax = 0.0, fparm(6) = phdif is returned.
c
c
c ... work
c
c          on output work contains intermediate values that must not
c          be destroyed if muh2 is to be called again with intl=1
c
c
c ... phi   *** for intl=1 calls only
c
c          on output phi(i,j) contains the approximation to p(xi,yj)
c          for all mesh points i = 1,...,nx and j=1,...,ny.  the last
c          computed iterate in phi is returned even if convergence is
c          not obtained
c
c
c ... ierror
c
c          for intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  discretization is bypassed for intl=1 calls
c          which can only return ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              abs(cx)*dlx > 2.*abs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              abs(cy)*dly > 2.*abs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c
c             cxx = amax1(cxx,0.5*abs(cx)*dx)
c
c                          (and)
c
c             cyy = amax1(cyy,0.5*abs(cy)*dy)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made to preserve convergence of multigrid iteration. if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-2  if the pde is not elliptic (i.e., cxx*cyy.le.0.0 for some (xi,yj))
c          in this case a solution is still attempted although convergence
c          may not occur due to ill-conditioning of the linear system.
c          the ierror = -2 flag overrides the ierror=-5,-4 nonfatal
c          flags.
c
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd
c         in iparm(2),iparm(3),iparm(4),iparm(5) are not 0,1 or 2
c         or if nxa,nxb or nyc,nyd are not pairwise zero.
c
c     = 3 if mino(ixp,jyq) < 2 (ixp = iparm(6), jyq = iparm(7))
c         of if ixp < 3 when nxa=0 or if jyq < 3 when nyc=0.
c
c     = 4 if min0(iex,jey) < 1 (iex = iparm(8), jey = iparm(9)) or
c         if max0(iex,jey) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or ny.ne.jyq*2**(jey-1)+1
c         (nx = iparm(10), ny = iparm(11))
c
c     = 6 if iguess = iparm(12) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(13) < 1
c
c     = 8 if method = iparm(14) is not 0,1,2, or 3
c
c     = 9 if length = iparm(15) is too small (see iparm(16) on output
c         for minimum required work space length)
c
c     =10 if xa >= xb or yc >= yd
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4))
c
c     =11 if tolmax = fparm(5) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(1) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c     =13 if iex=jey=1 (full direct method) and iguess=1 or maxcy > 1
c
c     =14 if the elliptic pde is singular (see ierror=-3 in mud2.d)
c
c *********************************************************
c *********************************************************
c
c     end of muh2 documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="muh24.txt"><b>MUH24</b></a>
<PRE>
c
c     file muh24.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file muh24.d
c
c     contains documentation for:
c     subroutine muh24(wk,iwk,phi,ierror)
c     A sample fortran driver is file "tmuh24.f".
c
c ... required MUDPACK files
c
c     muh2.f, mudcom.f
c
c ... purpose
c
c     muh24 attempts to improve the estimate in phi, obtained by calling
c     muh2,  from second to fourth order accuracy.  see the file "muh2.d"
c     for a detailed discussion of the elliptic pde approximated and
c     arguments "wk,iwk,phi" which are also part of the argument list for
c     muh2.
c
c ... assumptions
c
c     *  phi contains a second-order approximation from an earlier muh2 call
c
c     *  arguments "wk,iwk,phi" are the same used in calling muh2
c
c     *  "wk,iwk,phi" have not changed since the last call to muh2
c
c     *  the finest grid level contains at least 6 points in each direction
c
c
c *** warning
c
c     if the first assumption is not true then a fourth order approximation
c     cannot be produced in phi.  the last assumption (adequate grid size)
c     is the only one checked. failure in any of the others can result in
c     in an undetectable error.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections"
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... error parameter
c
c     = 0 if no error is detected
c
c     = 30 if min0(nx,ny) < 6 where nx,ny are the fine grid sizes
c          in the x,y directions.
c                                                                               
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of muh24 documentation
c
c  ***********************************************************************
c  ***********************************************************************
c
</PRE>
<HR>
 
<a name="muh24cr.txt"><b>MUH24CR</b></a>
<PRE>
c
c     file muh24cr.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file muh24cr.d
c
c     contains documentation for:
c     subroutine muh24cr(wk,iwk,coef,bndyc,phi,ierror)
c     A sample fortran driver is file "tmuh24cr.f".
c
c ... required MUDPACK files
c
c     muh2cr.f, mudcom.f
c
c ... purpose
c
c     muh24cr attempts to improve the estimate in phi, obtained by calling
c     muh2cr,  from second to fourth order accuracy.  see the file "muh2cr.d"
c     for a detailed discussion of the elliptic pde approximated and
c     arguments "wk,iwk,coef,bndyc,phi" which are also part of the argument
c     list for muh2cr.
c
c ... assumptions
c
c     *  phi contains a second-order approximation from an earlier muh2cr call
c
c     *  arguments "wk,iwk,coef,bndyc,phi" are the same used in calling muh2cr
c
c     *  "wk,iwk,coef,bndyc,phi" have not changed since the last call to muh2cr
c
c     *  the finest grid level contains at least 6 points in each direction
c
c
c *** warning
c
c     if the first assumption is not true then a fourth order approximation
c     cannot be produced in phi.  the last assumption (adequate grid size)
c     is the only one checked. failure in any of the others can result in
c     in an undetectable error.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections"
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c ... error parameter
c
c     = 0 if no error is detected
c
c     = 30 if min0(nx,ny) < 6 where nx,ny are the fine grid sizes
c          in the x,y directions.
c                                                                               
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of muh24cr documentation
c
c  ***********************************************************************
c  ***********************************************************************
c
</PRE>
<HR>
 
<a name="muh2cr.txt"><b>MUH2CR</b></a>
<PRE>
c
c     file muh2cr.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file muh2cr.d
c
c     contains documentation for:
c     subroutine muh2cr(iparm,fparm,work,coef,bndyc,rhs,phi,mgopt,ierror)
c     a sample fortran driver is file "tmuh2cr.f".
c
c ... required mudpack files
c
c     mudcom.f
c
c ... purpose
c
c     the "hybrid" multigrid/direct method code muh2cr approximates the
c     same 2-d nonseparable elliptic pde as the mudpack solver mud2cr.
c     muh2cr combines the efficiency of multigrid iteration with the certainty
c     a direct method.  the basic algorithm is modified by using banded
c     gaussian elimination in place of relaxation whenever the coarsest
c     subgrid is encountered within multigrid cycling.  this provides
c     additional grid size flexibility by eliminating the usual multigrid
c     constraint that the coarsest grid consist of "few" points for effective
c     error reduction with multigrid cycling.  in many cases the hybrid method
c     provides more robust convergence characteristics than multigrid cycling
c     alone.
c
c     the form of the pde solved is:
c
c          cxx(x,y)*pxx + cxy(x,y)*pxy + cyy(x,y)*pyy + cx(x,y)*px +
c
c          cy(x,y)*py + ce(x,y)*p(x,y) = r(x,y).
c
c
c     pxx,pxy,pyy,px,py are second and first partial derivatives of the
c     unknown real solution function p(x,y) with respect to the
c     independent variables x,y.  cxx,cxy,cyy,cx,cy,ce are the known
c     real coefficients of the elliptic pde and r(x,y) is the known
c     real right hand side of the equation.  cxx and cyy should be
c     positive for all x,y in the solution region and
c
c          4*cxx(x,y)*cyy(x,y) .le. cxy(x,y)**2
c
c     for ellipticity (see ierror=-2).  nonseparability means some
c     of the coefficients depend on both x and y and cxy.ne.0.  if
c     the pde is separable and cxy = 0 then subroutine muh2sp should
c     be used.
c                                                                               
c *** muh2cr becomes a full direct method if grid size arguments are chosen
c     so that the coarsest and finest grids coincide.  choosing iex=jey=1
c     and ixp=nx-1, jyq=ny-1 (iex=iparm(6),jey=iparm(7),ixp=iparm(8),
c     jyq=iparm(9),nx=iparm(10),ny=iparm(11)) will set gaussian elimination
c     on the nx by ny grid.  in this case, muh2cr produces a direct solution
c     to the same nonseparable elliptic pde as the direct solver crosel [5,6].
c     muh2cr is more general than crosel since it allows periodic boundary
c     conditions in the y direction.
c
c
c ... argument differences with mud2cr.f
c
c     the input and output arguments of muh2cr are almost identical to the
c     arguments of mud2cr (see mud2cr.d) with the following exceptions:
c
c     (1) the work space vector "wk" requires
c
c              (ixp+1)*(jyq+1)*(2*ixp+3)
c
c         additional words of storage (ixp = iparm(6), jyq = iparm(7))
c         if periodic boundary conditions are not flagged in the y direction
c         (nyc .ne. 0 where nyc = iparm(4)) or
c
c              (ixp+1)*[2*(ixp+1)*(2*jyq-1)+jyq+1]
c
c         additional words of storage if periodic boundary conditions are
c         flagged in the y direction (nyc = 0).  the extra work space is
c         used for a direct solution with gaussian elimination whenever the
c         coarsest grid is encountered within multigrid cycling.
c
c     (2) an integer work space iwk of length at least (ixp+1)*(jyq+1)
c         must be provided.
c
c     (3) jyq must be greater than 2 if periodic boundary conditions
c         are flagged in the y direction and ixp must be greater than
c         2 if periodic boundary conditions are flagged in the x direction.
c         inputting jyq = 2 when nyc = 0 or inputting ixp = 2 when nxa = 0
c         will set the fatal error flag ierror=3
c
c *** (4) it is no longer necessary that ixp and jyq be "small" for
c         effective error reduction with multigrid iteration.  there
c         is no reduction in convergence rates when larger values for
c         ixp or jyq are used .  this provides additional flexibility
c         in choosing grid size.  in many cases muh2cr provides more
c         robust convergence than mud2cr.  it can be used in place of
c         mud2cr for all nonsingular problems (see (6) below).
c
c     (5) iguess = iparm(11) = 1 (flagging an initial guess) or
c         maxcy = iparm(14) > 1 (setting more than one multigrid
c         cycle) are not allowed if muh2cr becomes a full direct method
c         by choosing iex = jey = 1 (iex = iparm(8),jey = iparm(9)).
c         this conflicting combination of input arguments for multigrid
c         iteration and a full direct method set the fatal error flag
c
c              ierror = 13
c
c         iguess = 0 and maxcy = 1 are required when muh2 becomes a
c         full direct method.
c
c     (6) if a "singular" pde is detected (see ierror=-3 description in mud2cr.d;
c         ce(x,y) = 0.0 for all x,y and the boundary conditions are a combination
c         of periodic and/or pure derivatives) then muh2cr sets the fatal error
c         flag
c
c              ierror = 14
c
c         the direct method utilized by muh2cr would likely cause a division
c         by zero in the singular case.  mud2cr can be tried for singular problems
c
c
c ... grid size considerations
c
c     (1) flexibility
c
c         muh2cr should be used in place of mud2cr whenever grid size
c         requirements do not allow choosing ixp and jyq to be "small"
c         positive integers (typically less than 4).
c
c         example:
c
c         suppose we wish to solve an elliptic pde on a one degree grid on
c         the full surface of a sphere.  choosing ixp = jyq = 45 and iex = 4
c         and jyq = 3 fits the required 361 by 181 grid exactly.  multigrid
c         cycling will be used on the sequence of subgrid sizes:
c
c           46 x 46  <  91 x 46  <  181 x 91  <  361 x 181
c
c         the 46 x 46 coarsest subgrid has too much resolution for effective
c         error reduction with relaxation only.  muh2cr circumvents this
c         difficulty by generating an exact direct solution (modulo roundoff
c         error) whenever the coarsest grid is encountered.
c
c     (2) additional work space (see (1) under "arguments differences") is
c         required by muh2 to implement gaussian elimination at the coarsest
c         grid level.  this may limit the size of ixp and jyq.
c
c     (3) operation counts
c
c         for simplicity, assume p = ixp = jyq and n = nx = ny.  banded
c         gaussian elimination requires o(p**4) operations for solution
c         on the coarsest subgrid while multigrid iteration is a o(n**2)
c         algorithm. these are approximately balanced when
c
c           p**4 =: (n/(2**k))**4 =: n**2
c
c         or
c
c           k =: log2(n)/2
c
c         grid levels are chosen with the hybrid method.  so if
c         p is approximately equal to
c
c           n/(2**(log2(n)/2))
c
c         then the direct method and multigrid parts of the hybrid algorithm
c         require roughly the same amount of computer time.  larger values
c         for p mean the direct method will dominate the computation.  smaller
c         values mean the hybrid method will cost only marginally more than
c         multigrid iteration with coarse grid relaxation.
c
c
c *** the remaining documentation is almost identical to mud2cr.d
c     except for the modifications already indicated.
c
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny grid.  the grid
c     is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1)
c
c     be the uniform grid increments in the x,y directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly
c
c     for i=1,...,nx and j=1,...,ny  denote the x,y uniform mesh points
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 17 used to pass integer
c          arguments.  iparm is set internally and defined as
c          follows:
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      an approximation is not generated after an intl=0 call!
c          muh2cr should be called with intl=1 to approximate the elliptic
c          pde discretized by the intl=0 call.  intl=1 should also
c          be input if muh2cr has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  this will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) muh2cr is being recalled for additional accuracy.  in
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) muh2cr is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) muh2cr is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to muh2cr

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by coef (see below) have
c              changed since the previous call
c
c          (e) any of the "alfa" coefficients input by bndyc (see below)
c              have changed since the previous call.
c
c          if any of (a) through (e) are true then the elliptic pde
c          must be discretized or rediscretized.  if none of (a)
c          through (e) holds, calls can be made with intl=1.
c          incorrect calls with intl=1 will produce erroneous results.
c  ***     the values set in the saved work space "work" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the edge x=xa
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y
c            (if nxa=0 then nxb=0 is required, see ierror = 2)
c
c        = 1 if p(xa,y) is specified (this must be input thru phi(1,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see bndyc)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the edge x=xb
c
c        = 0 if p(x,y) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y) = p(x,y) for all x,y)
c            (if nxb=0 then nxa=0 is required, see ierror = 2)
c
c        = 1 if p(xb,y) is specified (this must be input thru phi(nx,j))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see bndyc)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the edge y=yc
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c            (if nyc=0 then nyd=0 is required, see ierror = 2)
c
c        = 1 if p(x,yc) is specified (this must be input thru phi(i,1))
c
c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see bndyc)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the edge y=yd
c
c        = 0 if p(x,y) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc) = p(x,y) for all x,y
c             (if nyd=0 then nyc=0 is required, see ierror = 2)
c
c        = 1 if p(x,yd) is specified (this must be input thru phi(i,ny))
c
c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see bndyc)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(6)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the x direction is not used.
c          if ixp > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of ixp can be removed by increasing iex = iparm(8)
c          without changing nx = iparm(10).
c
c
c ... jyq = iparm(7)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible.
c          recommended values are the small primes 2 or 3.
c          larger values can reduce multigrid convergence rates considerably,
c          especially if line relaxation in the y direction is not used.
c          if jyq > 2 then it should be 2 or a small odd value since a power
c          of 2 factor of jyq can be removed by increasing jey = iparm(9)
c          without changing ny = iparm(11).
c
c
c ... iex = iparm(8)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(10)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx.
c
c
c ... jey = iparm(9)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(11)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(7)
c          as small as possible within grid size constraints when
c          defining ny.
c
c
c
c ... nx = iparm(10)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(6), iex = iparm(8).
c
c
c ... ny = iparm(11)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(7), jey = iparm(9).
c
c
c *** example
c
c         suppose a solution is wanted on a 33 by 97 grid.  then
c         ixp=2, jyq=6 and iex=jey=5 could be used.  a better
c         choice would be ixp=2, jyq=3, and iex=5, jey=6.
c
c *** grid size flexibility considerations:
c
c     the hybrid multigrid/direct method code muh2cr provides more grid size
c     flexibility than muh2cr by removing the constraint that ixp and jyq are
c     2 or 3.  this is accomplished by using a direct method whenever the
c     coarsest (ixp+1) x (jyq+1) grid is encountered in multigrid cycling.
c     if nx = ixp+1 and ny = jyq+1 then muh2cr becomes a full direct method.
c     muh2cr is roughly equivalent to muh2cr in efficiency as long as ixp and
c     jyq remain "small" (see muh2cr.d).  if the problem to be approximated
c     requires a grid neither muh2cr or muh2cr can exactly fit then another option
c     is to generate an approximation on a "close grid" using mud2cr or muh2cr.
c     then transfer the result to the required grid using cubic interpolation
c     via the package "regridpack"(contact john adams about this software)
c
c *** note
c
c     let G be the nx by ny fine grid on which the approximation is
c     generated and let n = max0(iex,jey).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         G(1) < ... < G(k) < ... < G(n) = G.
c
c     each G(k) (k=1,...,n) has mx(k) by my(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c
c
c ... iguess=iparm(12)
c
c          = 0 if no initial guess to the pde is provided
c
c          = 1 if an initial guess to the pde is at the finest grid
c              level is provided in phi (see below)
c
c     comments on iguess = 0 or 1 . . .
c
c     even if iguess = 0, phi must be initialized at all grid points (this
c     is not checked).  phi can be set to 0.0 at non-dirchlet grid points
c     if nothing better is available.  the values set in phi when iguess = 0
c     are passed down and serve as an initial guess to the pde at the coarsest
c     grid level where cycling commences.  in this sense, values input in
c     phi always serve as an initial guess.  setting iguess = 0 forces full
c     multigrid cycling beginning at the coarsest and finishing at the finest
c     grid level.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c     time dependent problems . . .
c
c *** assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at nondirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(13)
c
c          the exact number of cycles executed between the finest (nx by
c          ny) and the coarsest ((ixp+1) by (jyq+1)) grid levels when
c          tolmax=fparm(5)=0.0 (no error control).  when tolmax > 0.0
c          is input (error control) then maxcy is a limit on the number
c          of cycles between the finest and coarsest grid levels.  in
c          any case, at most maxcy*(iprer+ipost) relaxation sweeps are
c          are performed at the finest grid level (see iprer=mgopt(2),
c          ipost=mgopt(3) below).  when multigrid iteration is working
c          "correctly" only a few are required for convergence.  large
c          values for maxcy should not be necessary.
c
c
c ... method = iparm(14) determines the method of relaxation
c              (gauss-seidel based on alternating points or lines)
c
c          = 0 for  point relaxation
c
c          = 1 for line relaxation in the x direction
c
c          = 2 for line relaxation in the y direction
c
c          = 3 for line relaxation in both the x and y direction
c
c
c *** choice of method. . .
c
c     let fx represent the quantity cxx(x,y)/dlx**2 over the solution region.
c
c     let fy represent the quantity cyy(x,y)/dly**2 over the solution region
c
c     if fx,fy are roughly the same size and do not vary too much over
c     the solution region choose method = 0.  if this fails try method=3.
c
c     if fx is much greater than fy choose method = 1.
c
c     if fy is much greater than fx choose method = 2
c
c     if neither fx or fy dominates over the solution region and they
c     both vary considerably choose method = 3.
c
c
c ... length = iparm(15)
c
c          the length of the work space provided in vector work (see below).
c          let isx = 0 if method = 0 or method = 2
c          let isx = 3 if method = 1 or method = 3 and nxa.ne.0
c          let isx = 5 if method = 1 or method = 3 and nxa.eq.0
c          let jsy = 0 if method = 0 or method = 1
c          let jsy = 3 if method = 2 or method = 3 and nyc.ne.0
c          let jsy = 5 if method = 2 or method = 3 and nyc.eq.0
c          let
c
c           len = 4*[(nx+2)*(ny+2)+(10+isx+jsy)*nx*ny]/3+(nx+2)*(ny+2)
c
c          let (space for coarse grid direct method)
c
c           ldir = (ixp+1)*(jyq+1)*(2*ixp+3) (if nyc.ne.0)  or
c
c           ldir = (ixp+1)*[2*(ixp+1)*(2*jyq-1)+jyq+1] (if nyc=0)
c
c          then
c
c           length = len + ldir
c
c          will suffice in most cases.  the exact minimal work space
c          length required for the current nx,ny and method is output
c          in iparm(16) (even if iparm(15) is too small).  this will be
c          less then the value given by the simplified formula above
c          in most cases.
c
c
c ... fparm                                                                     
c
c          a floating point vector of length 6 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in muh2cr and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... tolmax = fparm(5)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j)
c          and phi2(i,j) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(abs(phi2(i,j)-phi1(i,j))) for all i,j
c
c          and
c
c              phmax = max(abs(phi2(i,j))) for all i,j
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(5)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible do not use error control!).
c
c ... wk
c
c          a one dimensional real saved work space (see iparm(15) for
c          length) which must be preserved from the previous call when
c          calling with intl=iparm(1)=1.
c
c ... iwk
c
c          an integer vector dimensioned of length at least (ixp+1)*(jyq+1)
c          (ixp = iparm(6),jyq=iparm(7)) in the routine calling muh2cr.
c          the length of iwk is not checked!  if iwk has length less than
c          (ixp+1)*(jyq+1) then undetectable errors will result.
c
c ... bndyc                                                                     
c
c          a subroutine with  arguments (kbdy,xory,alfa,beta,gama,gbdy) which
c          are used to input mixed boundary conditions to muh2cr. bndyc
c          must be declared "external" in the program calling muh2cr.
c          the boundaries are numbered one thru four and the mixed
c          derivative boundary conditions are described below (see the
c          sample driver code "tmuh2cr.f" for an example of how bndyc is
c          can beset up).
c                                                                               
c          * * * * * * * * * * * *  y=yd
c          *       kbdy=4        *
c          *                     *
c          *                     *
c          *                     *
c          * kbdy=1       kbdy=2 *
c          *                     *
c          *                     *
c          *                     *
c          *       kbdy=3        *
c          * * * * * * * * * * * *  y=yc
c
c          x=xa                  x=xb
c
c
c
c    (1)   the kbdy=1 boundary
c
c          this is the edge x=xa where nxa=iparm(2) = 2 flags
c          a mixed boundary condition of the form
c
c             alfxa(y)*px + betxa(y)*py + gamxa(y)*p(xa,y) = gbdxa(y)
c
c          in this case kbdy=1,xory=y will be input to bndyc and
c          alfa,beta,gama,gbdy corresponding to alfxa(y),betxa(y),gamxa(y),
c          gbdxa(y) must be returned.  alfxa(y) = 0. is not allowed for any y.
c          (see ierror = 13)
c
c    (2)   the kbdy=2 boundary
c
c          this is the edge x=xb where nxb=iparm(3) = 2 flags
c          a mixed boundary condition of the form
c
c             alfxb(y)*px + betxb(y)*py + gamxb(y)*p(xb,y) = gbdxb(y)
c
c          in this case kbdy=2,xory=y will be input to bndyc and
c          alfa,beta,gama,gbdy corresponding to alfxb(y),betxb(y),gamxb(y),
c          gbdxb(y) must be returned. alfxb(y) = 0.0 is not allowed for any y.
c          (see ierror = 13)
c
c    (3)   the kbdy=3 boundary
c
c          this is the edge y=yc where nyc=iparm(4) = 2 flags
c          a mixed boundary condition of the form
c
c             alfyc(x)*px + betyc(x)*py + gamyc(x)*p(x,yc) = gbdyc(x)
c
c          in this case kbdy=3,xory=x will be input to bndyc and
c          alfa,beta,gama,gbdy corresponding to alfyc(x),betyc(x),gamyc(x),
c          gbdyc(x) must be returned. betyc(x) = 0.0 is not allowed for any x.
c          (see ierror = 13)
c
c    (4)   the kbdy=4 boundary
c
c          this is the edge y=yd where nyd=iparm(5) = 2 flags
c          a mixed boundary condition of the form
c
c             alfyd(x)*px + betyd(x)*py + gamyd(x)*p(x,yd) = gbdyd(x)
c
c          in this case kbdy=4,xory=x will be input to bndyc and
c          alfa,beta,gama,gbdy corresponding to alfyd(x),betyd(x),gamyd(x),
c          gbdyd(x) must be returned. betyd(x) = 0.0 is not allowed for any x.
c          (see ierror = 13)
c
c                                                                               
c ***      bndyc must provide the mixed boundary condition values
c          in correspondence with those flagged in iparm(2) thru
c          iparm(5).  if all boundaries are specified or periodic
c          mud2cr will never call bndyc.  even then it must be entered
c          as a dummy subroutine. bndyc must be declared "external"
c          in the routine calling mud2cr.  the actual name chosen may
c          be different.
c
c
c ... coef
c
c         a subroutine with arguments (x,y,cxx,cxy,cyy,cx,cy,ce) which
c         provides the known real coefficients for the elliptic pde at
c         any grid point (x,y).  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         "external."
c
c ... rhs                                                                       
c
c          an array dimensioned nx by ny which contains the given
c          right hand side values on the uniform 2-d mesh.
c
c              rhs(i,j) = r(xi,yj) for i=1,...,nx and j=1,...,ny
c
c ... phi                                                                       
c
c          an array dimensioned nx by ny.  on input phi must contain
c          specified boundary values. for example, if nyd=iparm(5)=1
c          then phi(i,ny) must be set equal to p(xi,yd) for i=1,...nx
c          prior to calling muh2cr.  these values are preserved by muh2cr.
c          if an initial guess is provided (iguess=iparm(11)=1) it must
c          be input thru phi.
c
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at all grid points (this is not checked).  these
c          values will serve as an initial guess to the pde at the coarsest
c          grid level after a transfer from the fine solution grid.  set phi
c          equal to to 0.0 at all internal and non-specified boundaries
c          grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid arguments (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the arguments
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).  all version 5.0.1
c     mudpack solvers use only fully weighted residual restriction.  the
c     "d" at grid level 1 indicates a direct method (banded gaussian
c     elimination replaces relaxation).
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---d-----d-----------d-----------------d---------------     level 1
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --d---d-------d---d-----------d---d-------d---d--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c *** this algorithim is modified with the hybrid solvers which use
c     a direct method whenever grid level 1 is encountered.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c
c **********************************************************************
c *** output arguments ************************************************
c **********************************************************************
c
c
c ... iparm(16)  *** set for intl=0 calls only
c
c          on output iparm(16) contains the actual work space length
c          required.  this will usually be less than that given by the
c          simplified formula for length=iparm(15) (see as input argument)
c
c
c ... iparm(17)  *** set for intl=1 calls only
c
c          on output iparm(17) contains the actual number of multigrid cycles
c          between the finest and coarsest grid levels used to obtain the
c          approximation when error control (tolmax > 0.0) is set.
c
c
c ... fparm(6)   *** set for intl=1 calls with fparm(5) > 0. only
c
c          on output fparm(6) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(6) is computed only if there is error control (tolmax > 0.0)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c               phdif = max(abs(phi2(i,j)-phi1(i,j))) over all i,j
c
c          and
c
c               phmax = max(abs(phi2(i,j)) over all i,j
c
c          then
c
c               fparm(6) = phdif/phmax
c
c          is returned whenever phmax > 0.0. in the degenerate case
c          phmax = 0.0, fparm(6) = phdif is returned.
c
c
c ... work
c
c          on output work contains intermediate values that must not
c          be destroyed if muh2cr is to be called again with intl=1
c
c
c ... phi   *** for intl=1 calls only
c
c          on output phi(i,j) contains the approximation to p(xi,yj)
c          for all mesh points i = 1,...,nx and j=1,...,ny.  the last
c          computed iterate in phi is returned even if convergence is
c          not obtained
c
c
c ... ierror
c
c          for intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  argument checking and discretization
c          is bypassed for intl=1 calls which can only return
c          ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              abs(cx)*dlx > 2.*abs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              abs(cy)*dly > 2.*abs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c
c             cxx = amax1(cxx,0.5*abs(cx)*dx)
c
c                          (and)
c
c             cyy = amax1(cyy,0.5*abs(cy)*dy)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made to preserve convergence of multigrid iteration. if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-3  if the continuous elliptic pde is singular.  this means the
c          boundary conditions are periodic or pure derivative at all
c          boundaries and ce(x,y) = 0.0 for all x,y.  a solution is still
c          attempted but convergence may not occur due to ill-conditioning
c          of the linear system coming from the discretization.  the
c          ierror = -3 flag overrides the ierror=-4 and ierror=-5 nonfatal
c          flags.
c
c
c     =-2  if the pde is not elliptic (i.e., cxx*cyy.le.0.0 for some (xi,yj))
c          in this case a solution is still attempted although convergence
c          may not occur due to ill-conditioning of the linear system.
c          the ierror = -2 flag overrides the ierror=-5,-4,-3 nonfatal
c          flags.
c
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd
c         in iparm(2),iparm(3),iparm(4),iparm(5) are not 0,1 or 2
c         or if nxa,nxb or nyc,nyd are not pairwise zero.
c
c     = 3 if mino(ixp,jyq) < 2 (ixp = iparm(6), jyq = iparm(7))
c
c     = 4 if min0(iex,jey) < 1 (iex = iparm(8), jey = iparm(9)) or
c         if max0(iex,jey) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or ny.ne.jyq*2**(jey-1)+1
c         (nx = iparm(10), ny = iparm(11))
c
c     = 6 if iguess = iparm(12) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(13) < 1
c
c     = 8 if method = iparm(14) is not 0,1,2, or 3
c
c     = 9 if length = iparm(15) is too small (see iparm(16) on output
c         for minimum required work space length)
c
c     =10 if xa >=xb or yc >=yd
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4))
c
c     =11 if tolmax = fparm(5) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(1) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c     =13 if there is a pure tangential derivative along a mixed derivative
c         boundary (e.g., nyd = 2 and betyd(x) = 0.0 for some
c         grid point x along y = yd)
c
c     =14 if there is the "singular" condition described below at a
c         cornor which is the intersection of two derivative boundaries.
c
c         (1) the cornor (xa,yc) if nxa=nyc=2 and
c             alfxa(yc)*betyc(xa)-alfyc(xa)*betxa(yc) = 0.0.
c
c         (2) the cornor (xa,yd) if nxa=nyd=2 and
c             alfxa(yd)*betyd(xa)-alfyd(xa)*betxa(yd) = 0.0.
c
c         (3) the cornor (xb,yc) if nxb=nyc=2 and
c             alfxb(yc)*betyc(xb)-alfyc(xb)*betxb(yc) = 0.0.
c
c         (4) the cornor (xb,yd) if nxb=nyd=2 and
c             alfxb(yd)*betyd(xb)-alfyd(xb)*betxb(yd) = 0.0.
c
c *** the conditions described in ierror = 13 or 14 will lead to division
c     by zero during discretization if undetected.
c
c
c *********************************************************
c *********************************************************
c
c     end of muh2cr documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="muh3.txt"><b>MUH3</b></a>
<PRE>
c
c     file muh3.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file muh3.d
c
c     contains documentation for:
c     subroutine muh3(iparm,fparm,wk,iw,coef,bndyc,rhs,phi,mgopt,ierror)
c     a sample fortran driver is file "tmuh3.f".
c
c ... required mudpack files
c
c     mudcom.f, mud3ln.f, mud3pn.f
c
c ... purpose
c
c     the "hybrid" multigrid/direct method code muh3 approximates the
c     same 3-d nonseparable elliptic pde as the mudpack solver mud3.
c     the basic algorithm is modified by using block banded gaussian
c     elimination in place of relaxation whenever the coarsest subgrid is
c     encountered within multigrid cycling.  use of the direct method at
c     the coarsest grid level gives muh3 at least two advantages over mud3:
c
c     (1) improved convergence rates
c
c         the use of a direct method at the coarsest grid level can
c         improve convergence rates at a small additional computational
c         cost if the coarse grid parameters ixp=iparm(8),jyq=iparm(9),
c         kzr=iparm(10) are small relative to the fine grid parameters
c         nx=iparm(14),ny=iparm(15),nz=iparm(16).  this is especially true
c         in the presence of certain boundary conditions.  for example,
c         if all boundary conditions are neuman (pure derivative) and/or
c         periodic then mud3 may fail to converge.  muh3 should handle
c         these boundary conditions with the expected multigrid efficiency
c         (see tmuh3.f).  in all cases, muh3 should give convergence
c         rates which equal or exceed mud3.
c
c
c     (2) more resolution choices
c
c         muh3 allows more grid size flexibility by "relaxing" the
c         constraint on the coarse grid parameters that ixp,jyq,kzr
c         be "very" small (2 or 3 for mud3) for effective error
c         error reduction within multigrid cycling.  convergence
c         rates will not deteoriate with larger values for ixp,
c         jyq,kzr.
c
c *** caution
c
c     because of the very large computational and storage
c     requirements, the three-dimensional dimensional direct
c     method costs can overwhelm the multigrid cycling costs
c     if the coarsest grid is not small relative to the finest
c     solution grid.  this is a user decision set by the choice
c     of coarse and fine grid parameters (see iparm(8) through
c     iparm(16) and iparm(21) descriptions)
c
c     subroutine muh3 automatically discretizes and attempts to compute
c     the second order finite difference approximation to a three-
c     dimensional linear nonseparable elliptic partial differential
c     equation on a box.  the approximation is generated on a uniform
c     grid covering the box (see mesh description below).  boundary
c     conditions may be any combination of mixed, specified (Dirchlet)
c     or periodic.  the form of the pde solved is . . .
c
c          cxx(x,y,z)*pxx + cyy(x,y,z)*pyy + czz(z,y,z)*pzz +
c
c          cx(x,y,z)*px + cy(x,y,z)*py + cz(x,y,z)*pz +
c
c          ce(x,y,z)*p(x,y,z) = r(x,y,z)
c
c     here cxx,cyy,czz,cx,cy,cz,ce are the known real coefficients
c     of the pde; pxx,pyy,pzz,px,py,pz are the second and first
c     partial derivatives of the unknown solution function p(x,y,z)
c     with respect to the independent variables x,y,z; r(x,y,z) is
c     is the known real right hand side of the elliptic pde.  cxx,cyy
c     and czz should be positive for all (x,y,z) in the solution region.
c                                                                               
c
c ... argument differences with mud3.f
c
c     the input and output arguments of muh3 are almost identical to the
c     arguments of mud3 (see mud3.d) with the following exceptions:
c
c     (1) let mx=ixp+1, my=jyq+1, mz=kzr+1 (the coarsest grid
c         resolutions, ixp=iparm(8), jyq=iparm(9), kzr=iparm(10))
c         then the work space vector "wk" requires
c
c               mx*my*mz*(2*mx*my+1))           (nze.ne.0)
c
c         additional words of storage if periodic boundary conditions
c         are not flagged in the z direction or
c
c               mx*my*(mz*(4*mx*my+1))          (nze=0)
c
c         additional words of storage if periodic boundary conditions are
c         flagged in the z direction (nze = 0).  the extra work space is
c         used for a direct solution with gaussian elimination whenever the
c         coarsest grid is encountered within multigrid cycling.
c
c     (2) an integer work space iwk of length at least mx*my*mz words
c         must be provided.  the length of iwk is not checked!
c
c     (3) kzr > 2 if nze=0, jyq > 2 if nyc=0, ixp > 2 if nxe = 0 are
c         required (i.e., the coarsest grid must contain at least four
c         points in any direction with periodic boundary conditions,
c         see the expanded meaning of ierror=3).
c
c *** (4) it is no longer necessary that ixp,jyq,kzr be 2 or 3 for
c         effective error reduction with multigrid iteration.  there
c         is no reduction in convergence rates when larger values for
c         ixp,jyq,kzr are used .  this provides additional flexibility
c         in choosing grid size.  in many cases muh3 provides more
c         robust convergence than mud3.  it can be used in place of
c         mud3 for all nonsingular problems (see (5) below).
c
c     (5) iguess = iparm(17) = 1 (flagging an initial guess) or
c         maxcy = iparm(18) > 1 (setting more than one multigrid
c         cycle) are not allowed if muh3 becomes a full direct method
c         by choosing iex=jey=kez=1.  this conflicting combination
c         of input arguments for multigrid iteration and a full
c         direct method set the fatal error flag
c
c              ierror = 13
c
c         iguess = 0 and maxcy = 1 are required when muh3 becomes a
c         full direct method.  ordinarily (see *** caution above) this
c         should not happen except when testing with very coarse resolution.
c
c
c     (6) if a "singular" pde is detected (see ierror=-3 description in
c         mud3.d, ce(x,y) = 0.0 for all x,y and the boundary conditions
c         are a combination of periodic and/or pure derivatives) then muh3
c         sets the fatal error flag
c
c              ierror = 14
c
c         the direct method utilized by muh3 would likely cause a near
c         division by zero in the singular case.  mud3 can be tried for
c         singular problems.
c
c ... grid size considerations
c
c     (1) flexibility
c
c         muh3 should be used in place of mud3 whenever grid size
c         requirements do not allow choosing ixp,jyq,kzr to be 2 or 3.
c
c     (2) additional work space (see (1) under "arguments differences") is
c         required by muh3 to implement gaussian elimination at the coarsest
c         grid level.  this may limit the size of ixp,jyq,kzr.
c
c     (3) operation counts
c                                                              k
c         for simplicity, assume p=ixp=jyq=kzr and n=nx=ny=nz=2 *p.
c         gaussian elimination requires o(p**7) operations for solution
c         on the coarsest subgrid while multigrid iteration is a o(n**3)
c         algorithm.  consequently the storage and computational
c         requirements for the 3-d direct method will dominate the
c         calculation if p is "large."  note that  o(p**7)=:o(n**3)
c         whenever k =: (4/3)*log2(p) grid levels are used in cycling.
c         larger values mean the direct method will dominate the
c         calculation.  smaller values for k mean the direct method
c         will only marginally add to the cost of multigrid iteration
c         alone.
c
c *** the remaining documentation is almost identical to mud3.d
c     except for the modifications already indicated.
c
c
c ... mesh description . . .
c
c     the approximation is generated on a uniform nx by ny by nz grid.
c     the grid is superimposed on the rectangular solution region
c
c          [xa,xb] x [yc,yd] x [ze,zf].
c
c     let
c
c          dlx = (xb-xa)/(nx-1), dly = (yd-yc)/(ny-1), dlz = (zf-ze)/(nz-1)
c
c     be the uniform grid increments in the x,y,z  directions. then
c
c          xi=xa+(i-1)*dlx,  yj=yc+(j-1)*dly, zk = ze+(k-1)*dlz
c
c     for i=1,...,nx; j=1,...,ny; k=1,...,nz  denote the x,y,z uniform
c     mesh points.
c
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c *** discretization and solution (second-order solvers) (see [1])
c
c     the pde and boundary conditions are automatically discretized at all
c     grid levels using second-order finite difference formula.  diagonal
c     dominance at coarser grid levels is maintained in the presence of
c     nonzero first-order terms by adjusting the second-order coefficient
c     when necessary.  the resulting block tri-diagonal linear system is
c     approximated using multigrid iteration [10,11,13,15,16,18].  version
c     5.0.1 of mudpack uses only fully weighted residual restriction.  defaults
c     include cubic prolongation and w(2,1) cycles.  these can be overridden
c     with  selected multigrid options (see "mgopt").  error control based on
c     maximum relative differences is available. full multigrid cycling (fmg)
c     or cycling beginning or restarting at the finest grid level can be
c     selected. a menu of relaxation methods including gauss-seidel point,
c     line relaxation(s) (in any combination of directions) and planar
c     relaxation (for three-dimensional anisotropic problems) are provided.
c     all methods use ordering based on alternating points (red/black),
c     lines, or planes for cray vectorization and improved convergence
c     rates [14].
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections."
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... argument description
c                                                                               
c
c **********************************************************************
c *** input arguments *************************************************
c **********************************************************************
c
c
c ... iparm                                                                     
c
c          an integer vector of length 23 used to efficiently pass
c          integer arguments.  iparm is set internally in muh3
c          and defined as follows . . .                                         
c
c
c ... intl=iparm(1)
c
c          an initialization argument.  intl=0  must be input
c          on an initial call. in this case input arguments will
c          be checked for errors and the elliptic partial differential
c          equation and boundary conditions will be discretized using
c          second order finite difference formula.
c
c ***      an approximation is not generated after an intl=0 call!
c          muh3 should be called with intl=1 to approximate the elliptic
c          pde discretized by the intl=0 call.  intl=1 should also
c          be input if muh3 has been called earlier and only the
c          values in in rhs (see below) or gbdy (see bndyc below)
c          or phi (see below) have changed.  this will bypass
c          redundant pde discretization and argument checking
c          and save computational time.  some examples of when
c          intl=1 calls should be used are:
c
c          (0) after a intl=0 argument checking and discretization call
c
c          (1) muh3 is being recalled for additional accuracy.  in
c              this case iguess=iparm(12)=1 should also be used.
c
c          (2) muh3 is being called every time step in a time dependent
c              problem (see discussion below) where the elliptic operator
c              does not depend on time.
c
c          (3) muh3 is being used to solve the same elliptic equation
c              for several different right hand sides (iguess=0 should
c              probably be used for each new righthand side).
c
c          intl = 0 must be input before calling with intl = 1 when any
c          of the following conditions hold:
c
c          (a) the initial call to muh3

c          (b) any of the integer arguments other than iguess=iparm(12)
c              or maxcy=iparm(13) or mgopt have changed since the previous
c              call.
c
c          (c) any of the floating point arguments other than tolmax=
c              fparm(5) have changed since the previous call
c
c          (d) any of the coefficients input by coef (see below) have
c              changed since the previous call
c
c          (e) any of the "alfa" coefficients input by bndyc (see below)
c              have changed since the previous call.
c
c          if any of (a) through (e) are true then the elliptic pde
c          must be discretized or rediscretized.  if none of (a)
c          through (e) holds, calls can be made with intl=1.
c          incorrect calls with intl=1 will produce erroneous results.
c  ***     the values set in the saved work space "wk" (see below) with
c          an intl=0 call must be preserved with subsequent intl=1 calls.
c
c          MUDPACK software performance should be monitored for intl=1
c          calls.  The intl=0 discretization call performance depends
c          primarily on the efficiency or lack of efficiency of the
c          user provided subroutines for pde coefficients and
c          boundary conditions.
c
c
c ... nxa=iparm(2)
c
c          flags boundary conditions on the (y,z) plane x=xa                    
c
c        = 0 if p(x,y,z) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y,z) = p(x,y,z) for all x,y,z)
c
c        = 1 if p(xa,y,z) is specified  (this must be input thru phi(1,j,k))
c
c        = 2 if there are mixed derivative boundary conditions at x=xa
c            (see "bndyc" description below where kbdy = 1)
c
c
c ... nxb=iparm(3)
c
c          flags boundary conditions on the (y,z) plane x=xb                    
c
c        = 0 if p(x,y,z) is periodic in x on [xa,xb]
c            (i.e., p(x+xb-xa,y,z) = p(x,y,z) for all x,y,z)
c
c        = 1 if p(xb,y,z) is specified (this must be input thru phi(nx,j,k))
c
c        = 2 if there are mixed derivative boundary conditions at x=xb
c            (see "bndyc" description below where kbdy = 2)
c
c
c ... nyc=iparm(4)
c
c          flags boundary conditions on the (x,z) plane y=yc                    
c
c        = 0 if p(x,y,z) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc,z) = p(x,y,z) for all x,y,z)

c        = 1 if p(x,yc,z) is specified (this must be input thru phi(i,1,k))

c        = 2 if there are mixed derivative boundary conditions at y=yc
c            (see "bndyc" description below where kbdy = 3)
c
c
c ... nyd=iparm(5)
c
c          flags boundary conditions on the (x,z) plane y=yd                    
c
c        = 0 if p(x,y,z) is periodic in y on [yc,yd]
c            (i.e., p(x,y+yd-yc,z) = p(x,y,z) for all x,y,z)

c        = 1 if p(x,yd,z) is specified (this must be input thru phi(i,ny,k))

c        = 2 if there are mixed derivative boundary conditions at y=yd
c            (see "bndyc" description below where kbdy = 4)
c
c
c ... nze=iparm(6)
c
c          flags boundary conditions on the (x,y) plane z=ze                    
c
c        = 0 if p(x,y,z) is periodic in z on [ze,zf]
c            (i.e., p(x,y,z+zf-ze) = p(x,y,z) for all x,y,z

c        = 1 if p(x,y,ze) is specified (this must be input thru phi(i,j,1))

c        = 2 if there are mixed derivative boundary conditions at z=ze
c            (see "bndyc" description below where kbdy = 5)
c
c
c ... nzf=iparm(7)
c
c          flags boundary conditions on the (x,y) plane z=zf                    
c
c        = 0 if p(x,y,z) is periodic in z on [ze,zf]
c            (i.e., p(x,y,z+zf-ze) = p(x,y,z) for all x,y,z

c        = 1 if p(x,y,zf) is specified (this must be input thru phi(i,j,nz))

c        = 2 if there are mixed derivative boundary conditions at z=zf
c            (see "bndyc" description below where kbdy = 6)
c
c
c *** grid size arguments
c
c
c ... ixp = iparm(8)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the x direction (see nx = iparm(14)).  "ixp+1"
c          is the number of points on the coarsest x grid visited during
c          multigrid cycling.  ixp should be chosen as small as possible
c          within grid size requirements.
c
c
c ... jyq = iparm(9)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the y direction (see ny = iparm(15)).  "jyq+1"
c          is the number of points on the coarsest y grid visited during
c          multigrid cycling.  jyq should be chosen as small as possible
c          within grid size requirements.
c
c
c ... kzr = iparm(10)
c
c          an integer greater than one which is used in defining the number
c          of grid points in the z direction (see nz = iparm(16)).  "kzr+1"
c          is the number of points on the coarsest z grid visited during
c          multigrid cycling.  kzr should be chosen as small as possible
c          within grid size requirements.
c
c
c ... iex = iparm(11)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the x direction (see nx = iparm(14)).
c          iex .le. 50 is required.  for efficient multigrid cycling,
c          iex should be chosen as large as possible and ixp=iparm(8)
c          as small as possible within grid size constraints when
c          defining nx = iparm(14).
c
c
c ... jey = iparm(12)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the y direction (see ny = iparm(15)).
c          jey .le. 50 is required.  for efficient multigrid cycling,
c          jey should be chosen as large as possible and jyq=iparm(9)
c          as small as possible within grid size constraints when
c          defining ny = iparm(15).
c
c
c ... kez = iparm(13)
c
c          a positive integer exponent of 2 used in defining the number
c          of grid points in the z direction (see nz = iparm(16)).
c          kez .le. 50 is required.  for efficient multigrid cycling,
c          kez should be chosen as large as possible and kzr=iparm(10)
c          as small as possible within grid size constraints when
c          defining nz = iparm(16).
c
c
c ... nx = iparm(14)
c
c          the number of equally spaced grid points in the interval [xa,xb]
c          (including the boundaries).  nx must have the form
c
c               nx = ixp*(2**(iex-1)) + 1
c
c          where ixp = iparm(8), iex = iparm(11).
c
c
c ... ny = iparm(15)
c
c          the number of equally spaced grid points in the interval [yc,yd]
c          (including the boundaries).  ny must have the form:
c
c               ny = jyq*(2**(jey-1)) + 1
c
c          where jyq = iparm(9), jey = iparm(12).
c
c
c ... nz = iparm(16)
c
c          the number of equally spaced grid points in the interval [ze,zf]
c          (including the boundaries).  nz must have the form
c
c               nz = kzr*(2**(kez-1)) + 1
c
c          where kzr = iparm(10), kez = iparm(13)
c
c
c *** note
c
c     let g be the nx by ny by nz fine grid on which the approximation is
c     generated and let n = max0(iex,jey,kez).  in mudpack, multigrid
c     cycling is implemented on the ascending chain of grids
c
c         g(1) < ... < g(k) < ... < g(n) = g.
c
c     each g(k) (k=1,...,n) has mx(k) by my(k) by mz(k) grid points
c     given by:
c
c         mx(k) = ixp*[2**(max0(iex+k-n,1)-1)] + 1
c
c         my(k) = jyq*[2**(max0(jey+k-n,1)-1)] + 1
c
c         mz(k) = kzr*[2**(max0(kez+k-n,1)-1)] + 1
c
c     additionally muh3 implements a direct method whenever g(1) is
c     encountered.
c
c ... iguess=iparm(17)
c
c          = 0 if no initial guess to the pde is provided
c              and/or full multigrid cycling beginning at the
c              coarsest grid level is desired.
c
c          = 1 if an initial guess to the pde at the finest grid
c              level is provided in phi (see below).  in this case
c              cycling beginning or restarting at the finest grid
c              is initiated.
c
c *** comments on iguess = 0 or 1 . . .
c
c
c     setting iguess=0 forces full multigrid or "fmg" cycling.  phi
c     must be initialized at all grid points.  it can be set to zero at
c     non-Dirchlet grid points if nothing better is available.
c
c     if iguess = 1 then the values input in phi are an initial guess to the
c     pde at the finest grid level where cycling begins.  this option should
c     be used only if a "very good" initial guess is available (as, for
c     example, when restarting from a previous iguess=0 call).
c
c *** time dependent problems . . .
c
c     assume we are solving an elliptic pde every time step in a
c     marching problem of the form:
c
c          l(p(t)) = r(t)
c
c     where the differential operator "l" has no time dependence,
c     "p(t)" is the solution and "r(t)" is the right hand side at
c     current time "t". let "dt" be the increment between time steps.
c     then p(t) can be used as an initial guess to p(t+dt) with
c     intl = 1 when solving
c
c          l(p(t+dt)) = r(t+dt).
c
c     after the first two time steps, rather than continue, it would
c     be better to define the "correction" term:
c
c          e(t,dt) = p(t+dt) - p(t)
c
c     this clearly satisfies the equation
c
c          l(e(t,dt)) = r(t+dt) - r(t).
c
c     this should be solved with iguess = 0 and intl = 1. boundary
c     conditions for e(t,dt) are obtained from the boundary conditions
c     for p(t) by subtracting given values at t from given values at
c     t+dt. for example if
c
c          d(p(t))/dx = f(t), d(p(t+dt))/dx = f(t+dt)
c
c     at some x boundary then e(t,dt) satisfies the derivative
c     boundary condition
c
c          d(e(t,dt))/dx = f(t+dt) - f(t).
c
c     e(t,dt) can be preset to 0.0 (at non-Dirchlet points) or (if p(t-dt)
c     is saved) to p(t)-p(t-dt).  with iguess = 0, these values will serve
c     as an initial guess to e(t,dt) at the coarsest grid level.  this
c     approach has the advantage that a full sequence of multigrid cycles,
c     beginning at the coarsest grid level, is invoked every time step in
c     solving for e(t,dt).  a few digits of accuracy in e(t,dt), which is
c     ordinarily much smaller than p(t), will yield several more digits of
c     accuracy in the final approximation:
c
c          p(t+dt) = p(t) + e(t,dt).
c
c     using this approach to integrate in time will give more accuracy
c     then using p(t) as an initial guess to p(t+dt) for all time steps.
c     it does require additional storage.
c
c     if the differential operator "l" has time dependence (either thru
c     the coefficients in the pde or the coefficients in the derivative
c     boundary conditions) then use p(t) as an initial guess to p(t+dt)
c     when solving
c
c          l(t+dt)(p(t+dt)) = r(t+dt)
c
c     with intl = 0 for all time steps (the discretization must be repeated
c     for each new "t"). either iguess = 0 (p(t) will then be an initial
c     guess at the coarsest grid level where cycles will commence) or
c     iguess = 1 (p(t) will then be an initial guess at the finest grid
c     level where cycles will remain fixed) can be tried.
c
c
c ... maxcy = iparm(18)
c
c          the exact number of cycles executed between the finest
c          (nx by ny by nz) and the coarsest ((ixp+1) by (jyq+1) by
c          (kzr+1)) grid levels when tolmax=fparm(7)=0.0 (no error
c          control). when tolmax=fparm(7).gt.0.0 is input (error control)
c          then maxcy is a limit on the number of cycles between the
c          finest and coarsest grid levels.  in any case, at most
c          maxcy*(iprer+ipost) relaxation sweeps are performed at the
c          finest grid level (see iprer=mgopt(2),ipost=mgopt(3) below)
c          when multigrid iteration is working "correctly" only a few
c          cycles are required for convergence.  large values for maxcy
c          should not be required.
c
c
c ... method = iparm(19)
c
c          this sets the method of relaxation (all relaxation
c          schemes in mudpack use red/black type ordering)
c
c          = 0 for gauss-seidel pointwise relaxation
c
c          = 1 for line relaxation in the x direction
c
c          = 2 for line relaxation in the y direction
c
c          = 3 for line relaxation in the z direction
c
c          = 4 for line relaxation in the x and y direction
c
c          = 5 for line relaxation in the x and z direction
c
c          = 6 for line relaxation in the y and z direction
c
c          = 7 for line relaxation in the x,y and z direction
c
c          = 8 for x,y planar relaxation
c
c          = 9 for x,z planar relaxation
c
c          =10 for y,z planar relaxation
c
c ***  choice of method
c
c      this is very important for efficient convergence.  in some cases
c      experimentation may be required.
c
c      let fx represent the quantity cxx(x,y,z)/dlx**2 over the solution box
c
c      let fy represent the quantity cyy(x,y,z)/dly**2 over the solution box
c
c      let fz represent the quantity czz(x,y,z)/dlz**2 over the solution box
c
c      (0) if fx,fy,fz are roughly the same size and do not vary too
c          much choose method = 0.  if this fails try method = 7.
c
c      (1) if fx is much greater then fy,fz and fy,fz are roughly the same
c          size choose method = 1
c
c      (2) if fy is much greater then fx,fz and fx,fz are roughly the same
c          size choose method = 2
c
c      (3) if fz is much greater then fx,fy and fx,fy are roughly the same
c          size choose method = 3
c
c      (4) if fx,fy are roughly the same and both are much greater then fz
c          try method = 4.  if this fails try method = 8
c
c      (5) if fx,fz are roughly the same and both are much greater then fy
c          try method = 5.  if this fails try method = 9
c
c      (6) if fy,fz are roughly the same and both are much greater then fx
c          try method = 6.  if this fails try method = 10
c
c      (7) if fx,fy,fz vary considerably with none dominating try method = 7
c
c      (8) if fx and fy are considerably greater then fz but not necessarily
c          the same size and method=4 fails try method = 8
c
c      (9) if fx and fz are considerably greater then fy but not necessarily
c          the same size and method=5 fails try method = 9
c
c      (10)if fy and fz are considerably greater then fx but not necessarily
c          the same size and method=6 fails try method = 10
c
c
c ... meth2 = iparm(20) determines the method of relaxation used in the planes
c             when method = 8 or 9 or 10.
c
c
c          as above, let fx,fy,fz represent the quantities cxx/dlx**2,
c          cyy/dly**2,czz/dlz**2 over the box.
c
c          (if method = 8)
c
c          = 0 for gauss-seidel pointwise relaxation
c              in the x,y plane for each fixed z
c          = 1 for line relaxation in the x direction
c              in the x,y plane for each fixed z
c          = 2 for line relaxation in the y direction
c              in the x,y plane for each fixed z
c          = 3 for line relaxation in the x and y direction
c              in the x,y plane for each fixed z
c
c          (1) if fx,fy are roughly the same and vary little choose meth2 = 0
c          (2) if fx is much greater then fy choose meth2 = 1
c          (3) if fy is much greater then fx choose meth2 = 2
c          (4) if none of the above or meth2 = 0 fails choose meth2 = 3
c
c          (if method = 9)
c
c          = 0 for gauss-seidel pointwise relaxation with red/black ordering
c              in the x,z plane for each fixed y
c          = 1 for simultaneous line relaxation in the x direction
c              of the x,z plane for each fixed y
c          = 2 for simultaneous line relaxation in the z direction
c              of the x,z plane for each fixed y
c          = 3 for simultaneous line relaxation in the x and z direction
c              of the x,z plane for each fixed y
c
c          (1) if fx,fz are roughly the same and vary little choose meth2 = 0
c          (2) if fx is much greater then fz choose meth2 = 1
c          (3) if fz is much greater then fx choose meth2 = 2
c          (4) if none of the above or meth2 = 0 fails choose meth2 = 3
c
c          (if method = 10)
c
c          = 0 for gauss-seidel pointwise relaxation with red/black ordering
c              in the y,z plane for each fixed x
c          = 1 for simultaneous line relaxation in the y direction
c              of the y,z plane for each fixed x
c          = 2 for simultaneous line relaxation in the z direction
c              of the y,z plane for each fixed x
c          = 3 for simultaneous line relaxation in the y and z direction
c              of the y,z plane for each fixed x
c
c          (1) if fy,fz are roughly the same and vary little choose meth2 = 0
c          (2) if fy is much greater then fz choose meth2 = 1
c          (3) if fz is much greater then fy choose meth2 = 2
c          (4) if none of the above or meth2 = 0 fails choose meth2 = 3
c
c
c ***  note that planar relaxation implements full two-dimensional multigrid
c      cycling for each plane visited during three dimensional multigrid
c      cycling.  Consequently it can be computationally expensive.
c
c ... length = iparm(21)
c
c          the length of the work space provided in vector wk.
c
c          let isx = 3 if method = 1,4,5 or 7 and nxa.ne.0
c          let isx = 5 if method = 1,4,5 or 7 and nxa.eq.0
c          let isx = 0 if method has any other value
c
c          let jsy = 3 if method = 2,4,6 or 7 and nyc.ne.0
c          let jsy = 5 if method = 2,4,6 or 7 and nyc.eq.0
c          let jsy = 0 if method has any other value
c
c          let ksz = 3 if method = 3,5,6 or 7 and nze.ne.0
c          let ksz = 5 if method = 3,5,6 or 7 and nze.eq.0
c          let ksz = 0 if method has any other value
c
c
c
c          let ls = (nx+2)*(ny+2)*(nz+2)*(10+isx+jsy+ksz)
c
c          let mx = ixp+1; my = jyq+1; mz = kzr+1.  the block gaussian
c          elimination at the coarsest mx by my by mz grid level requires
c
c             ld = mx*my*mz*(2*mx*my+1))           (nze.ne.0)
c
c          words of storage if z boundary conditions are not periodic or
c
c             ld = mx*my*(mz*(4*mx*my+1))          (nze=0)
c
c          words of storage if z boundary conditions are periodic.
c          if ixp,jyq,kzr are not the same, this quantity is
c          minimized if they are chosen so that kzr > max0(ixp,jyq).
c
c          finally
c
c             length = ls + ld

c          will usually but not always suffice.  the exact minimal length depends,
c          in a complex way, on the grid size arguments and method chosen.
c  ***     it can be predetermined for the current input arguments by calling
c          muh3 with length=iparm(21)=0 and printing iparm(22) or (in f90)
c          dynamically allocating the work space using the value in iparm(22)
c          in a subsequent muh3 call.
c
c ... fparm                                                                     
c
c          a floating point vector of length 8 used to efficiently
c          pass floating point arguments.  fparm is set internally
c          in muh3 and defined as follows . . .
c
c
c ... xa=fparm(1), xb=fparm(2)
c
c          the range of the x independent variable. xa must                     
c          be less than xb                                                      
c
c
c ... yc=fparm(3), yd=fparm(4)
c
c          the range of the y independent variable.  yc must                    
c          be less than yd.                                                     
c
c
c ... ze=fparm(5), zf=fparm(6)
c
c          the range of the z independent variable. ze must                     
c          be less than zf.                                                     
c
c
c ... tolmax = fparm(7)
c
c          when input positive, tolmax is a maximum relative error tolerance
c          used to terminate the relaxation iterations. assume phi1(i,j,k)
c          and phi2(i,j,k) are the last two computed approximations at all
c          grid points of the finest grid level. if we define
c
c              phdif = max(abs(phi2(i,j,k)-phi1(i,j,k))) for all i,j,k
c
c          and
c
c              phmax = max(abs(phi2(i,j,k))) for all i,j,k
c
c          then "convergence" is considered to have occurred if and only if
c
c              phdif/phmax < tolmax.
c
c
c          if tolmax=fparm(7)=0.0 is input then there is no error control
c          and maxcy cycles from the finest grid level are executed. maxcy
c          is a limit which cannot be exceeded even with error control.
c     ***  calls with tolmax=0.0, when appropriate because of known
c          convergence behavior, are more efficient than calls with tolmax
c          positive (i.e., if possible DO NOT use error control!).
c
c
c ... wk
c
c          a one dimensional array that must be provided for work space.        
c          see length = iparm(21). the values in wk must be preserved
c          if muh3 is called again with intl=iparm(1).ne.0 or if muh34
c          is called to improve accuracy.
c
c
c ... iwk
c
c          an integer vector dimensioned of length at least
c
c             (ixp+1)*(jyq+1)*(kzr+1)
c
c          in the routine calling muh3. the length of iwk is not
c          checked!  if iwk has length too small then undetectable
c          undetectable errors will result.
c
c
c ... bndyc                                                                     
c
c          a subroutine with arguments (kbdy,xory,yorz,alfa,gbdy).
c          which are used to input mixed boundary conditions to muh3.
c          the boundaries are numbered one thru six and the form of
c          conditions are described below.
c                                                                               
c
c     (1) the kbdy=1 boundary
c
c     this is the (y,z) plane x=xa where nxa=iparm(2) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dx + alfxa(y,z)*p(xa,y,z) = gbdxa(y,z)
c
c     in this case kbdy=1,xory=y,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfxa(y,z),gbdxa(y,z) must be returned.
c
c
c     (2) the kbdy=2 boundary
c
c     this is the (y,z) plane x=xb where nxb=iparm(3) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dx + alfxb(y,z)*p(xb,y,z) = gbdxb(y,z)
c
c     in this case kbdy=2,xory=y,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfxb(y,z),gbdxb(y,z) must be returned.
c
c
c     (3) the kbdy=3 boundary
c
c     this is the (x,z) plane y=yc where nyc=iparm(4) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dy + alfyc(x,z)*p(x,yc,z) = gbdyc(x,z)
c
c     in this case kbdy=3,xory=x,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfyc(x,z),gbdyc(x,z) must be returned.
c
c
c     (4) the kbdy=4 boundary
c
c     this is the (x,z) plane y=yd where nyd=iparm(5) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dy + alfyd(x,z)*p(x,yd,z) = gbdyd(x,z)
c
c     in this case kbdy=4,xory=x,yorz=z will be input to bndyc and
c     alfa,gbdy corresponding to alfyd(x,z),gbdyd(x,z) must be returned.
c
c                                                                               
c     (5) the kbdy=5 boundary
c
c     this is the (x,y) plane z=ze where nze=iparm(6) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dz + alfze(x,y)*p(x,y,ze) = gbdze(x,y)
c
c     in this case kbdy=5,xory=x,yorz=y will be input to bndyc and
c     alfa,gbdy corresponding to alfze(x,y),gbdze(x,y) must be returned.
c
c
c     (6) the kbdy=6 boundary
c
c     this is the (x,y) plane z=zf where nzf=iparm(7) = 2 flags
c     a mixed boundary condition of the form
c
c        dp/dz + alfzf(x,y)*p(x,y,zf) = gbdzf(x,y)
c
c     in this case kbdy=6,xory=x,yorz=y will be input to bndyc and
c     alfa,gbdy corresponding to alfzf(x,y),gbdzf(x,y) must be returned.
c
c                                                                               
c *** alfxa,alfyc,alfze nonpositive and alfxb,alfyd,alfze nonnegative
c     will help maintain matrix diagonal dominance during discretization
c     aiding convergence.
c
c *** bndyc must provide the mixed boundary condition
c     values in correspondence with those flagged in iparm(2)
c     thru iparm(7).  if all boundaries are specified then
c     muh3 will never call bndyc.  even then it must be entered
c     as a dummy subroutine. bndyc must be declared
c     external in the routine calling muh3.  the actual
c     name chosen may be different.
c
c
c ... coef
c
c         a subroutine with arguments (x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
c         which provides the known real coefficients for the elliptic pde
c         at any grid point (x,y,z).  the name chosen in the calling routine
c         may be different where the coefficient routine must be declared
c         external.
c
c ... rhs                                                                       
c
c          an array dimensioned nx by ny by nz which contains
c          the given right hand side values on the uniform 3-d mesh.            
c          rhs(i,j,k) = r(xi,yj,zk) for i=1,...,nx and j=1,...,ny               
c          and k=1,...,nz.
c
c ... phi                                                                       
c
c          an array dimensioned nx by ny by nz .  on input phi must
c          contain specified boundary values and an initial guess
c          to the solution if flagged (see iguess=iparm(17)=1).  for
c          example, if nyd=iparm(5)=1 then phi(i,ny,k) must be set
c          equal to p(xi,yd,zk) for i=1,...,nx and k=1,...,nz prior to
c          calling muh3.  the specified values are preserved by muh3.
c
c ***      if no initial guess is given (iguess=0) then phi must still
c          be initialized at non-Dirchlet grid points (this is not
c          checked). these values are projected down and serve as an initial
c          guess to the pde at the coarsest grid level.  set phi to 0.0 at
c          nonDirchlet grid points if nothing better is available.
c
c
c ... mgopt
c
c           an integer vector of length 4 which allows the user to select
c           among various multigrid options.  if mgopt(1)=0 is input then
c           a default set of multigrid arguments (chosen for robustness)
c           will be internally selected and the remaining values in mgopt
c           will be ignored.  if mgopt(1) is nonzero then the arguments
c           in mgopt are set internally and defined as follows:  (see the
c           basic coarse grid correction algorithm below)
c
c
c     kcycle = mgopt(1)
c
c            = 0 if default multigrid options are to be used
c
c            = 1 if v cycling is to be used (the least expensive per cycle)
c
c            = 2 if w cycling is to be used (the default)
c
c            > 2 if more general k cycling is to be used
c             *** warning--values larger than 2 increase
c                 the execution time per cycle considerably and
c                 result in the nonfatal error ierror = -5
c                 which indicates inefficient multigrid cycling.
c
c    iprer = mgopt(2)
c
c           the number of "pre-relaxation" sweeps executed before the
c           residual is restricted and cycling is invoked at the next
c           coarser grid level (default value is 2 whenever mgopt(1)=0)
c
c    ipost = mgopt(3)
c
c           the number of "post relaxation" sweeps executed after cycling
c           has been invoked at the next coarser grid level and the residual
c           correction has been transferred back (default value is 1
c           whenever mgopt(1)=0).
c
c *** if iprer, ipost, or (especially) kcycle is greater than 2
c     than inefficient multigrid cycling has probably been chosen and
c     the nonfatal error (see below) ierror = -5 will be set.  note
c     this warning may be overridden by any other nonzero value
c     for ierror.
c
c   intpol = mgopt(4)
c
c          = 1 if multilinear prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c
c          = 3 if multicubic prolongation (interpolation) is used to
c              transfer residual corrections and the pde approximation
c              from coarse to fine grids within full multigrid cycling.
c              (this is the default value whenever mgopt(1)=0).
c
c *** the default values (2,2,1,3) in the vector mgopt were chosen for
c     robustness.  in some cases v(2,1) cycles with linear prolongation will
c     give good results with less computation (especially in two-dimensions).
c     this  was the default and only choice in an earlier version of mudpack
c     (see [1]) and can be set with the integer vector (1,2,1,1) in mgopt.
c
c *** the schedules for one full multigrid cycle (iguess=0) using v(2,1)
c     cycles and w(2,1) cycles are depicted for a four level grid below.
c     the number of relaxation sweeps when each grid is visited are indicated.
c     the "*" stands for prolongation of the full approximation and the "."
c     stands for transfer of residuals and residual corrections within the
c     coarse grid correction algorithm (see below).  the "d" at level 1
c     indicates a direct method is used
c
c     one fmg with v(2,1) cycles:
c
c
c     ------------------------------2-----------------1------     level 4
c                                  * .               .
c                                 *   .             .
c     ---------------2-----------1-----2-----------1---------     level 3
c                   * .         .       .         .
c                  *   .       .         .       .
c     ------2-----1-----2-----1-----------2-----1------------     level 2
c          * .   .       .   .             .   .
c         *   . .         . .               . .
c     ---d-----d-----------d-----------------d---------------     level 1
c
c
c     one fmg with w(2,1) cycles:
c
c     ------------------------2---------------------------1--     level 4
c                            * .                         .
c     ----------2-----------1---2-----------3-----------1----     level 3
c              * .         .     .         . .         .
c     ----2---1---2---3---1-------2---3---1---2---3---1------     level 2
c        * . .     . . . .         . . . .     . . . .
c     --d---d-------d---d-----------d---d-------d---d--------     level 1
c
c
c     the form of the "recursive" coarse grid correction cycling used
c     when kcycle.ge.0 is input is described below in pseudo-algorithmic
c     language.  it is implemented non-recursively in fortran in mudpack.
c *** this algorithim is modified with the hybrid solvers which use
c     a direct method whenever grid level 1 is encountered.
c
c     algorithm cgc(k,l(k),u(k),r(k),kcycle,iprer,ipost,iresw,intpol)
c
c *** approximately solve l(k)*u(k) = r(k) using multigrid iteration
c *** k is the current grid level
c *** l(k) is the discretized pde operator at level k
c *** u(k) is the initial guess at level k
c *** r(k) is the right hand side at level k
c *** i(k,k-1) is the restriction operator from level k to level k-1
c *** (the form of i(k,k-1) depends on iresw)
c *** i(k-1,k) is the prolongation operator from level k-1 to level k
c *** (the form of i(k-1,k) depends on intpol)
c
c     begin algorithm cgc
c
c ***   pre-relax at level k
c
c     . do (i=1,iprer)
c
c     . .  relax(l(k),u(k),r(k))
c
c     . end do
c
c     . if (k > 1) then
c
c ***     restrict the residual from level k to level k-1
c
c     . . r(k-1) = i(k,k-1)(r(k)-l(k)*u(k))
c
c     . . kount = 0
c
c     . . repeat
c
c ***     solve for the residual correction at level k-1 in u(k-1)
c ***     using algorithm cgc "kcycle" times (this is the recursion)
c
c     . . . kount = kount+1
c
c     . . . invoke cgc(k-1,l(k-1),u(k-1),r(k-1),kcycle,iprer,ipost,iresw)
c
c
c     . . until (kount.eq.kcycle)
c
c ***     transfer residual correction in u(k-1) to level k
c ***     with the prolongation operator and add to u(k)
c
c     . . u(k) = u(k) + i(k-1,k)(u(k-1))
c
c     . end if
c
c ***   post relax at level k
c
c     . do (i=1,ipost)
c
c     . . relax(l(k),u(k),r(k))
c
c     . end do
c
c     . return
c
c     end algorithm cgc
c
c ***********************************************************************
c ****output arguments**************************************************
c ***********************************************************************
c
c
c ... iparm(22)
c
c          on output iparm(22) contains the actual work space length
c          required for the current grid sizes and method.  this value
c          will be computed and returned even if iparm(21) is less then
c          iparm(22) (see ierror=9).
c
c
c ... iparm(23)
c
c          if error control is selected (tolmax = fparm(7) .gt. 0.0) then
c          on output iparm(23) contains the actual number of cycles executed
c          between the coarsest and finest grid levels in obtaining the
c          approximation in phi.  the quantity (iprer+ipost)*iparm(23) is
c          the number of relaxation sweeps performed at the finest grid level.
c
c
c ... fparm(8)                                                                  
c
c          on output fparm(8) contains the final computed maximum relative
c          difference between the last two iterates at the finest grid level.
c          fparm(8) is computed only if there is error control (tolmax.gt.0.)
c          assume phi1(i,j,k) and phi2(i,j,k) are the last two computed
c          values for phi(i,j,k) at all points of the finest grid level.
c          if we define
c
c             phdif = max(abs(phi2(i,j,k)-phi1(i,j,k))) for all i,j,k
c
c          and
c
c             phmax = max(abs(phi2(i,j,k))) for all i,j,k
c
c          then
c
c             fparm(8) = phdif/phmax
c
c          is returned whenever phmax.gt.0.0.  in the degenerate case
c          phmax = 0.0, fparm(8) = phdif is returned.
c
c
c
c ... wk
c
c          on output wk contains intermediate values that must not be
c          destroyed if muh3 is to be called again with iparm(1)=1 or
c          if muh34 is to be called to improve the estimate to fourth
c          order.
c
c ... phi
c
c          on output phi(i,j,k) contains the approximation to
c          p(xi,yj,zk) for all mesh points i=1,...,nx; j=1,...,ny;
c          k=1,...,nz.  the last computed iterate in phi is returned
c          even if convergence is not obtained (ierror=-1)
c
c ... ierror
c
c          for intl=iparm(1)=0 initialization calls, ierror is an
c          error flag that indicates invalid input arguments when
c          returned positive and nonfatal warnings when returned
c          negative.  argument checking and discretization
c          is bypassed for intl=1 calls which can only return
c          ierror = -1 or 0 or 1.
c
c
c     non-fatal warnings * * *
c
c
c     =-5 if kcycle=mgopt(1) is greater than 2. values larger than 2 results
c         in an algorithm which probably does far more computation than
c         necessary.  kcycle = 1 (v cycles)  or kcycle=2 (w cycles) should
c         suffice for most problems.  ierror = -5 is also set if either
c         iprer = mgopt(2) or ipost=mgopt(3) is greater than 2.  the
c         ierror=-5 flag is overridden by any other fatal or non-fatal
c         error.
c
c     =-4 if there are dominant nonzero first order terms in the pde which
c         make it "hyperbolic" at the finest grid level. numerically, this
c         happens if:
c
c              abs(cx)*dlx > 2.*abs(cxx)   (dlx = (xb-xa)/(nx-1))
c
c                         (or)
c
c              abs(cy)*dly > 2.*abs(cyy)   (dly = (yd-yc)/(ny-1))
c
c
c         at some fine grid point (xi,yj).  if an adjustment is not made the
c         condition can lead to a matrix coming from the discretization
c         which is not diagonally dominant and divergence is possible. since
c         the condition is "likely" at coarser grid levels for pde's with
c         nonzero first order terms, the adjustments (actually first order
c         approximations to the pde)
c
c
c             cxx = amax1(cxx,0.5*abs(cx)*dx)
c
c                          (and)
c
c             cyy = amax1(cyy,0.5*abs(cy)*dy)
c
c
c         (here dx,dy are the x,y mesh sizes of the subgrid)
c
c         are made to preserve convergence of multigrid iteration. if made
c         at the finest grid level, it can lead to convergence to an
c         erroneous solution (flagged by ierror = -4).  a possible remedy
c         is to increase resolution. the ierror = -4 flag overrides the
c         nonfatal ierror = -5 flag.
c
c
c     =-3  if the continuous elliptic pde is singular.  this means the
c          boundary conditions are periodic or pure derivative at all
c          boundaries and ce(x,y) = 0.0 for all x,y.  a solution is still
c          attempted but convergence may not occur due to ill-conditioning
c          of the linear system coming from the discretization.  the
c          ierror = -3 flag overrides the ierror=-4 and ierror=-5 nonfatal
c          flags.
c
c
c     =-2  if the pde is not elliptic (i.e., cxx*cyy.le.0.0 for some (xi,yj))
c          in this case a solution is still attempted although convergence
c          may not occur due to ill-conditioning of the linear system.
c          the ierror = -2 flag overrides the ierror=-5,-4,-3 nonfatal
c          flags.
c
c
c     =-1  if convergence to the tolerance specified in tolmax=fparm(5)>0.
c          is not obtained in maxcy=iparm(13) multigrid cycles between the
c          coarsest (ixp+1,jyq+1) and finest (nx,ny) grid levels.
c          in this case the last computed iterate is still returned.
c          the ierror = -1 flag overrides all other nonfatal flags
c
c
c     no errors * * *
c
c     = 0
c
c     fatal argument errors * * *
c
c     = 1 if intl=iparm(1) is not 0 on initial call or not 0 or 1
c         on subsequent calls
c
c     = 2 if any of the boundary condition flags nxa,nxb,nyc,nyd,nze,nzf
c         in iparm(2) through iparm(7)is not 0,1 or 2 or if
c         (nxa,nxb) or (nyc,nyd) or (nze,nzf) are not pairwise zero.
c
c     = 3 if mino(ixp,jyq,kzr) < 2 (ixp=iparm(8),jyq=iparm(9),kzr=iparm(10))
c         or if ixp<3 when nxa=0 or jyq<3 when nyc=0 or kzr<3 when nze=0.
c
c     = 4 if min0(iex,jey,kez) < 1 (iex=iparm(11),jey=iparm(12),kez=iparm(13))
c         or if max0(iex,jey,kez) > 50
c
c     = 5 if nx.ne.ixp*2**(iex-1)+1 or if ny.ne.jyq*2**(jey-1)+1 or
c         if nz.ne.kzr*2**(kez-1)+1 (nx=iparm(14),ny=iparm(15),nz=iparm(16))
c
c     = 6 if iguess = iparm(17) is not equal to 0 or 1
c
c     = 7 if maxcy = iparm(18) < 1 (large values for maxcy should not be used)
c
c     = 8 if method = iparm(19) is less than 0 or greater than 10
c
c     = 9 if length = iparm(20) is too small (see iparm(21) on output
c         for minimum required work space length)
c
c     =10 if xa > xb or yc > yd or ze > zf
c         (xa=fparm(1),xb=fparm(2),yc=fparm(3),yd=fparm(4),ze=fparm(5),zf=fparm(6))
c
c     =11 if tolmax = fparm(7) < 0.0
c
c     errors in setting multigrid options * * * (see also ierror=-5)
c
c     =12 if kcycle = mgopt(1) < 0 or
c         if iprer = mgopt(2) < 1 or
c         if ipost = mgopt(3) < 1 or
c         if intpol = mgopt(4) is not 1 or 3
c
c     =13 if iex=jey=kez=1 (full direct method) and iguess=1 or maxcy > 1
c
c     =14 if the elliptic pde is singular (see ierror=-3 in mud3.d)
c
c
c *********************************************************
c *********************************************************
c
c     end of muh3 documentation
c
c **********************************************************
c **********************************************************
c
c
</PRE>
<HR>
 
<a name="muh34.txt"><b>MUH34</b></a>
<PRE>
c
c     file muh34.d
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... file muh34.d
c
c     contains documentation for:
c     subroutine muh34(wk,iwk,phi,ierror)
c     A sample fortran driver is file "tmuh34.f".
c
c ... required MUDPACK files
c
c     muh3.f, mudcom.f,mud3ln.f, mud3pn.f
c
c ... purpose
c
c     muh34 attempts to improve the estimate in phi, obtained by calling
c     muh3,  from second to fourth order accuracy.  see the file "muh3.d"
c     for a detailed discussion of the elliptic pde approximated and
c     arguments "wk,iwk,phi" which are also part of the argument list for
c     muh3.
c
c ... assumptions
c
c     *  phi contains a second-order approximation from an earlier muh3 call
c
c     *  arguments "wk,iwk,phi" are the same used in calling muh3
c
c     *  "wk,iwk,phi" have not changed since the last call to muh3
c
c     *  the finest grid level contains at least 6 points in each direction
c
c
c *** warning
c
c     if the first assumption is not true then a fourth order approximation
c     cannot be produced in phi.  the last assumption (adequate grid size)
c     is the only one checked. failure in any of the others can result in
c     in an undetectable error.
c
c ... language                                                                  
c
c     fortran90/fortran77
c
c ... portability                                                               
c
c     mudpack5.0.1 software has been compiled and tested with fortran77
c     and fortran90 on a variety of platforms.
c                                                                               
c ... methods
c
c     details of the methods employeed by the solvers in mudpack are given
c     in [1,9].  [1,2,9] contain performance measurements on a variety of
c     elliptic pdes (see "references" in the file "readme").  in summary:
c
c
c *** higher order solution (fourth-order solvers) (see [9,19,21])
c
c     if the multigrid cycling results in a second-order estimate (i.e.,
c     discretization level error is reached) then this can be improved to a
c     fourth-order estimate using the technique of "deferred corrections"
c     the values in the solution array are used to generate a fourth-order
c     approximation to the truncation error.  second-order finite difference
c     formula are used to approximate third and fourth partial derivatives
c     of the solution function [3].  the truncation error estimate is
c     transferred down to all grid levels using weighted averaging where
c     it serves as a new right hand side.  the default multigrid options
c     are used to compute the fourth-order correction term which is added
c     to the original solution array.
c
c
c ... references (partial)
c
c
c     [1] J. Adams, "MUDPACK: Multigrid Fortran Software for the Efficient
c     Solution of Linear Elliptic Partial Differential Equations,"
c     Applied Math. and Comput. vol.34, Nov 1989, pp.113-146.
c
c     [2] J. Adams,"FMG Results with the Multigrid Software Package MUDPACK,"
c     proceedings of the fourth Copper Mountain Conference on Multigrid, SIAM,
c     1989, pp.1-12.
c     .
c     .
c     .
c     [7] J. Adams, R. Garcia, B. Gross, J. Hack, D. Haidvogel, and V. Pizzo,
c     "Applications of Multigrid Software in the Atmospheric Sciences,"
c      Mon. Wea. Rev.,vol. 120 # 7, July 1992, pp. 1447-1458.
c     .
c     .
c     .
c     [9] J. Adams, "Recent Enhancements in MUDPACK, a Multigrid Software
c     package for Elliptic Partial Differential Equations," Applied Math.
c     and Comp., 1991, vol. 43, May 1991, pp. 79-94.
c
c     [10]J. Adams, "MUDPACK-2: Multigrid Software for Approximating
c     Elliptic Partial Differential Equations on Uniform Grids with
c     any Resolution," Applied Math. and Comp., 1993, vol. 53, February
c     1993, pp. 235-249
c     .
c     .
c     .
c
c ... error parameter
c
c     = 0 if no error is detected
c
c     = 30 if min0(nx,ny,nz) < 6 where nx,ny,nz are the fine grid sizes
c          in the x,y,z directions.
c                                                                               
c
c  ***********************************************************************
c  ***********************************************************************
c
c     end of muh34 documentation
c
c  ***********************************************************************
c  ***********************************************************************
c
</PRE>
<HR>
 
<a name="resc2.txt"><b>RESC2</b></a>
<PRE>
c
c     file resc2.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     subroutine resc2(nx,ny,work,res)
c
c
c ... purpose
c
c
c     subroutine resc2 computes the fine grid residual in the nx by ny array
c     res after calling cud2 or cuh2 or cud2sa.  if
c
c          L * p = f
c
c     is the n by n (n = nx*ny) block tri-diagonal linear system resulting
c     from the pde discretization (done internally in the mudpack solver)
c     then resc2 computes the nx by ny residual array
c
c          res = f - L * p
c
c     one of the vector norms of res,
c
c          || res ||
c
c     can be computed as a "measure" of how well the approximation satisfies
c     the discretization equations.
c
c *** please note:
c
c          let pe be the exact continuous solution to the elliptic pde
c          evaluated on the nx by ny discretization grid
c
c          let p be the exact solution to the linear discretization
c
c          let phi be the approximation to p generated by the mudpack solver
c
c     then discretization level error is defined by the condition
c
c          || phi - p || < || p - pe ||.
c                        =
c
c     a common measure of multigrid efficieny is that discretization level
c     error is reached in one full multigrid cycle (see references [2,9] in
c     the mudpack file "readme").  this can happen before the residual is
c     reduced to the level of roundoff error.  consequently, || res || is
c     a conservative measure of accuracy which can be wasteful if multi-
c     grid cycles are executed until it reaches the level of roundoff error.
c
c     || res || can be used to estimate the convergence rate of multigrid
c     iteration.  let r(n) be the residual and e(n) be the error after
c     executing n cycles.  they are related by the residual equation
c
c          L * e(n) = r(n).
c
c     it follows that the ratio
c
c          || r(n+1) || / || r(n) ||
c
c     estimates
c
c          || e(n+1) || / || e(n) ||
c
c     which in turn estimates the convergence rate
c
c          c = max || e(k+1) || / || e(k) ||.
c               k
c
c     notice
c                         n
c          || e(n) || <  c  || e(0) ||.
c
c
c ... assumptions (see cud2.d or cuh2.d or cud2sa.d)
c
c     (1) nx,ny have the same values as iparm(10),iparm(11) (used
c         to set the fine grid resolution)
c
c     (2) work is the same argument used in calling the solver.
c
c     (3) work have not changed since the last call to the solver.
c
c     (3) assures a copy of the last approximation phi is contained in work.
c     if these assumptions are not true then resc2 cannot compute the
c     residual in res.
c
      subroutine resc2(nx,ny,work,res)
      implicit none
      integer nx,ny,ic
      complex work(*),res(nx,ny)
c
c     set approximation and coefficient pointers
c
      ic = 1+(nx+2)*(ny+2)
      call rec2(nx,ny,work,work(ic),res)
      return
      end

      subroutine rec2(nx,ny,phi,cof,res)
      implicit none
      integer nx,ny,i,j
      complex phi(0:nx+1,0:ny+1),cof(nx,ny,6),res(nx,ny)
c
c     compute residual over entire x,y grid
c
      do j=1,ny
	do i=1,nx
	  res(i,j) =  cof(i,j,6)-(
     +                cof(i,j,1)*phi(i-1,j)+
     +                cof(i,j,2)*phi(i+1,j)+
     +                cof(i,j,3)*phi(i,j-1)+
     +                cof(i,j,4)*phi(i,j+1)+
     +                cof(i,j,5)*phi(i,j))
	end do
      end do
      return
      end
</PRE>
<HR>
 
<a name="resc2cr.txt"><b>RESC2CR</b></a>
<PRE>
c
c     file resc2cr.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     subroutine resc2cr(nx,ny,work,res)
c
c ... purpose
c
c
c     subroutine resc2cr computes the fine grid residual in the nx by ny array
c     res after calling cud2cr or cuh2cr.  if
c
c          l * p = f
c
c     is the n by n (n = nx*ny) block tri-diagonal linear system resulting
c     from the pde discretization (done internally in cud2cr or cuh2cr) and
c     phi is the approximation to p obtained by calling cud2cr or cuh2cr,
c     then resc2cr computes the nx by ny residual array
c
c          res = f - l * phi.
c
c     one of the vector norms of res,
c
c          || res ||
c
c     can be computed as a "measure" of how well phi satisfies the
c     discretization equations.  for example, the following statements
c     will compute the location and size of the maximum residual in res
c     on cray computers:
c
c          ij = isamax(nx*ny,res,1)
c
c          jmax = (ij-1)/nx + 1
c
c          imax = ij - (jmax-1)*nx
c
c          resmax = abs(res(imax,jmax))
c
c
c *** please note:
c
c          let pe be the exact continuous solution to the elliptic pde
c          evaluated on the nx by ny discretization grid
c
c          let p be the exact solution to the linear discretization
c
c          let phi be the approximation to p generated by the mudpack solver
c
c     then discretization level error is defined by the condition
c
c          || phi - p || < || p - pe ||.
c                        =
c
c     a common measure of multigrid efficieny is that discretization level
c     error is reached in one full multigrid cycle (see references [2,9] in
c     the mudpack file "readme").  this can happen before the residual is
c     reduced to the level of roundoff error.  consequently, || res || is
c     a conservative measure of accuracy which can be wasteful if multi-
c     grid cycles are executed until it reaches the level of roundoff error.
c
c     || res || can be used to estimate the convergence rate of multigrid
c     iteration.  let r(n) be the residual and e(n) be the error after
c     executing n cycles.  they are related by the residual equation
c
c          l * e(n) = r(n).
c
c     it follows that the ratio
c
c          || r(n+1) || / || r(n) ||
c
c     estimates
c
c          || e(n+1) || / || e(n) ||
c
c     which in turn estimates the convergence rate
c
c          c = max || e(k+1) || / || e(k) ||.
c               k
c
c     notice
c                         n
c          || e(n) || <  c  || e(0) ||.
c
c
c ... assumptions (see cuh2cr.d or cud2cr.d)
c
c     (1) nx,ny have the same values as iparm(10),iparm(11) (used
c         to set the fine grid resolution when calling cud2cr or cuh2cr)
c
c     (2) work is the same argument used in calling cud2cr or cuh2cr.
c
c     (3) work has not changed since the last call to cud2cr or cuh2cr.
c
c     if these assumptions are not true then resc2cr cannot compute the
c     residual in res. (3) assures a copy of the last approximation phi
c     is contained in work.
c
      subroutine resc2cr(nx,ny,work,res)
      implicit none
      integer nx,ny,ic
      real work(*),res(nx,ny)
c
c     set pointer for fine grid coefficients in work
c
      ic = 1+(nx+2)*(ny+2)
      call rec2cr(nx,ny,work,work(ic),res)
      return
      end

      subroutine rec2cr(nx,ny,phi,cof,res)
c
c     compute residual
c
      implicit none
      integer nx,ny,i,j
      real phi(0:nx+1,0:ny+1),cof(nx,ny,10),res(nx,ny)
      do j=1,ny
	do i=1,nx
	  res(i,j) = cof(i,j,10) - (cof(i,j,9)*phi(i,j) +
     +               cof(i,j,1)*phi(i+1,j) + cof(i,j,2)*phi(i+1,j+1) +
     +               cof(i,j,3)*phi(i,j+1) + cof(i,j,4)*phi(i-1,j+1) +
     +               cof(i,j,5)*phi(i-1,j) + cof(i,j,6)*phi(i-1,j-1) +
     +               cof(i,j,7)*phi(i,j-1) + cof(i,j,8)*phi(i+1,j-1) )
	end do
      end do
      return
      end
</PRE>
<HR>
 
<a name="resc2sp.txt"><b>RESC2SP</b></a>
<PRE>
c
c     file resc2sp.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     subroutine resc2sp(nx,ny,nxa,nxb,nyc,nyd,work,res)
c
c
c ... purpose
c
c
c     subroutine resc2sp computes the fine grid residual in the nx by ny array
c     res after calling cud2sp.  if
c
c          l * p = f
c
c     is the n by n (n = nx*ny) block tri-diagonal linear system resulting
c     from the pde discretization (done internally in cud2sp) and phi is the
c     approximation to p obtained by calling cud2sp, then resc2sp computes the
c     nx by ny residual array
c
c          res = f - l * phi.
c
c     one of the vector norms of res,
c
c          || res ||
c
c     can be computed as a "measure" of how well phi satisfies the
c     discretization equations.  for example, the following statements
c     will compute the location and size of the maximum residual in res
c     on cray computers:
c
c          ij = isamax(nx*ny,res,1)
c
c          jmax = (ij-1)/nx + 1
c
c          imax = ij - (jmax-1)*nx
c
c          resmax = abs(res(imax,jmax))
c
c
c *** please note:
c
c          let pe be the exact continuous solution to the elliptic pde
c          evaluated on the nx by ny discretization grid
c
c          let p be the exact solution to the linear discretization
c
c          let phi be the approximation to p generated by the mudpack solver
c
c     then discretization level error is defined by the condition
c
c          || phi - p || < || p - pe ||.
c                        =
c
c     a common measure of multigrid efficieny is that discretization level
c     error is reached in one full multigrid cycle (see references [2,9] in
c     the mudpack file "readme").  this can happen before the residual is
c     reduced to the level of roundoff error.  consequently, || res || is
c     a conservative measure of accuracy which can be wasteful if multi-
c     grid cycles are executed until it reaches the level of roundoff error.
c
c     || res || can be used to estimate the convergence rate of multigrid
c     iteration.  let r(n) be the residual and e(n) be the error after
c     executing n cycles.  they are related by the residual equation
c
c          l * e(n) = r(n).
c
c     it follows that the ratio
c
c          || r(n+1) || / || r(n) ||
c
c     estimates
c
c          || e(n+1) || / || e(n) ||
c
c     which in turn estimates the convergence rate
c
c          c = max || e(k+1) || / || e(k) ||.
c               k
c
c     notice
c                         n
c          || e(n) || <  c  || e(0) ||.
c
c
c ... assumptions (see cud2sp.d)
c
c     (1) nx,ny have the same values as iparm(10),iparm(11) (used
c         to set the fine grid resolution when calling cud2sp)
c
c     (2) nxa,nxb,nyc,nyd have the same values as iparm(2),iparm(3),
c         iparm(4),iparm(5) (boundary condition flags) used to call
c         cud2sp
c
c     (3) work is the same work space argument used in calling cud2sp.
c
c     (4) work has not changed since the last call to cud2sp.
c
c     If (1)-(4) are not true then resc2sp cannot compute the residual
c     in res.  (3),(4) assure a copy of the last computed phi is in work.
c
      subroutine resc2sp(nx,ny,nxa,nxb,nyc,nyd,work,res)
      implicit none
      integer nx,ny,nxa,nxb,nyc,nyd,irh,icx,icy
      complex work(*),res(nx,ny)
c
c     set pointer for fine grid coefficients in work
c
      irh = 1 + (nx+2)*(ny+2)
      icx = irh + nx*ny
      icy = icx + 3*nx
      call rec2sp(nx,ny,nxa,nxb,nyc,nyd,work,work(irh),
     +            work(icx),work(icy),res)
      return
      end

      subroutine rec2sp(nx,ny,nxa,nxb,nyc,nyd,phi,rhs,cofx,cofy,res)
      implicit none
      integer nx,ny,nxa,nxb,nyc,nyd,i,j,ist,ifn,jst,jfn
      complex phi(0:nx+1,0:ny+1),rhs(nx,ny)
      complex cofx(nx,3),cofy(ny,3),res(nx,ny)
c
c     intialize residual to zero and set limits
c
      do j=1,ny
	do i=1,nx
	  res(i,j) = (0.0,0.0)
	end do
      end do
c
c     set limits
c
      ist = 1
      if (nxa.eq.1) ist = 2
      ifn = nx
      if (nxb.eq.1) ifn = nx-1
      jst = 1
      if (nyc.eq.1) jst = 2
      jfn = ny
      if (nyd.eq.1) jfn = ny-1
c
c     compute residual on nonspecified grid points
c
      do j=jst,jfn
	do i=ist,ifn
	  res(i,j) =  rhs(i,j)-(
     +                cofx(i,1)*phi(i-1,j)+
     +                cofx(i,2)*phi(i+1,j)+
     +                cofy(j,1)*phi(i,j-1)+
     +                cofy(j,2)*phi(i,j+1)+
     +                (cofx(i,3)+cofy(j,3))*phi(i,j))
	end do
      end do
      return
      end
</PRE>
<HR>
 
<a name="resc3.txt"><b>RESC3</b></a>
<PRE>
c
c     file resc3.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     subroutine resc3(nx,ny,nz,work,res)
c
c
c ... purpose
c
c
c     subroutine resc3 computes the fine grid residual in the nx by ny by nz
c     array res after calling cuh3 or cud3 or cud3sa.  if
c
c          L * p = f
c
c     is the n by n (n = nx*ny*nz) block tri-diagonal linear system resulting
c     from the pde discretization (done internally in cud3 or cuh3) and phi
c     is the approximation to p obtained by calling cud3, then resc3 computes
c     the nx by ny by nz residual array
c
c          res = f - L * phi.
c
c     one of the vector norms of res,
c
c          || res ||
c
c     can be computed as a "measure" of how well phi satisfies the
c     discretization equations.  for example, the following statements
c     will compute the location and size of the maximum residual in res
c     on cray computers:
c
c          ijk = isamax(nx*ny*nz,res,1)
c
c          kmax = (ijk-1)/(nx*ny) + 1
c
c          jmax = (ijk-(kmax-1)*nx*ny-1)/nx + 1
c
c          imax = ij - nx*((kmax-1)*ny-jmax+1)
c
c          resmax = abs(res(imax,jmax,kmax))
c
c
c *** please note:
c
c          let pe be the exact continuous solution to the elliptic pde
c          evaluated on the nx by ny by nz discretization grid
c
c          let p be the exact solution to the linear discretization
c
c          let phi be the approximation to p generated by the mudpack solver
c
c     then discretization level error is defined by the condition
c
c          || phi - p || < || p - pe ||.
c                        =
c
c     a common measure of multigrid efficieny is that discretization level
c     error is reached in one full multigrid cycle (see references [2,9] in
c     the mudpack file "readme").  this can happen before the residual is
c     reduced to the level of roundoff error.  consequently, || res || is
c     a conservative measure of accuracy which can be wasteful if multi-
c     grid cycles are executed until it reaches the level of roundoff error.
c
c     || res || can be used to estimate the convergence rate of multigrid
c     iteration.  let r(n) be the residual and e(n) be the error after
c     executing n cycles.  they are related by the residual equation
c
c          L * e(n) = r(n).
c
c     it follows that the ratio
c
c          || r(n+1) || / || r(n) ||
c
c     estimates
c
c          || e(n+1) || / || e(n) ||
c
c     which in turn estimates the convergence rate
c
c          c = max || e(k+1) || / || e(k) ||.
c               k
c
c     notice
c                         n
c          || e(n) || <  c  || e(0) ||.
c
c
c ... assumptions (see cud3.d or cud3sa.d or cuh3.d)
c
c     (1) nx,ny,nz have the same values as iparm(14),iparm(15),iparm(16)
c         (used to set the fine grid resolution when calling cud3 or cuh3 or cud3sa)
c
c     (2) work,phi are the same parameters used in calling cud3 or cuh3 or cud3sa
c
c     (3) work,phi have not changed since the last call to cud3 or cud3sa or cuh3
c
c
c     (3) assures a copy of the last approximation phi is contained in work.
c     if these assumptions are not true then resc3 cannot compute the
c     residual in res.
c
      subroutine resc3(nx,ny,nz,work,res)
c
c     compute fine grid residual in res after calling cud3 or cud3sa or cuh3
c
      implicit none
      integer nx,ny,nz,ic
      complex work(*),res(nx,ny,nz)
c
c     set coefficient pointer
c
      ic = 1+(nx+2)*(ny+2)*(nz+2)
      ic = 1+(nx+2)*(ny+2)*(nz+2)
      call rec3(nx,ny,nz,work,work(ic),res)
      return
      end

      subroutine rec3(nx,ny,nz,phi,cof,res)
      implicit none
      integer nx,ny,nz,i,j,k
      complex cof(nx,ny,nz,8),phi(0:nx+1,0:ny+1,0:nz+1),res(nx,ny,nz)
      do k=1,nz
	do j=1,ny
	  do i=1,nx
	    res(i,j,k) =  cof(i,j,k,8) - (
     +                    cof(i,j,k,1)*phi(i-1,j,k)+
     +                    cof(i,j,k,2)*phi(i+1,j,k)+
     +                    cof(i,j,k,3)*phi(i,j-1,k)+
     +                    cof(i,j,k,4)*phi(i,j+1,k)+
     +                    cof(i,j,k,5)*phi(i,j,k-1)+
     +                    cof(i,j,k,6)*phi(i,j,k+1)+
     +                    cof(i,j,k,7)*phi(i,j,k) )
	  end do
	end do
      end do
      return
      end
</PRE>
<HR>
 
<a name="resc3sp.txt"><b>RESC3SP</b></a>
<PRE>
c
c     file resc3sp.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     subroutine resc3sp(nx,ny,nz,nxa,nxb,nyc,nyd,nze,nzf,work,res)
c
c
c ... purpose
c
c
c     subroutine resc3sp computes the fine grid residual in the nx by ny by nz
c     array res after calling cud3sp.  if
c
c          l * p = f
c
c     is the n by n (n = nx*ny*nz) block tri-diagonal linear system resulting
c     from the pde discretization (done internally in cud3sp) and phi is the
c     approximation to p obtained by calling cud3sp, then resc3sp computes
c     the nx by ny by nz residual array
c
c          res = f - l * phi.
c
c     one of the vector norms of res,
c
c          || res ||
c
c     can be computed as a "measure" of how well phi satisfies the
c     discretization equations.  for example, the following statements
c     will compute the location and size of the maximum residual in res
c     on cray computers:
c
c          ijk = isamax(nx*ny*nz,res,1)
c
c          kmax = (ijk-1)/(nx*ny) + 1
c
c          jmax = (ijk-(kmax-1)*nx*ny-1)/nx + 1
c
c          imax = ij - nx*((kmax-1)*ny-jmax+1)
c
c          resmax = abs(res(imax,jmax,kmax))
c
c
c *** please note:
c
c          let pe be the exact continuous solution to the elliptic pde
c          evaluated on the nx by ny by nz discretization grid
c
c          let p be the exact solution to the linear discretization
c
c          let phi be the approximation to p generated by the mudpack solver
c
c     then discretization level error is defined by the condition
c
c          || phi - p || < || p - pe ||.
c                        =
c
c     a common measure of multigrid efficieny is that discretization level
c     error is reached in one full multigrid cycle (see references [2,9] in
c     the mudpack file "readme").  this can happen before the residual is
c     reduced to the level of roundoff error.  consequently, || res || is
c     a conservative measure of accuracy which can be wasteful if multi-
c     grid cycles are executed until it reaches the level of roundoff error.
c
c     || res || can be used to estimate the convergence rate of multigrid
c     iteration.  let r(n) be the residual and e(n) be the error after
c     executing n cycles.  they are related by the residual equation
c
c          l * e(n) = r(n).
c
c     it follows that the ratio
c
c          || r(n+1) || / || r(n) ||
c
c     estimates
c
c          || e(n+1) || / || e(n) ||
c
c     which in turn estimates the convergence rate
c
c          c = max || e(k+1) || / || e(k) ||.
c               k
c
c     notice
c                         n
c          || e(n) || <  c  || e(0) ||.
c
c
c ... assumptions (see cud3sp.d)
c
c     (1) nx,ny,nz have the same values as iparm(14),iparm(15),iparm(16)
c         (used to set the fine grid resolution when calling cud3sp)
c
c     (2) nxa,nxb,nyc,nyd,nze,nzf have the same values as iparm(2),
c         iparm(3),iparm(4),iparm(5),iparm(6),iparm(7) (used to flag
c         boundary conditions when calling cud3sp).
c
c     (3) work,phi are the same parameters used in calling cud3sp.
c
c     (4) work,phi have not changed since the last call to cud3sp.
c
c     (3) assures a copy of the last approximation phi is contained in work.
c     if (1)-(4) are not true then resc3sp cannot compute the residual.
c
      subroutine resc3sp(nx,ny,nz,nxa,nxb,nyc,nyd,nze,nzf,wk,res)
      implicit none
      integer nx,ny,nz,nxa,nxb,nyc,nyd,nze,nzf,ir,ix,iy,iz
      complex wk(*),res(*)
c
c     set pointers
c
      ir = 1+(nx+2)*(ny+2)*(nz+2)
      ix = ir+nx*ny*nz
      iy = ix+3*nx
      iz = iy+3*ny
      call rec3sp(nx,ny,nz,nxa,nxb,nyc,nyd,nze,nzf,wk,wk(ir),wk(ix),
     +            wk(iy),wk(iz),res)
      return
      end

      subroutine rec3sp(nx,ny,nz,nxa,nxb,nyc,nyd,nze,nzf,phi,
     +                  rhs,cofx,cofy,cofz,resf)
      implicit none
      integer nx,ny,nz,nxa,nxb,nyc,nyd,nze,nzf
      integer i,j,k,ist,ifn,jst,jfn,kst,kfn
      complex cofx(nx,3),cofy(ny,3),cofz(nz,3)
      complex rhs(nx,ny,nz),phi(0:nx+1,0:ny+1,0:nz+1),resf(nx,ny,nz)
c
c     intialize residual to zero and set loop limits
c
      do k=1,nz
	do j=1,ny
	  do i=1,nx
	    resf(i,j,k) = (0.0,0.0)
	  end do
	end do
      end do
      ist = 1
      if (nxa.eq.1) ist = 2
      ifn = nx
      if (nxb.eq.1) ifn = nx-1
      jst = 1
      if (nyc.eq.1) jst = 2
      jfn = ny
      if (nyd.eq.1) jfn = ny-1
      kst = 1
      if (nze.eq.1) kst = 2
      kfn = nz
      if (nzf.eq.1) kfn = nz-1
c
c     compute residual
c
      do k=kst,kfn
	do j=jst,jfn
	  do i=ist,ifn
	    resf(i,j,k) =  rhs(i,j,k)-(
     +      cofx(i,1)*phi(i-1,j,k)+cofx(i,2)*phi(i+1,j,k) +
     +      cofy(j,1)*phi(i,j-1,k)+cofy(j,2)*phi(i,j+1,k) +
     +      cofz(k,1)*phi(i,j,k-1)+cofz(k,2)*phi(i,j,k+1) +
     +      (cofx(i,3)+cofy(j,3)+cofz(k,3))*phi(i,j,k)  )
	  end do
	end do
      end do
      return
      end
</PRE>
<HR>
 
<a name="resm2.txt"><b>RESM2</b></a>
<PRE>
c
c     file resm2.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     subroutine resm2(nx,ny,work,res)
c
c
c ... purpose
c
c
c     subroutine resm2 computes the fine grid residual in the nx by ny array
c     res after calling mud2 or muh2 or mud2sa.  if
c
c          L * p = f
c
c     is the n by n (n = nx*ny) block tri-diagonal linear system resulting
c     from the pde discretization (done internally in the mudpack solver)
c     then resm2 computes the nx by ny residual array
c
c          res = f - L * p
c
c     one of the vector norms of res,
c
c          || res ||
c
c     can be computed as a "measure" of how well the approximation satisfies
c     the discretization equations.  for example, the following statements
c     will compute the location and size of the maximum residual in res
c     on cray computers:
c
c          ij = isamax(nx*ny,res,1)
c
c          jmax = (ij-1)/nx + 1
c
c          imax = ij - (jmax-1)*nx
c
c          resmax = abs(res(imax,jmax))
c
c
c *** please note:
c
c          let pe be the exact continuous solution to the elliptic pde
c          evaluated on the nx by ny discretization grid
c
c          let p be the exact solution to the linear discretization
c
c          let phi be the approximation to p generated by the mudpack solver
c
c     then discretization level error is defined by the condition
c
c          || phi - p || < || p - pe ||.
c                        =
c
c     a common measure of multigrid efficieny is that discretization level
c     error is reached in one full multigrid cycle (see references [2,9] in
c     the mudpack file "readme").  this can happen before the residual is
c     reduced to the level of roundoff error.  consequently, || res || is
c     a conservative measure of accuracy which can be wasteful if multi-
c     grid cycles are executed until it reaches the level of roundoff error.
c
c     || res || can be used to estimate the convergence rate of multigrid
c     iteration.  let r(n) be the residual and e(n) be the error after
c     executing n cycles.  they are related by the residual equation
c
c          L * e(n) = r(n).
c
c     it follows that the ratio
c
c          || r(n+1) || / || r(n) ||
c
c     estimates
c
c          || e(n+1) || / || e(n) ||
c
c     which in turn estimates the convergence rate
c
c          c = max || e(k+1) || / || e(k) ||.
c               k
c
c     notice
c                         n
c          || e(n) || <  c  || e(0) ||.
c
c
c ... assumptions (see mud2.d or muh2.d or mud2sa.d)
c
c     (1) nx,ny have the same values as iparm(10),iparm(11) (used
c         to set the fine grid resolution)
c
c     (2) work is the same argument used in calling the solver.
c
c     (3) work have not changed since the last call to the solver.
c
c     (3) assures a copy of the last approximation phi is contained in work.
c     if these assumptions are not true then resm2 cannot compute the
c     residual in res.
c
      subroutine resm2(nx,ny,work,res)
      implicit none
      integer nx,ny,ic
      real work(*),res(nx,ny)
c
c     set approximation and coefficient pointers
c
      ic = 1+(nx+2)*(ny+2)
      call rem2(nx,ny,work,work(ic),res)
      return
      end

      subroutine rem2(nx,ny,phi,cof,res)
      implicit none
      integer nx,ny,i,j
      real phi(0:nx+1,0:ny+1),cof(nx,ny,6),res(nx,ny)
c
c     compute residual over entire x,y grid
c
      do j=1,ny
	do i=1,nx
	  res(i,j) =  cof(i,j,6)-(
     +                cof(i,j,1)*phi(i-1,j)+
     +                cof(i,j,2)*phi(i+1,j)+
     +                cof(i,j,3)*phi(i,j-1)+
     +                cof(i,j,4)*phi(i,j+1)+
     +                cof(i,j,5)*phi(i,j))
	end do
      end do
      return
      end
</PRE>
<HR>
 
<a name="resm2cr.txt"><b>RESM2CR</b></a>
<PRE>
c
c     file resm2cr.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     subroutine resm2cr(nx,ny,work,res)
c
c
c ... purpose
c
c
c     subroutine resm2cr computes the fine grid residual in the nx by ny array
c     res after calling mud2cr or muh2cr.  if
c
c          l * p = f
c
c     is the n by n (n = nx*ny) block tri-diagonal linear system resulting
c     from the pde discretization (done internally in mud2cr or muh2cr) and
c     phi is the approximation to p obtained by calling mud2cr or muh2cr,
c     then resm2cr computes the nx by ny residual array
c
c          res = f - l * phi.
c
c     one of the vector norms of res,
c
c          || res ||
c
c     can be computed as a "measure" of how well phi satisfies the
c     discretization equations.  for example, the following statements
c     will compute the location and size of the maximum residual in res
c     on cray computers:
c
c          ij = isamax(nx*ny,res,1)
c
c          jmax = (ij-1)/nx + 1
c
c          imax = ij - (jmax-1)*nx
c
c          resmax = abs(res(imax,jmax))
c
c
c *** please note:
c
c          let pe be the exact continuous solution to the elliptic pde
c          evaluated on the nx by ny discretization grid
c
c          let p be the exact solution to the linear discretization
c
c          let phi be the approximation to p generated by the mudpack solver
c
c     then discretization level error is defined by the condition
c
c          || phi - p || < || p - pe ||.
c                        =
c
c     a common measure of multigrid efficieny is that discretization level
c     error is reached in one full multigrid cycle (see references [2,9] in
c     the mudpack file "readme").  this can happen before the residual is
c     reduced to the level of roundoff error.  consequently, || res || is
c     a conservative measure of accuracy which can be wasteful if multi-
c     grid cycles are executed until it reaches the level of roundoff error.
c
c     || res || can be used to estimate the convergence rate of multigrid
c     iteration.  let r(n) be the residual and e(n) be the error after
c     executing n cycles.  they are related by the residual equation
c
c          l * e(n) = r(n).
c
c     it follows that the ratio
c
c          || r(n+1) || / || r(n) ||
c
c     estimates
c
c          || e(n+1) || / || e(n) ||
c
c     which in turn estimates the convergence rate
c
c          c = max || e(k+1) || / || e(k) ||.
c               k
c
c     notice
c                         n
c          || e(n) || <  c  || e(0) ||.
c
c
c ... assumptions (see muh2cr.d or mud2cr.d)
c
c     (1) nx,ny have the same values as iparm(10),iparm(11) (used
c         to set the fine grid resolution when calling cud2cr or cuh2cr)
c
c     (2) work is the same argument used in calling cud2cr or cuh2cr.
c
c     (3) work has not changed since the last call to cud2cr or cuh2cr.
c
c     if these assumptions are not true then resc2cr cannot compute the
c     residual in res. (3) assures a copy of the last approximation phi
c     is contained in work.
c
      subroutine resm2cr(nx,ny,work,res)
      implicit none
      integer nx,ny,ic
      real work(*),res(nx,ny)
c
c     set pointer for fine grid coefficients in work
c
      ic = 1+(nx+2)*(ny+2)
      call rem2cr(nx,ny,work,work(ic),res)
      return
      end

      subroutine rem2cr(nx,ny,phi,cof,res)
c
c     compute residual
c
      implicit none
      integer nx,ny,i,j
      real phi(0:nx+1,0:ny+1),cof(nx,ny,10),res(nx,ny)
      do j=1,ny
	do i=1,nx
	  res(i,j) = cof(i,j,10) - (cof(i,j,9)*phi(i,j) +
     +               cof(i,j,1)*phi(i+1,j) + cof(i,j,2)*phi(i+1,j+1) +
     +               cof(i,j,3)*phi(i,j+1) + cof(i,j,4)*phi(i-1,j+1) +
     +               cof(i,j,5)*phi(i-1,j) + cof(i,j,6)*phi(i-1,j-1) +
     +               cof(i,j,7)*phi(i,j-1) + cof(i,j,8)*phi(i+1,j-1) )
	end do
      end do
      return
      end
</PRE>
<HR>
 
<a name="resm2sp.txt"><b>RESM2SP</b></a>
<PRE>
c
c     file resm2sp.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     subroutine resm2sp(nx,ny,nxa,nxb,nyc,nyd,work,res)
c
c
c ... purpose
c
c
c     subroutine resm2sp computes the fine grid residual in the nx by ny array
c     res after calling mud2sp.  if
c
c          l * p = f
c
c     is the n by n (n = nx*ny) block tri-diagonal linear system resulting
c     from the pde discretization (done internally in mud2sp) and phi is the
c     approximation to p obtained by calling mud2sp, then resm2sp computes the
c     nx by ny residual array
c
c          res = f - l * phi.
c
c     one of the vector norms of res,
c
c          || res ||
c
c     can be computed as a "measure" of how well phi satisfies the
c     discretization equations.  for example, the following statements
c     will compute the location and size of the maximum residual in res
c     on cray computers:
c
c          ij = isamax(nx*ny,res,1)
c
c          jmax = (ij-1)/nx + 1
c
c          imax = ij - (jmax-1)*nx
c
c          resmax = abs(res(imax,jmax))
c
c
c *** please note:
c
c          let pe be the exact continuous solution to the elliptic pde
c          evaluated on the nx by ny discretization grid
c
c          let p be the exact solution to the linear discretization
c
c          let phi be the approximation to p generated by the mudpack solver
c
c     then discretization level error is defined by the condition
c
c          || phi - p || < || p - pe ||.
c                        =
c
c     a common measure of multigrid efficieny is that discretization level
c     error is reached in one full multigrid cycle (see references [2,9] in
c     the mudpack file "readme").  this can happen before the residual is
c     reduced to the level of roundoff error.  consequently, || res || is
c     a conservative measure of accuracy which can be wasteful if multi-
c     grid cycles are executed until it reaches the level of roundoff error.
c
c     || res || can be used to estimate the convergence rate of multigrid
c     iteration.  let r(n) be the residual and e(n) be the error after
c     executing n cycles.  they are related by the residual equation
c
c          l * e(n) = r(n).
c
c     it follows that the ratio
c
c          || r(n+1) || / || r(n) ||
c
c     estimates
c
c          || e(n+1) || / || e(n) ||
c
c     which in turn estimates the convergence rate
c
c          c = max || e(k+1) || / || e(k) ||.
c               k
c
c     notice
c                         n
c          || e(n) || <  c  || e(0) ||.
c
c
c ... assumptions (see mud2sp.d)
c
c     (1) nx,ny have the same values as iparm(10),iparm(11) (used
c         to set the fine grid resolution when calling mud2sp)
c
c     (2) nxa,nxb,nyc,nyd have the same values as iparm(2),iparm(3),
c         iparm(4),iparm(5) (boundary condition flags) used to call
c         mud2sp
c
c     (3) work is the same work space argument used in calling mud2sp.
c
c     (4) work has not changed since the last call to mud2sp.
c
c     If (1)-(4) are not true then resm2sp cannot compute the residual
c     in res.  (3),(4) assure a copy of the last computed phi is in work.
c
      subroutine resm2sp(nx,ny,nxa,nxb,nyc,nyd,work,res)
      implicit none
      integer nx,ny,nxa,nxb,nyc,nyd,irh,icx,icy
      real work(*),res(nx,ny)
c
c     set pointer for fine grid coefficients in work
c
      irh = 1 + (nx+2)*(ny+2)
      icx = irh + nx*ny
      icy = icx + 3*nx
      call rem2sp(nx,ny,nxa,nxb,nyc,nyd,work,work(irh),
     +            work(icx),work(icy),res)
      return
      end

      subroutine rem2sp(nx,ny,nxa,nxb,nyc,nyd,phi,rhs,cofx,cofy,res)
      implicit none
      integer nx,ny,nxa,nxb,nyc,nyd,i,j,ist,ifn,jst,jfn
      real phi(0:nx+1,0:ny+1),rhs(nx,ny)
      real cofx(nx,3),cofy(ny,3),res(nx,ny)
c
c     intialize residual to zero and set limits
c
      do j=1,ny
	do i=1,nx
	  res(i,j) = 0.0
	end do
      end do
c
c     set limits
c
      ist = 1
      if (nxa.eq.1) ist = 2
      ifn = nx
      if (nxb.eq.1) ifn = nx-1
      jst = 1
      if (nyc.eq.1) jst = 2
      jfn = ny
      if (nyd.eq.1) jfn = ny-1
c
c     compute residual on nonspecified grid points
c
      do j=jst,jfn
	do i=ist,ifn
	  res(i,j) =  rhs(i,j)-(
     +                cofx(i,1)*phi(i-1,j)+
     +                cofx(i,2)*phi(i+1,j)+
     +                cofy(j,1)*phi(i,j-1)+
     +                cofy(j,2)*phi(i,j+1)+
     +                (cofx(i,3)+cofy(j,3))*phi(i,j))
	end do
      end do
      return
      end
</PRE>
<HR>
 
<a name="resm3.txt"><b>RESM3</b></a>
<PRE>
c
c     file resm3.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     subroutine resm3(nx,ny,nz,work,res)
c
c
c ... purpose
c
c
c     subroutine resm3 computes the fine grid residual in the nx by ny by nz
c     array res after calling muh3 or mud3 or mud3sa.  if
c
c          L * p = f
c
c     is the n by n (n = nx*ny*nz) block tri-diagonal linear system resulting
c     from the pde discretization (done internally in mud3 or mud3sa) and phi
c     is the approximation to p obtained by calling mud3, then resm3 computes
c     the nx by ny by nz residual array
c
c          res = f - L * phi.
c
c     one of the vector norms of res,
c
c          || res ||
c
c     can be computed as a "measure" of how well phi satisfies the
c     discretization equations.  for example, the following statements
c     will compute the location and size of the maximum residual in res
c     on cray computers:
c
c          ijk = isamax(nx*ny*nz,res,1)
c
c          kmax = (ijk-1)/(nx*ny) + 1
c
c          jmax = (ijk-(kmax-1)*nx*ny-1)/nx + 1
c
c          imax = ij - nx*((kmax-1)*ny-jmax+1)
c
c          resmax = abs(res(imax,jmax,kmax))
c
c
c *** please note:
c
c          let pe be the exact continuous solution to the elliptic pde
c          evaluated on the nx by ny by nz discretization grid
c
c          let p be the exact solution to the linear discretization
c
c          let phi be the approximation to p generated by the mudpack solver
c
c     then discretization level error is defined by the condition
c
c          || phi - p || < || p - pe ||.
c                        =
c
c     a common measure of multigrid efficieny is that discretization level
c     error is reached in one full multigrid cycle (see references [2,9] in
c     the mudpack file "readme").  this can happen before the residual is
c     reduced to the level of roundoff error.  consequently, || res || is
c     a conservative measure of accuracy which can be wasteful if multi-
c     grid cycles are executed until it reaches the level of roundoff error.
c
c     || res || can be used to estimate the convergence rate of multigrid
c     iteration.  let r(n) be the residual and e(n) be the error after
c     executing n cycles.  they are related by the residual equation
c
c          L * e(n) = r(n).
c
c     it follows that the ratio
c
c          || r(n+1) || / || r(n) ||
c
c     estimates
c
c          || e(n+1) || / || e(n) ||
c
c     which in turn estimates the convergence rate
c
c          c = max || e(k+1) || / || e(k) ||.
c               k
c
c     notice
c                         n
c          || e(n) || <  c  || e(0) ||.
c
c
c ... assumptions (see mud3.d or mud3sa.d)
c
c     (1) nx,ny,nz have the same values as iparm(14),iparm(15),iparm(16)
c         (used to set the fine grid resolution when calling mud3 or mud3sa)
c
c     (2) work,phi are the same parameters used in calling mud3 or mud3sa.
c
c     (3) work,phi have not changed since the last call to mud3 or mud3sa.
c
c
c     (3) assures a copy of the last approximation phi is contained in work.
c     if these assumptions are not true then resm3 cannot compute the
c     residual in res.
c
      subroutine resm3(nx,ny,nz,work,res)
c
c     compute fine grid residual in res after calling mud3 or mud3sa
c
      implicit none
      integer nx,ny,nz,ic
      real work(*),res(nx,ny,nz)
c
c     set coefficient pointer
c
      ic = 1+(nx+2)*(ny+2)*(nz+2)
      ic = 1+(nx+2)*(ny+2)*(nz+2)
      call rem3(nx,ny,nz,work,work(ic),res)
      return
      end

      subroutine rem3(nx,ny,nz,phi,cof,res)
      implicit none
      integer nx,ny,nz,i,j,k
      real cof(nx,ny,nz,8),phi(0:nx+1,0:ny+1,0:nz+1),res(nx,ny,nz)
      do k=1,nz
	do j=1,ny
	  do i=1,nx
	    res(i,j,k) =  cof(i,j,k,8) - (
     +                    cof(i,j,k,1)*phi(i-1,j,k)+
     +                    cof(i,j,k,2)*phi(i+1,j,k)+
     +                    cof(i,j,k,3)*phi(i,j-1,k)+
     +                    cof(i,j,k,4)*phi(i,j+1,k)+
     +                    cof(i,j,k,5)*phi(i,j,k-1)+
     +                    cof(i,j,k,6)*phi(i,j,k+1)+
     +                    cof(i,j,k,7)*phi(i,j,k) )
	  end do
	end do
      end do
      return
      end
</PRE>
<HR>
 
<a name="resm3sp.txt"><b>RESM3SP</b></a>
<PRE>
c
c     file resm3sp.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     subroutine resm3sp(nx,ny,nz,nxa,nxb,nyc,nyd,nze,nzf,work,res)
c
c
c ... purpose
c
c
c     subroutine resm3sp computes the fine grid residual in the nx by ny by nz
c     array res after calling mud3sp.  if
c
c          l * p = f
c
c     is the n by n (n = nx*ny*nz) block tri-diagonal linear system resulting
c     from the pde discretization (done internally in mud3sp) and phi is the
c     approximation to p obtained by calling mud3sp, then resm3sp computes
c     the nx by ny by nz residual array
c
c          res = f - l * phi.
c
c     one of the vector norms of res,
c
c          || res ||
c
c     can be computed as a "measure" of how well phi satisfies the
c     discretization equations.  for example, the following statements
c     will compute the location and size of the maximum residual in res
c     on cray computers:
c
c          ijk = isamax(nx*ny*nz,res,1)
c
c          kmax = (ijk-1)/(nx*ny) + 1
c
c          jmax = (ijk-(kmax-1)*nx*ny-1)/nx + 1
c
c          imax = ij - nx*((kmax-1)*ny-jmax+1)
c
c          resmax = abs(res(imax,jmax,kmax))
c
c
c *** please note:
c
c          let pe be the exact continuous solution to the elliptic pde
c          evaluated on the nx by ny by nz discretization grid
c
c          let p be the exact solution to the linear discretization
c
c          let phi be the approximation to p generated by the mudpack solver
c
c     then discretization level error is defined by the condition
c
c          || phi - p || < || p - pe ||.
c                        =
c
c     a common measure of multigrid efficieny is that discretization level
c     error is reached in one full multigrid cycle (see references [2,9] in
c     the mudpack file "readme").  this can happen before the residual is
c     reduced to the level of roundoff error.  consequently, || res || is
c     a conservative measure of accuracy which can be wasteful if multi-
c     grid cycles are executed until it reaches the level of roundoff error.
c
c     || res || can be used to estimate the convergence rate of multigrid
c     iteration.  let r(n) be the residual and e(n) be the error after
c     executing n cycles.  they are related by the residual equation
c
c          l * e(n) = r(n).
c
c     it follows that the ratio
c
c          || r(n+1) || / || r(n) ||
c
c     estimates
c
c          || e(n+1) || / || e(n) ||
c
c     which in turn estimates the convergence rate
c
c          c = max || e(k+1) || / || e(k) ||.
c               k
c
c     notice
c                         n
c          || e(n) || <  c  || e(0) ||.
c
c
c ... assumptions (see mud3sp.d)
c
c     (1) nx,ny,nz have the same values as iparm(14),iparm(15),iparm(16)
c         (used to set the fine grid resolution when calling mud3sp)
c
c     (2) nxa,nxb,nyc,nyd,nze,nzf have the same values as iparm(2),
c         iparm(3),iparm(4),iparm(5),iparm(6),iparm(7) (used to flag
c         boundary conditions when calling mud3sp).
c
c     (3) work,phi are the same parameters used in calling mud3sp.
c
c     (4) work,phi have not changed since the last call to mud3sp.
c
c     (3) assures a copy of the last approximation phi is contained in work.
c     if (1)-(4) are not true then resm3sp cannot compute the residual.
c
      subroutine resm3sp(nx,ny,nz,nxa,nxb,nyc,nyd,nze,nzf,wk,res)
      implicit none
      integer nx,ny,nz,nxa,nxb,nyc,nyd,nze,nzf,ir,ix,iy,iz
      real wk(*),res(*)
c
c     set pointers
c
      ir = 1+(nx+2)*(ny+2)*(nz+2)
      ix = ir+nx*ny*nz
      iy = ix+3*nx
      iz = iy+3*ny
      call rem3sp(nx,ny,nz,nxa,nxb,nyc,nyd,nze,nzf,wk,wk(ir),wk(ix),
     +            wk(iy),wk(iz),res)
      return
      end

      subroutine rem3sp(nx,ny,nz,nxa,nxb,nyc,nyd,nze,nzf,phi,
     +                  rhs,cofx,cofy,cofz,resf)
      implicit none
      integer nx,ny,nz,nxa,nxb,nyc,nyd,nze,nzf
      integer i,j,k,ist,ifn,jst,jfn,kst,kfn
      real cofx(nx,3),cofy(ny,3),cofz(nz,3)
      real rhs(nx,ny,nz),phi(0:nx+1,0:ny+1,0:nz+1),resf(nx,ny,nz)
c
c     intialize residual to zero and set loop limits
c
      do k=1,nz
	do j=1,ny
	  do i=1,nx
	    resf(i,j,k) = 0.0
	  end do
	end do
      end do
      ist = 1
      if (nxa.eq.1) ist = 2
      ifn = nx
      if (nxb.eq.1) ifn = nx-1
      jst = 1
      if (nyc.eq.1) jst = 2
      jfn = ny
      if (nyd.eq.1) jfn = ny-1
      kst = 1
      if (nze.eq.1) kst = 2
      kfn = nz
      if (nzf.eq.1) kfn = nz-1
c
c     compute residual
c
      do k=kst,kfn
	do j=jst,jfn
	  do i=ist,ifn
	    resf(i,j,k) =  rhs(i,j,k)-(
     +      cofx(i,1)*phi(i-1,j,k)+cofx(i,2)*phi(i+1,j,k) +
     +      cofy(j,1)*phi(i,j-1,k)+cofy(j,2)*phi(i,j+1,k) +
     +      cofz(k,1)*phi(i,j,k-1)+cofz(k,2)*phi(i,j,k+1) +
     +      (cofx(i,3)+cofy(j,3)+cofz(k,3))*phi(i,j,k)  )
	  end do
	end do
      end do
      return
      end
</PRE>
<HR>
 
<a name="tcud2.txt"><b>TCUD2</b></a>
<PRE>
c
c     file tcud2.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the complex MUDPACK solver cud2
c
c ... required MUDPACK files
c
c     cud2.f, cudcom.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cud2
c
c **********************************************************
c **********************************************************
c
c     a sample program/test driver for cud2 is below.  it can be
c     executed as an initial test.  the output is listed for the
c     test case described.
c
c     test the driver below by solving the complex linear elliptic pde
c
c        cmplx(1.+x*x,1.+y*y)*pxx +
c
c        cmplx(exp(-x),exp(-y))*(pyy - py) +
c
c        cmplx(y,x)*p(x,y) = r(x,y)
c
c     on the unit square with specified boundary conditions at
c     xb = 1.0, yc = 1.0 and mixed boundary conditions
c
c           dp/dx - cmplx(y,y)*p(xa,y) = g(y) at x = xa
c     and
c
c           dp/dy + cmplx(x,x)*p(x,yd) = h(x) at y = yd.
c
c     the exact solution
c
c          p(x,y) = cmplx(x**5,y**5) + 1.0
c
c     is used for testing.  one full multigrid cycle (no initial guess)
c     with red/black gauss-seidel point relaxation and the default multigrid
c     options is sufficient to reach discretization level error on a
c     49 x 65 grid.
c
c
c ******************************************************
c     output (32 bit floating point arithmetic)
c *******************************************************
c
c     cud2 test
c
c     integer input arguments
c     intl =  0 nxa =  2 nxb =  1 nyc =  1 nyd =  2
c     ixp =  3 jyq =  2 iex =  5 jey =  6
c     nx =  49 ny =  65 iguess =  0 maxcy =  1
c     method =  0 work space estimate =   42776
c
c     multigrid option arguments
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     xa =  0.000 xb =  1.000 yc =  0.000 yd =  1.000
c     tolerance (error control) =    0.000E+00
c
c     discretization call to cud2 intl =  0
c     ierror =  0 minimum work space =   34192
c
c     approximation call to cud2
c     intl =  1 method =  0 iguess =  0
c     ierror =  0
c     maximum error  =   0.615E-03
c
c ************************************************************
c     end of output
c ************************************************************
c
      program tcud2
      implicit none
      integer iixp,jjyq,iiex,jjey,nnx,nny,llw
c
c     set grid sizes with parameter statements
c
      parameter (iixp = 3 , jjyq = 2 , iiex =5, jjey = 6)
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     estimate work length approximation for method=0 (see cud2.d)
c
      parameter (llw=(40*nnx*nny+8*(nnx+nny+2))/3)
c
c     dimension solution,right hand side, and work arrays
c
      complex p(nnx,nny),r(nnx,nny),w(llw)
c     put integer and floating point parameter names in contiguous
c     storeage for labelling purposes
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itcud2/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftcud2/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      complex pe,px,py,pxx,pyy,cxx,cyy,cx,cy,ce
      real dlx,dly,x,y,errmax
c
c     declare coefficient and boundary condition input subroutines external
c
      external cof,bndc
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 2
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set for one multigrid cycle
c
      maxcy = 1
c
c     set work space length approximation from parameter statement
c
      nwork = llw
c
c     set point relaxation
c
      method = 0
c
c     flag no initial guess (this sets full multigrid cycling)
c
      iguess = 0
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in r
c     initialize p to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cof(x,y,cxx,cyy,cx,cy,ce)
	  call exact(x,y,pxx,pyy,px,py,pe)
	  r(i,j) = cxx*pxx+cyy*pyy+cx*px+cy*py+ce*pe
	  p(i,j) = (0.0,0.0)
	end do
      end do
c
c     set specified boundaries in p
c
      x = xb
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pyy,px,py,pe)
	p(nx,j) = pe
      end do
      y = yc
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exact(x,y,pxx,pyy,px,py,pe)
	p(i,1) = pe
      end do
c
c     set default multigrid opitons
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     print input parameters (except multigrid options which are default)
c
      write(6,100)
  100 format(//' cud2 test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to cud2', ' intl = ', i2)
      call cud2(iprm,fprm,w,cof,bndc,r,p,mgopt,ierror)
c
c     print error parameter and minimum work space requirement
c
      write (*,105) ierror,iprm(16)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess
  106 format(/' approximation call to cud2',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2)
      call cud2(iprm,fprm,w,cof,bndc,r,p,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
c
c     compute and print exact maximum error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pyy,px,py,pe)
	  errmax = amax1(errmax,cabs((p(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
  108 format(' maximum error  =  ',e10.3)
      end

      subroutine cof(x,y,cxx,cyy,cx,cy,ce)
c
c     input pde coefficients at any grid point (x,y) in the solution region
c     (xa.le.x.le.xb,yc.le.y.le.yd) to cud2
c
      implicit none
      real x,y
      complex cxx,cyy,cx,cy,ce
      cxx = cmplx(1.+x*x,1.+y*y)
      cyy = cmplx(exp(-x),exp(-y))
      cx = (0.,0.)
      cy = -cyy
      ce = -cmplx(y,x)
      return
      end

      subroutine bndc(kbdy,xory,alfa,gbdy)
c
c     input mixed derivative b.c. to cud2
c
      implicit none
      integer kbdy
      real xory,x,y
      complex alfa,gbdy
      real xa,xb,yc,yd,tolmax,relmax
      common/ftcud2/xa,xb,yc,yd,tolmax,relmax
      complex pe,px,py,pxx,pyy
      if (kbdy.eq.1) then
c
c     x=xa boundary (nxa must equal 2)
c     b.c. has the form px + alfxa(y)*pe = gbdxa(y)
c     alfa and gbdy corresponding to alfxa(y),gbdxa(y)
c     must be output
c
	y = xory
	x = xa
	call exact(x,y,pxx,pyy,px,py,pe)
	alfa = -cmplx(y,y)
	gbdy = px + alfa*pe
	return
      end if
      if (kbdy.eq.4) then
c
c     y = yd boundary (nyd must equal 2)
c     b.c. has the form py + alfyd(x)*pe = gbdyd(x)
c     alfa and gbdy corresponding to alfyd(x),gbdyd(x)
c     must be output
c
	y = yd
	x = xory
	call exact(x,y,pxx,pyy,px,py,pe)
	alfa = cmplx(x,x)
	gbdy = py + alfa*pe
      return
      end if
      end

      subroutine exact(x,y,pxx,pyy,px,py,pe)
c
c     this subroutine is used to set an exact solution for testing cud2
c
      implicit none
      real x,y
      complex pxx,pyy,px,py,pe
      pe = cmplx(x**5,y**5)+1.0
      px = cmplx(5*x**4,0.)
      py = cmplx(0.,5*y**4)
      pxx = cmplx(20.*x**3,0.)
      pyy = cmplx(0.,20.*y**3)
      return
      end
</PRE>
<HR>
 
<a name="tcud24.txt"><b>TCUD24</b></a>
<PRE>
c
c     file tcud24.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the complex MUDPACK solver cud2
c
c ... required MUDPACK files
c
c     cud2.f, cudcom.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cud2
c
c **********************************************************
c **********************************************************
c
c     a sample program/test driver for cud2 is below.  it can be
c     executed as an initial test.  the output is listed for the
c     test case described.
c
c     test the driver below by solving the complex linear elliptic pde
c
c        cmplx(1.+x*x,1.+y*y)*pxx +
c
c        cmplx(exp(-x),exp(-y))*(pyy - py) +
c
c        cmplx(y,x)*p(x,y) = r(x,y)
c
c     on a 49 X 65 grid superimposed on the unit square with
c     specified boundary conditions at xb=1.0, yc=1.0 and
c     mixed boundary conditions
c
c           dp/dx - cmplx(y,y)*p(xa,y) = g(y) at x = xa
c     and
c
c           dp/dy + cmplx(x,x)*p(x,yd) = h(x) at y = yd.
c
c     the exact solution
c
c          p(x,y) = cmplx(x**5,y**5) + 1.0
c
c     is used for testing.  three multigrid cycles (no initial guess)
c     with red/black gauss-seidel point relaxation and the default multigrid
c     options are used to compute the second-order approximation with cud2.
c     Then cud24 is called to produce a fourth order estimate.
c
c ******************************************************
c     output (64 bit floating point arithmetic)
c *******************************************************
c
c     cud2 test
c
c     integer input arguments
c     intl =  0 nxa =  2 nxb =  1 nyc =  1 nyd =  2
c     ixp =  3 jyq =  2 iex =  5 jey =  6
c     nx =  49 ny =  65 iguess =  0 maxcy =  3
c     method =  0 work space estimate =   34192
c
c     multigrid option arguments
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     xa =  0.000 xb =  1.000 yc =  0.000 yd =  1.000
c     tolerance (error control) =    0.000E+00
c
c     discretization call to cud2 intl =  0
c     ierror =  0 minimum work space =   34192
c
c     approximation call to cud2
c     intl =  1 method =  0 iguess =  0 maxcy =  3
c     ierror =  0
c     maximum error  =   0.640E-03
c
c     cud24 test  ierror =  0
c     maximum error  =   0.346E-05
c
c ************************************************************
c     end of output
c ************************************************************
c
      program tcud24
      implicit none
      integer iixp,jjyq,iiex,jjey,nnx,nny,llw
c
c     set grid sizes with parameter statements
c
      parameter (iixp = 3 , jjyq = 2 , iiex =5, jjey = 6)
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     set exact minimal work space required (see tcud2.f)
c
      parameter (llw=34192)
c
c     dimension solution,right hand side, and work arrays
c
      complex p(nnx,nny),r(nnx,nny),w(llw)
c     put integer and floating point parameter names in contiguous
c     storeage for labelling purposes
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itcud2/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftcud2/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      complex cxx,cyy,cx,cy,ce,pxx,pyy,px,py,pe
      real dlx,dly,x,y,errmax
c
c     declare coefficient and boundary condition input subroutines external
c
      external cof,bndc
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 2
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set for three multigrid cycle
c
      maxcy = 3
c
c     set work space length approximation from parameter statement
c
      nwork = llw
c
c     set point relaxation
c
      method = 0
c
c     flag no initial guess (this sets full multigrid cycling)
c
      iguess = 0
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in r
c     initialize p to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cof(x,y,cxx,cyy,cx,cy,ce)
	  call exact(x,y,pxx,pyy,px,py,pe)
	  r(i,j) = cxx*pxx+cyy*pyy+cx*px+cy*py+ce*pe
	  p(i,j) = (0.0,0.0)
	end do
      end do
c
c     set specified boundaries in p
c
      x = xb
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pyy,px,py,pe)
	p(nx,j) = pe
      end do
      y = yc
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exact(x,y,pxx,pyy,px,py,pe)
	p(i,1) = pe
      end do
c
c     set default multigrid opitons
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     print input parameters (except multigrid options which are default)
c
      write(6,100)
  100 format(//' cud2 test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to cud2', ' intl = ', i2)
      call cud2(iprm,fprm,w,cof,bndc,r,p,mgopt,ierror)
c
c     print error parameter and minimum work space requirement
c
      write (*,105) ierror,iprm(16)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to cud2',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call cud2(iprm,fprm,w,cof,bndc,r,p,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
c
c     compute and print exact maximum error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pyy,px,py,pe)
	  errmax = amax1(errmax,cabs((p(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
  108 format(' maximum error  =  ',e10.3)
c
c      attempt to improve approximation to fourth order
c
      call cud24(w,p,ierror)
      write (*,109) ierror
  109 format(/' cud24 test ', ' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pyy,px,py,pe)
	  errmax = amax1(errmax,abs((p(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
      end

      subroutine cof(x,y,cxx,cyy,cx,cy,ce)
c
c     input pde coefficients at any grid point (x,y) in the solution region
c     (xa.le.x.le.xb,yc.le.y.le.yd) to cud2
c
      implicit none
      real x,y
      complex cxx,cyy,cx,cy,ce
      cxx = cmplx(1.+x*x,1.+y*y)
      cyy = cmplx(exp(-x),exp(-y))
      cx = (0.,0.)
      cy = -cyy
      ce = -cmplx(y,x)
      return
      end

      subroutine bndc(kbdy,xory,alfa,gbdy)
c
c     input mixed derivative b.c. to cud2
c
      implicit none
      integer kbdy
      real xory,x,y
      complex alfa,gbdy
      real xa,xb,yc,yd,tolmax,relmax
      common/ftcud2/xa,xb,yc,yd,tolmax,relmax
      complex pe,px,py,pxx,pyy
      if (kbdy.eq.1) then
c
c     x=xa boundary (nxa must equal 2)
c     b.c. has the form px + alfxa(y)*pe = gbdxa(y)
c     alfa and gbdy corresponding to alfxa(y),gbdxa(y)
c     must be output
c
	y = xory
	x = xa
	call exact(x,y,pxx,pyy,px,py,pe)
	alfa = -cmplx(y,y)
	gbdy = px + alfa*pe
	return
      end if
      if (kbdy.eq.4) then
c
c     y = yd boundary (nyd must equal 2)
c     b.c. has the form py + alfyd(x)*pe = gbdyd(x)
c     alfa and gbdy corresponding to alfyd(x),gbdyd(x)
c     must be output
c
	y = yd
	x = xory
	call exact(x,y,pxx,pyy,px,py,pe)
	alfa = cmplx(x,x)
	gbdy = py + alfa*pe
      return
      end if
      end

      subroutine exact(x,y,pxx,pyy,px,py,pe)
c
c     this subroutine is used to set an exact solution for testing cud2
c
      implicit none
      real x,y
      complex pxx,pyy,px,py,pe
      pe = cmplx(x**5,y**5)+1.0
      px = cmplx(5*x**4,0.)
      py = cmplx(0.,5*y**4)
      pxx = cmplx(20.*x**3,0.)
      pyy = cmplx(0.,20.*y**3)
      return
      end
</PRE>
<HR>
 
<a name="tcud24cr.txt"><b>TCUD24CR</b></a>
<PRE>
c
c     file tcud24cr.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the complex MUDPACK solver cud24cr
c
c ... required MUDPACK files
c
c     cud24cr.f, cud2cr.f, cudcom.f
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cud24cr
c
c **********************************************************
c **********************************************************
c
c     a sample program/test driver for cud24cr is below.  it can
c     be executed as an initial test.  the output is listed for
c     the test case described.
c
c     test the driver below by solving the elliptic pde
c
c      cmplx(1.+y*y,1.-y*y)*pxx + cmplx(x*y,-x*y)*pxy +
c
c      cmplx(1.+x*x,1.-x*x)*pyy + cmplx(y,-y)*px +
c
c      cmplx(x,-x)*py + cmplx(x+y,-x-y)*p(x,y) = r(x,y)
c
c     on the unit square with specified boundary conditions at
c     xa=0.0, xb=1.0, yc=1.0 and mixed boundary conditions at yd=1.0
c     of the form:
c
c          cmplx(-x,x)*dp/dx + cmplx(1.+x,1.-x)*dp/dy +
c
c          cmplx(-x,x)*p(x,1.0) = gbdy(x)
c
c     choose a 49 x 65 grid and use line relaxation in the y direction.
c     forr testing purposes use the exact solution
c
c       p(x,y) = cmplx((x*y)**3,-(x*y)**3) + (1.,1.)
c
c     First cud2cr is called with iguess=0 and maxcy=1 (see tcud2sp.f)
c     to execute one full multigrid cycle with no initial guess.  Then
c     cud2cr is called again with iguess=1 and maxcy=2 to ensure second
c     order discretization level error is reached (a requirement for
c     fourth order mudpack solvers).  Finally cud24cr is called to
c     produce a fourth-order estimate.
c
c ******************************************************
c     output (64 bit floating point arithmetic)
c *******************************************************
c
c     cud2cr test
c
c     integer input arguments
c     intl =  0 nxa =  1 nxb =  1 nyc =  1 nyd =  2
c     ixp =  3 jyq =  2 iex =  5 jey =  6
c     nx =  49 ny =  65 iguess =  0 maxcy =  1
c     method =  2 work space estimate =   64474
c
c     multigrid option arguments
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     xa =  0.000 xb =  1.000 yc =  0.000 yd =  1.000
c     tolerance (error control) =    0.000E+00
c
c     discretization call to cud2cr intl =  0
c     ierror =  0 minimum work space =   64474
c
c     approximation call to cud2cr
c     intl =  1 method =  2 iguess =  0 maxcy =  1
c     ierror =  0
c     maximum error  =   0.192E-03
c
c     approximation call to cud2cr
c     intl =  1 method =  2 iguess =  1 maxcy =  2
c     ierror =  0
c     maximum error  =   0.194E-03
c
c     cud24cr test  ierror =  0
c     maximum error  =   0.209E-06
c
c **********************************************************
c     end of output
c **********************************************************
c
      program tcud24cr
      implicit none
      integer iixp,jjyq,iiex,jjey,nnx,nny,llw
c
c     set grid sizes with parameter statements
c
      parameter (iixp = 3 , jjyq = 2 , iiex =5, jjey = 6)
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     set minimum required work space (see tcud2cr.f)
c
      parameter (llw = 64474)
c
c     dimension solution,right hand side, and work arrays
c
      complex p(nnx,nny),r(nnx,nny),w(llw)
c     put integer and floating point parameter names in contiguous
c     storeage for labelling purposes
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itcud2cr/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftcur2/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      complex cxx,cxy,cyy,cx,cy,ce,pxx,pxy,pyy,px,py,pe
      real dlx,dly,x,y,errmax
c
c     declare coefficient and boundary condition input subroutines external
c
      external cofcr,bndcr
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set for one multigrid cycle
c
      maxcy = 1
c
c     set work space length approximation from parameter statement
c
      nwork = llw
c
c     set point relaxation
c
      method = 2
c
c     flag no initial guess (this sets full multigrid cycling)
c
      iguess = 0
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in r
c     initialize p to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cofcr(x,y,cxx,cxy,cyy,cx,cy,ce)
	  call exact(x,y,pxx,pxy,pyy,px,py,pe)
	  r(i,j) = cxx*pxx+cxy*pxy+cyy*pyy+cx*px+cy*py+ce*pe
	  p(i,j) = (0.0,0.0)
	end do
      end do
c
c     set specified boundaries in p
c
      x = xa
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pxy,pyy,px,py,pe)
	p(1,j) = pe
      end do
      x = xb
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pxy,pyy,px,py,pe)
	p(nx,j) = pe
      end do
      y = yc
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exact(x,y,pxx,pxy,pyy,px,py,pe)
	p(i,1) = pe
      end do
c
c     set default multigrid opitons
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     print input parameters (except multigrid options which are default)
c
      write(6,100)
  100 format(//' cud2cr test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to cud2cr', ' intl = ', i2)
      call cud2cr(iprm,fprm,w,cofcr,bndcr,r,p,mgopt,ierror)
c
c     print error parameter and minimum work space requirement
c
      write (*,105) ierror,iprm(16)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to cud2cr',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call cud2cr(iprm,fprm,w,cofcr,bndcr,r,p,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print exact maximum error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pxy,pyy,px,py,pe)
	  errmax = amax1(errmax,cabs((p(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
  108 format(' maximum error  =  ',e10.3)
c
c     recall with iguess=1,maxcy=2
c
      maxcy = 2
      iguess = 1
      write(*,106) intl,method,iguess,maxcy
      call cud2cr(iprm,fprm,w,cofcr,bndcr,r,p,mgopt,ierror)
      write (*,107) ierror
      if (ierror.gt.0) call exit(0)
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pxy,pyy,px,py,pe)
	  errmax = amax1(errmax,cabs((p(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
c
c      now attempt fourth order estimate
c
      call cud24cr(w,cofcr,bndcr,p,ierror)
      write(*,109) ierror
  109 format(/' cud24cr test ', ' ierror = ',i2)
      if (ierror.gt.0.0) call exit(0)
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pxy,pyy,px,py,pe)
	  errmax = amax1(errmax,cabs((p(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
      end

      subroutine cofcr(x,y,cxx,cxy,cyy,cx,cy,ce)
c
c     input pde coefficients at any point (x,y) in the solution region
c     (xa.le.x.le.xb,yc.le.y.le.yd) to cud2cr
c
      implicit none
      complex cxx,cxy,cyy,cx,cy,ce
      real x,y,xa,xb,yc,yd,tolmax,relmax
      common/ftcur2/xa,xb,yc,yd,tolmax,relmax
      cxx = cmplx(1.+y**2,1.-y**2)
      cxy = cmplx(x*y,-x*y)
      cyy = cmplx(1.+x**2,1.-x*x)
      cx = cmplx(y,-y)
      cy = cmplx(x,-x)
      ce = -cmplx((x+y),-x-y)
      return
      end

      subroutine bndcr(kbdy,xory,alfa,beta,gama,gbdy)
c
c     input mixed "oblique" derivative b.c. to cud2cr
c
      implicit none
      integer kbdy
      real xory,x,y,xa,xb,yc,yd,tolmax,relmax
      complex alfa,beta,gama,gbdy,pe,px,py,pxx,pxy,pyy
      common/ftcur2/xa,xb,yc,yd,tolmax,relmax
      if (kbdy.eq.4) then
c
c     y=yd boundary (nyd must equal 2 if this code is to be executed).
c     b.c. has the form alfyd(x)*px+betyd(x)*py+gamyd(x)*pe = gbdyd(x)
c     where x = yorx.   alfa,beta,gama,gbdy corresponding to alfyd(x),
c     betyd(x),gamyd(x),gbdyd(y) must be output.
c
	y = yd
	x = xory
	alfa = -cmplx(x,-x)
	beta = cmplx(1.+x,1.-x)
	gama = -cmplx(x,-x)
	call exact(x,y,pxx,pxy,pyy,px,py,pe)
	gbdy = alfa*px + beta*py + gama*pe
	return
      end if
      end

      subroutine exact(x,y,pxx,pxy,pyy,px,py,pe)
c
c     this subroutine is used for setting an exact solution in order
c     to test subroutine cud2cr.
c
      implicit none
      real x,y,xy,xy2,xy3
      complex pxx,pxy,pyy,px,py,pe
      xy = x*y
      xy2 = xy*xy
      xy3 = xy2*xy
      pe = cmplx(xy3,-xy3)
      px = 3.*y*cmplx(xy2,-xy2)
      py = 3.*x*cmplx(xy2,-xy2)
      pxx = 6.*y*y*cmplx(xy,-xy)
      pxy = 9.*xy*cmplx(xy,-xy)
      pyy = 6.*x*x*cmplx(xy,-xy)
      return
      end

</PRE>
<HR>
 
<a name="tcud24sp.txt"><b>TCUD24SP</b></a>
<PRE>
c
c     file tcud24sp.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the complex MUDPACK solver cud24sp
c
c ... required MUDPACK files
c
c     cud24sp.f, cud2sp.f, cudcom.f
c
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cud24sp
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for cud24sp is listed below.  it
c     can be executed as an initial test.  the output is listed for
c     the test case described.
c
c     test the driver below by solving the complex separable elliptic pde
c
c          cmplx(1.+x*x,1-x*x)*pxx + cmplx(exp(1.-y),exp(y))*(pyy-py) -
c
c          (cmplx(x,x) + cmplx(y,y))*pe(x,y) = r(x,y)
c
c     on the (x,y) region
c
c         [1/4,3/4] X [1/3,2/3]
c
c     with specified boundaries at upper x boundry xb = 3/4 and
c     the lower y boundary yc = 1/3 and mixed boundary conditions
c     at the lower x boundry xa = 1/4
c
c          dp/dx - p = g(y)
c
c     and upper y boundary yd = 2/3
c
c          dp/dy + p = h(x)
c
c     Use point relaxation, the default multigrid options and
c     the exact solution
c
c          pe(x,y) = cmplx(y**5,x**4+1.0)
c
c     to set the righthand side, boundary conditions, and compute
c     error.  the approximation is generated on a 129 by 97 grid.
c     First cud2sp is called to render a second-order approximation.
c     then cud24sp is called for a fourth-order estimate
c
c
c *************************************************************
c     output (64 bit floating point arithmetic)
c *************************************************************
c
c     cud2sp test
c
c     integer input arguments
c     intl =  0 nxa =  2 nxb =  1 nyc =  1 nyd =  2
c     ixp =  2 jyq =  3 iex =  7 jey =  6
c     nx = 129 ny =  97 iguess =  0 maxcy =  3
c     method =  0 work space estimate =   48976
c
c     multigrid option arguments
c     kcycle =  0
c     iprer =  0
c     ipost =  0
c     intpol =  0
c
c     floating point input parameters
c     xa =  0.000 xb =  1.000 yc =  0.000 yd =  1.000
c     tolerance (error control) =    0.000E+00
c
c     discretization call to cud2sp intl =  0
c     ierror =  0 minimum work space =   48976
c
c     approximation call to cud2sp
c     intl =  1 method =  0 iguess =  0
c     ierror =  0
c     maximum error  =   0.317E-03
c
c     cud24sp test  ierror =  0
c     maximum error  =   0.621E-06
c
c ***************************************************************
c      end of output
c ***************************************************************
c
      program tcud24sp
      implicit none
      integer iixp,jjyq,iiex,jjey,nnx,nny,llw
c
c     set grid sizes with parameter statements
c
      parameter (iixp = 2 , jjyq = 3 , iiex =7, jjey = 6)
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     set minimum required work space (see tmud2sp.f)
c
      parameter (llw = 48976)
c
c     dimension solution,right hand side, and work arrays
c
      complex p(nnx,nny),r(nnx,nny),w(llw)
c     put integer and floating point parameter names in contiguous
c     storeage for labelling purposes
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itcud2sp/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftcud2sp/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      complex cxx,cyy,cx,cy,ce,pxx,pyy,px,py,pe
      complex pe,px,py,pxx,pyy,cxx,cyy,cx,cy,cex,cey,ce
      real dlx,dly,x,y,errmax
c
c     declare coefficient and boundary condition input subroutines external
c
      external cfx,cfy,bndc
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 2
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set three multigrid cycles
c
      maxcy = 3
c
c     set work space length approximation from parameter statement
c
      nwork = llw
c
c     set point relaxation
c
      method = 0
c
c     flag no initial guess (this sets full multigrid cycling)
c
      iguess = 0
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in r
c     initialize p to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	call cfx(x,cxx,cx,cex)
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cfy(y,cyy,cy,cey)
	  ce = cex+cey
	  call exact(x,y,pxx,pyy,px,py,pe)
	  r(i,j) = cxx*pxx+cyy*pyy+cx*px+cy*py+ce*pe
	  p(i,j) = (0.0,0.0)
	end do
      end do
c
c     set specified boundaries in p
c
      x = xb
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pyy,px,py,pe)
	p(nx,j) = pe
      end do
      y = yc
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exact(x,y,pxx,pyy,px,py,pe)
	p(i,1) = pe
      end do
c
c     set default multigrid opitons
c
      mgopt(1) = 0
c
c     print input parameters (except multigrid options which are default)
c
      write(6,100)
  100 format(//' cud2sp test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to cud2sp', ' intl = ', i2)
      call cud2sp(iprm,fprm,w,cfx,cfy,bndc,r,p,mgopt,ierror)
c
c     print error parameter and minimum work space requirement
c
      write (*,105) ierror,iprm(16)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess
  106 format(/' approximation call to cud2sp ',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2)
      call cud2sp(iprm,fprm,w,cfx,cfy,bndc,r,p,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
c
c     compute and print exact maximum error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pyy,px,py,pe)
	  errmax = amax1(errmax,cabs((p(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
  108 format(' maximum error  =  ',e10.3)
c
c     fourth-order estimate
c
      call cud24sp(w,p,ierror)
      write(*,109) ierror
  109 format(/' cud24sp test ', ' ierror = ',i2)
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pyy,px,py,pe)
	  errmax = amax1(errmax,cabs((p(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
      end

      subroutine cfx(x,cxx,cx,cex)
c
c     input x dependent complex coefficients
c
      implicit none
      real x
      complex cxx,cx,cex
      cxx = cmplx(1.+x*x,1.-x*x)
      cx = (0.,0.)
      cex = -cmplx(x,x)
      return
      end

      subroutine cfy(y,cyy,cy,cey)
c
c     input y dependent complex coefficients
c
      implicit none
      real y
      complex cyy,cy,cey
      cyy = cmplx(exp(1.0-y),exp(y))
      cy = -cyy
      cey = -cmplx(y,y)
      return
      end

      subroutine bndc(kbdy,xory,cons,gbdy)
c
c     input mixed complex derivative b.c. to cud2sp
c
      implicit none
      integer kbdy
      real xory,x,y
      complex cons,gbdy,pe,px,py,pxx,pyy
      real xa,xb,yc,yd,tolmax,relmax
      common/ftcud2sp/xa,xb,yc,yd,tolmax,relmax
      if (kbdy.eq.1) then
c
c     x=xa boundary
c
	y = xory
	x = xa
	cons =(-1.0,0.0)
	call exact(x,y,pxx,pyy,px,py,pe)
	gbdy = px + cons*pe
	return
      end if
      if (kbdy.eq.4) then
c
c     y=yd boundary
c
	y = yd
	x = xory
	cons = (1.0,0.0)
	call exact(x,y,pxx,pyy,px,py,pe)
	gbdy = py + cons*pe
	return
      end if
      end

      subroutine exact(x,y,pxx,pyy,px,py,pe)
c
c     set exact solution used for testing cud2sp
c
      implicit none
      real x,y
      complex pe,px,py,pxx,pyy
      pe = cmplx(y**5.,x**4+1.)
      px = cmplx(0.,4.*x**3)
      pxx = cmplx(0.,12.*x**2)
      py = cmplx(5.*y**4,0.)
      pyy = cmplx(20.*y**3,0.)
      return
      end
</PRE>
<HR>
 
<a name="tcud2cr.txt"><b>TCUD2CR</b></a>
<PRE>
c
c     file tcud2cr.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the complex MUDPACK solver cud2cr
c
c ... required MUDPACK files
c
c     cud2cr.f, cudcom.f
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cud2cr
c
c **********************************************************
c **********************************************************
c
c     a sample program/test driver for cud2cr is below.  it can
c     be executed as an initial test.  the output is listed for
c     the test case described.
c
c     test the driver below by solving the elliptic pde
c
c      cmplx(1.+y*y,1.-y*y)*d(dp/dx)/dx + cmplx(x*y,-x*y)*d(dp/dx)/dy
c
c      cmplx(1.+x*x,1.-x*x)*d(dp/dy)/dy + cmplx(y,-y)*dp/dx +
c
c      cmplx(x,-x)*dp/dy + cmplx(x+y,-x-y)*p(x,y) = r(x,y)
c
c     on the unit square with specified boundary conditions at
c     xa=0.0, xb=1.0, yc=0.0 and mixed boundary conditions at yd=1.0
c     of the form:
c
c     cmplx(-x,x)*dp/dx+cmplx(1.+x,1.-x)*dp/dy+cmplx(-x,x)*p(x,yd)=gbdyd(x)
c
c     choose a 49 x 65 grid and use line relaxation in the y direction.
c     forr testing purposes use the exact solution
c
c       p(x,y) = cmplx((x*y)**3,-(x*y)**3) + (1.,1.)
c
c ******************************************************
c     output (32 bit floating point arithmetic)
c *******************************************************
c
c     cud2cr test
c
c     integer input arguments
c     intl =  0 nxa =  1 nxb =  1 nyc =  1 nyd =  2
c     ixp =  3 jyq =  2 iex =  5 jey =  6
c     nx =  49 ny =  65 iguess =  0 maxcy =  1
c     method =  2 work space estimate =   67426
c
c     multigrid option arguments
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     xa =  0.000 xb =  1.000 yc =  0.000 yd =  1.000
c     tolerance (error control) =    0.000E+00
c
c     discretization call to cud2cr intl =  0
c     ierror =  0 minimum work space =   64474
c
c     approximation call to cud2cr
c     intl =  1 method =  2 iguess =  0
c     ierror =  0
c     maximum error  =   0.188E-03
c
c **********************************************************
c     end of output
c **********************************************************
c
      program tcud2cr
      implicit none
      integer iixp,jjyq,iiex,jjey,nnx,nny,llw
c
c     set grid sizes with parameter statements
c
      parameter (iixp = 3 , jjyq = 2 , iiex =5, jjey = 6)
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     estimate work length approximation for method=0 (see cud2cr.d)
c
      parameter (llw=(7*(nnx+2)*(nny+2)+56*nnx*nny)/3)
c
c     dimension solution,right hand side, and work arrays
c
      complex p(nnx,nny),r(nnx,nny),w(llw)
c     put integer and floating point parameter names in contiguous
c     storeage for labelling purposes
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itcud2cr/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftcur2/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      complex cxx,cxy,cyy,cx,cy,ce,pxx,pxy,pyy,px,py,pe
      real dlx,dly,x,y,errmax
c
c     declare coefficient and boundary condition input subroutines external
c
      external cofcr,bndcr
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set for one multigrid cycle
c
      maxcy = 1
c
c     set work space length approximation from parameter statement
c
      nwork = llw
c
c     set point relaxation
c
      method = 2
c
c     flag no initial guess (this sets full multigrid cycling)
c
      iguess = 0
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in r
c     initialize p to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cofcr(x,y,cxx,cxy,cyy,cx,cy,ce)
	  call exact(x,y,pxx,pxy,pyy,px,py,pe)
	  r(i,j) = cxx*pxx+cxy*pxy+cyy*pyy+cx*px+cy*py+ce*pe
	  p(i,j) = (0.0,0.0)
	end do
      end do
c
c     set specified boundaries in p
c
      x = xa
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pxy,pyy,px,py,pe)
	p(1,j) = pe
      end do
      x = xb
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pxy,pyy,px,py,pe)
	p(nx,j) = pe
      end do
      y = yc
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exact(x,y,pxx,pxy,pyy,px,py,pe)
	p(i,1) = pe
      end do
c
c     set default multigrid opitons
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     print input parameters (except multigrid options which are default)
c
      write(6,100)
  100 format(//' cud2cr test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to cud2cr', ' intl = ', i2)
      call cud2cr(iprm,fprm,w,cofcr,bndcr,r,p,mgopt,ierror)
c
c     print error parameter and minimum work space requirement
c
      write (*,105) ierror,iprm(16)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess
  106 format(/' approximation call to cud2cr',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2)
      call cud2cr(iprm,fprm,w,cofcr,bndcr,r,p,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
c
c     compute and print exact maximum error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pxy,pyy,px,py,pe)
	  errmax = amax1(errmax,cabs((p(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
  108 format(' maximum error  =  ',e10.3)
      end

      subroutine cofcr(x,y,cxx,cxy,cyy,cx,cy,ce)
c
c     input pde coefficients at any point (x,y) in the solution region
c     (xa.le.x.le.xb,yc.le.y.le.yd) to cud2cr
c
      implicit none
      complex cxx,cxy,cyy,cx,cy,ce
      real x,y,xa,xb,yc,yd,tolmax,relmax
      common/ftcur2/xa,xb,yc,yd,tolmax,relmax
      cxx = cmplx(1.+y**2,1.-y**2)
      cxy = cmplx(x*y,-x*y)
      cyy = cmplx(1.+x**2,1.-x*x)
      cx = cmplx(y,-y)
      cy = cmplx(x,-x)
      ce = -cmplx((x+y),-x-y)
      return
      end

      subroutine bndcr(kbdy,xory,alfa,beta,gama,gbdy)
c
c     input mixed "oblique" derivative b.c. to cud2cr
c
      implicit none
      integer kbdy
      real xory,x,y,xa,xb,yc,yd,tolmax,relmax
      complex alfa,beta,gama,gbdy,pe,px,py,pxx,pxy,pyy
      common/ftcur2/xa,xb,yc,yd,tolmax,relmax
      if (kbdy.eq.4) then
c
c     y=yd boundary (nyd must equal 2 if this code is to be executed).
c     b.c. has the form alfyd(x)*px+betyd(x)*py+gamyd(x)*pe = gbdyd(x)
c     where x = yorx.   alfa,beta,gama,gbdy corresponding to alfyd(x),
c     betyd(x),gamyd(x),gbdyd(y) must be output.
c
	y = yd
	x = xory
	alfa = -cmplx(x,-x)
	beta = cmplx(1.+x,1.-x)
	gama = -cmplx(x,-x)
	call exact(x,y,pxx,pxy,pyy,px,py,pe)
	gbdy = alfa*px + beta*py + gama*pe
	return
      end if
      end

      subroutine exact(x,y,pxx,pxy,pyy,px,py,pe)
c
c     this subroutine is used for setting an exact solution in order
c     to test subroutine cud2cr.
c
      implicit none
      real x,y,xy,xy2,xy3
      complex pxx,pxy,pyy,px,py,pe
      xy = x*y
      xy2 = xy*xy
      xy3 = xy2*xy
      pe = cmplx(xy3,-xy3)
      px = 3.*y*cmplx(xy2,-xy2)
      py = 3.*x*cmplx(xy2,-xy2)
      pxx = 6.*y*y*cmplx(xy,-xy)
      pxy = 9.*xy*cmplx(xy,-xy)
      pyy = 6.*x*x*cmplx(xy,-xy)
      return
      end

</PRE>
<HR>
 
<a name="tcud2sp.txt"><b>TCUD2SP</b></a>
<PRE>
c
c     file tcud2sp.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the complex MUDPACK solver cud2sp
c
c ... required MUDPACK files
c
c     cud2sp.f, cudcom.f
c
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cud2sp
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for cud2sp is listed below.  it
c     can be executed as an initial test.  the output is listed for
c     the test case described.
c
c     test the driver below by solving the complex separable elliptic pde
c
c          cmplx(1.+x*x,1-x*x)*pxx + cmplx(exp(1.-y),exp(y))*(pyy-py) -
c
c          (cmplx(x,x) + cmplx(y,y))*pe(x,y) = r(x,y)
c
c     on the (x,y) region
c
c         [1/4,3/4] X [1/3,2/3]
c
c     with specified boundaries at upper x boundry xb = 3/4 and
c     the lower y boundary yc = 1/3 and mixed boundary conditions
c     at the lower x boundry xa = 1/4
c
c          dp/dx - p = g(y)
c
c     and upper y boundary yd = 2/3
c
c          dp/dy + p = h(x)
c
c     Use point relaxation, the default multigrid options and
c     the exact solution
c
c          pe(x,y) = cmplx(y**5,x**4+1.0)
c
c     to set the righthand side, boundary conditions, and compute
c     error.  the approximation is generated on a 129 by 97 grid.
c
c *************************************************************
c     output (32 bit floating point arithmetic)
c *************************************************************
c
c     cud2sp test
c
c     integer input arguments
c     intl =  0 nxa =  2 nxb =  1 nyc =  1 nyd =  2
c     ixp =  2 jyq =  3 iex =  7 jey =  6
c     nx = 129 ny =  97 iguess =  0 maxcy =  3
c     method =  0 work space estimate =   64825
c
c     multigrid option arguments
c     kcycle =  0
c     iprer =  0
c     ipost =  0
c     intpol =  0
c
c     floating point input parameters
c     xa =  0.000 xb =  1.000 yc =  0.000 yd =  1.000
c     tolerance (error control) =    0.000E+00
c
c     discretization call to cud2sp intl =  0
c     ierror =  0 minimum work space =   48976
c
c     approximation call to cud2sp
c     intl =  1 method =  0 iguess =  0
c     ierror =  0
c     maximum error  =   0.328E-03
c
c ***************************************************************
c      end of output
c ***************************************************************
c
      program tcud2sp
      implicit none
      integer iixp,jjyq,iiex,jjey,nnx,nny,llw
c
c     set grid sizes with parameter statements
c
      parameter (iixp = 2 , jjyq = 3 , iiex =7, jjey = 6)
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     estimate work length approximation for method=0 (see cud2sp.d)
c
      parameter (llw = 5*(nnx*nny+2*(nnx+nny)))
c
c     dimension solution,right hand side, and work arrays
c
      complex p(nnx,nny),r(nnx,nny),w(llw)
c     put integer and floating point parameter names in contiguous
c     storeage for labelling purposes
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itcud2sp/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftcud2sp/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      complex cxx,cyy,cx,cy,ce,pxx,pyy,px,py,pe
      complex pe,px,py,pxx,pyy,cxx,cyy,cx,cy,cex,cey,ce
      real dlx,dly,x,y,errmax
c
c     declare coefficient and boundary condition input subroutines external
c
      external cfx,cfy,bndc
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 2
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set three multigrid cycles
c
      maxcy = 3
c
c     set work space length approximation from parameter statement
c
      nwork = llw
c
c     set point relaxation
c
      method = 0
c
c     flag no initial guess (this sets full multigrid cycling)
c
      iguess = 0
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in r
c     initialize p to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	call cfx(x,cxx,cx,cex)
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cfy(y,cyy,cy,cey)
	  ce = cex+cey
	  call exact(x,y,pxx,pyy,px,py,pe)
	  r(i,j) = cxx*pxx+cyy*pyy+cx*px+cy*py+ce*pe
	  p(i,j) = (0.0,0.0)
	end do
      end do
c
c     set specified boundaries in p
c
      x = xb
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pyy,px,py,pe)
	p(nx,j) = pe
      end do
      y = yc
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exact(x,y,pxx,pyy,px,py,pe)
	p(i,1) = pe
      end do
c
c     set default multigrid opitons
c
      mgopt(1) = 0
c
c     print input parameters (except multigrid options which are default)
c
      write(6,100)
  100 format(//' cud2sp test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to cud2sp', ' intl = ', i2)
      call cud2sp(iprm,fprm,w,cfx,cfy,bndc,r,p,mgopt,ierror)
c
c     print error parameter and minimum work space requirement
c
      write (*,105) ierror,iprm(16)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess
  106 format(/' approximation call to cud2sp ',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2)
      call cud2sp(iprm,fprm,w,cfx,cfy,bndc,r,p,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
c
c     compute and print exact maximum error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pyy,px,py,pe)
	  errmax = amax1(errmax,cabs((p(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
  108 format(' maximum error  =  ',e10.3)
      end

      subroutine cfx(x,cxx,cx,cex)
c
c     input x dependent complex coefficients
c
      implicit none
      real x
      complex cxx,cx,cex
      cxx = cmplx(1.+x*x,1.-x*x)
      cx = (0.,0.)
      cex = -cmplx(x,x)
      return
      end

      subroutine cfy(y,cyy,cy,cey)
c
c     input y dependent complex coefficients
c
      implicit none
      real y
      complex cyy,cy,cey
      cyy = cmplx(exp(1.0-y),exp(y))
      cy = -cyy
      cey = -cmplx(y,y)
      return
      end

      subroutine bndc(kbdy,xory,cons,gbdy)
c
c     input mixed complex derivative b.c. to cud2sp
c
      implicit none
      integer kbdy
      real xory,x,y
      complex cons,gbdy,pe,px,py,pxx,pyy
      real xa,xb,yc,yd,tolmax,relmax
      common/ftcud2sp/xa,xb,yc,yd,tolmax,relmax
      if (kbdy.eq.1) then
c
c     x=xa boundary
c
	y = xory
	x = xa
	cons =(-1.0,0.0)
	call exact(x,y,pxx,pyy,px,py,pe)
	gbdy = px + cons*pe
	return
      end if
      if (kbdy.eq.4) then
c
c     y=yd boundary
c
	y = yd
	x = xory
	cons = (1.0,0.0)
	call exact(x,y,pxx,pyy,px,py,pe)
	gbdy = py + cons*pe
	return
      end if
      end

      subroutine exact(x,y,pxx,pyy,px,py,pe)
c
c     set exact solution used for testing cud2sp
c
      implicit none
      real x,y
      complex pe,px,py,pxx,pyy
      pe = cmplx(y**5.,x**4+1.)
      px = cmplx(0.,4.*x**3)
      pxx = cmplx(0.,12.*x**2)
      py = cmplx(5.*y**4,0.)
      pyy = cmplx(20.*y**3,0.)
      return
      end
</PRE>
<HR>
 
<a name="tcud3.txt"><b>TCUD3</b></a>
<PRE>
c
c     file tcud3.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver cud3
c
c ... required MUDPACK files
c
c     cud3.f, cudcom.f, cud3ln.f, cud3pn.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cud3
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for cud3 is below. it can be
c     executed as an initial test.  the output is listed for the
c     test case described.
c
c     test the driver below by solving the complex nonseparable
c     linear elliptic pde
c
c          cmplx(y,z)*d(dp/dx)/dx + cmplx(x,z)*d(dp/dy)/dy +
c
c          cmplx(x,y)*d(dp/dz)/dz - cmplx(y+z,x+y)*pe(x,y,z)
c
c          = r(x,y,z)
c
c     on the box [0.5,1.0] x [0.5,1.0] x [0.0,1.0] with dirchlet
c     boundary conditions at the x and y boundaries and periodic
c     boundary conditions in the z direction.  use point relaxation
c     and choose a grid 33 by 33 by 97 grid.  use the exact solution
c
c          pe(x,y,z) = exp(x*y)*cmplx(cos(tpi*z),sin(tpi*z))
c
c     for testing (tpi = 8.0*atan(1.0)).
c
c
c ******************************************************
c     output (32 bit floating point arithmetic)
c *******************************************************
c
c     cud3 test
c
c     input arguments
c     intl =  0 nxa =  1 nxb =  1 nyc =  1 nyd =  1
c     nze =  0 nzf =  0
c     ixp =  2 jyq =  2 kzr =  3
c     iex =  5 jey =  5 kez =  6
c     nx =  33 ny =  33 nz =  97 iguess =  0 maxcy =  1
c     method =  3 work space length input = 1940400
c     xa =  0.50 xb =  1.00
c     yc =  0.50 yd =  1.00
c     ze =  0.00 zf =  1.00
c     tolmax =  0.000e+00
c
c     multigrid options
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     discretization call to cud3 intl =  0
c     ierror =  0 minimum work space = 1854498
c
c     approximation call to cud3
c     intl =  1 method =  3 iguess =  0 maxcy =  1
c     ierror =  0
c     maximum error  =   0.361e-03
c
c ************************************************************
c     end of output
c ************************************************************
c
      program tcud3
      implicit none
c
c     set grid sizes with parameter statements
c
      integer iixp,jjyq,kkzr,iiex,jjey,kkez,llwork,nnx,nny,nnz
      parameter(iixp=2,jjyq=2,kkzr=3)
      parameter(iiex=5,jjey=5,kkez=6)
      parameter (nnx = iixp*2**(iiex-1)+1)
      parameter (nny = jjyq*2**(jjey-1)+1)
      parameter (nnz = kkzr*2**(kkez-1)+1)
c
c     set work space length estimate for method=3 (see cud3.d).
c     this will probably overestimate required space
c
      parameter (llwork = 16*(nnx+2)*(nny+2)*(nnz+2) )
c
c
c     dimension solution,right hand side, and work arrays
c
      complex phi(nnx,nny,nnz),rhs(nnx,nny,nnz),work(llwork)
      integer iprm(23),mgopt(4)
      real fprm(8)
c
c     put integer and floating point arguments names in contiguous
c     storeage labelling
c
      integer intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,
     +              lwrkqd,itero
      common/itcud3/intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,
     +              lwrkqd,itero

      real xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      common/ftcud3/xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      real dlx,dly,dlz,x,y,z,errm
      complex cxx,cyy,czz,cx,cy,cz,ce, pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k,ierror
      equivalence(intl,iprm)
      equivalence(xa,fprm)
c
c     declare coefficient and boundary condition input subroutines external
c
      external cof,bndc
      tpi = 8.0*atan(1.0)
c
c     set for initial call
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 1
      nyc = 1
      nyd = 1
      nze = 0
      nzf = 0
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      kzr = kkzr
      iex = iiex
      jey = jjey
      kez = kkez
      nx = nnx
      ny = nny
      nz = nnz
c
c     set for one multigrid cycles
c
      maxcy = 1
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set method of relaxation--line in the z direction
c
      method = 3
c
c     meth2 only used in planar relaxation--but set
c
      meth2 = 0
c
c     set full multigrid cycling by flagging no initial guess at the finest
c     grid level
c
      iguess = 0
c
c     set end points of solution region in (x,y,z) space
c
      xa = 0.5
      xb = 1.0
      yc = 0.5
      yd = 1.0
      ze = 0.0
      zf = 1.0
c
c     set default multigrid options
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
      dlz = (zf-ze)/float(nz-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in rhs and phi to zero
c
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    rhs(i,j,k) = cxx*pxx+cyy*pyy+czz*pzz+cx*px+cy*py+cz*pz+ce*pe
	    phi(i,j,k) = (0.,0.)
	  end do
	end do
      end do
c
c     set specified values at x and y boundaries in phi
c
      x = xa
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(1,j,k) = pe
	end do
      end do
      x = xb
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(nx,j,k) = pe
	end do
      end do
      y = yc
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,1,k) = pe
	end do
      end do
      y = yd
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,ny,k) = pe
	end do
      end do
      write(6,50)
   50 format(//' cud3 test ')
c
c     print input arguments
c
      write(6,100)intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,kez,
     +            nx,ny,nz,iguess,maxcy,method,nwork,xa,xb,yc,yd,ze,zf,
     +            tolmax,mgopt(1),mgopt(2),mgopt(3),mgopt(4)
  100 format(/' input arguments ',
     +/' intl = ',i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = 'i2,
     +/' nze = ',i2, ' nzf = ',i2,
     +/' ixp = ',i2,' jyq = 'i2,' kzr = 'i2,
     +/' iex = ',i2, ' jey = 'i2, ' kez = 'i2,
     +/' nx = 'i3,' ny = 'i3,' nz = 'i3, ' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space length input = ',i7,
     +/' xa = 'f5.2,' xb = 'f5.2,
     +/' yc = 'f5.2,' yd = 'f5.2,
     +/' ze = 'f5.2,' zf = 'f5.2,
     +/' tolmax = ' ,e10.3
     +//' multigrid options '
     +/' kcycle = ',i2
     +/' iprer = ',i2
     +/' ipost = ',i2
     +/' intpol = ',i2 )
c
c     discretize pde
c
      write(*,104) intl
  104 format(/' discretization call to cud3', ' intl = ', i2)
      call cud3(iprm,fprm,work,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,105) ierror,iprm(22)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     approximate pde
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to cud3 ',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call cud3(iprm,fprm,work,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum error
c
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
  108 format(' maximum error  =  ',e10.3)
      end

      subroutine error(nx,ny,nz,phi,errm)
c
c     compute the error in the estimate in phi
c
      implicit none
      integer nx,ny,nz
      complex phi(nx,ny,nz)
      real xa,xb,yc,yd,ze,zf,tolmax,relmax,errm,tpi
      common/ftcud3/xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      real dlx,dly,dlz,x,y,z
      complex pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k
      dlx = (xb-xa)/(nx-1)
      dly = (yd-yc)/(ny-1)
      dlz = (zf-ze)/(nz-1)
      errm = 0.0
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    errm = amax1(errm,abs(phi(i,j,k)-pe))
	  end do
	end do
      end do
      return
      end

      subroutine cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
c
c     input pde coefficients at grid point (x,y,z) in the solution region
c     to subroutine cud3
c
      implicit none
      complex cxx,cyy,czz,cx,cy,cz,ce
      real x,y,z
      cxx = cmplx(y,z)
      cyy = cmplx(x,z)
      czz = cmplx(x,y)
      cx = (0.,0.)
      cy = cx
      cz = cz
      ce = -cmplx(y+z,x+z)
      return
      end

      subroutine bndc(kbdy,xory,yorz,alfa,gbdy)
c
c     dummy subroutine since no mixed derivative b.c.
c
      implicit none
      integer kbdy
      real xory,yorz
      complex alfa,gbdy
      return
      end

      subroutine exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
c
c     this subroutine is used to set an exact solution for testing cud3
c
      implicit none
      real x,y,z
      complex pxx,pyy,pzz,px,py,pz,pe
      real xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      common/ftcud3/xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      pe = exp(x*y)*cmplx(cos(tpi*z),sin(tpi*z))
      px = y*pe
      py = x*pe
      pz = tpi*exp(x*y)*cmplx(-sin(tpi*z),cos(tpi*z))
      pxx = y*y*pe
      pyy = x*x*pe
      pzz = -tpi*tpi*pe
      return
      end

</PRE>
<HR>
 
<a name="tcud34.txt"><b>TCUD34</b></a>
<PRE>
c
c     file tcud34.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver cud34
c
c ... required MUDPACK files
c
c     cud34.f, cud3.f, cudcom.f, cud3ln.f, cud3pn.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cud34
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for cud34 is below. it can be
c     executed as an initial test.  the output is listed for the
c     test case described.
c
c     test the driver below by solving the complex nonseparable
c     linear elliptic pde
c
c          cmplx(y,z)*d(dp/dx)/dx + cmplx(x,z)*d(dp/dy)/dy +
c
c          cmplx(x,y)*d(dp/dz)/dz - cmplx(y+z,x+y)*pe(x,y,z)
c
c          = r(x,y,z)
c
c     on the box [0.5,1.0] x [0.5,1.0] x [0.0,1.0] with Dirchlet
c     boundary conditions at the x and y boundaries and periodic
c     boundary conditions in the z direction.  use point relaxation
c     and choose a grid 33 by 33 by 97 grid.  use the exact solution
c
c          pe(x,y,z) = exp(x*y)*cmplx(cos(tpi*z),sin(tpi*z))
c
c     for testing (tpi = 8.0*atan(1.0)).  First cud3 is called with
c     iguess=0, maxcy=1 to force one full multigrid cycle as in tcud3.f.
c     Then, to ensure second order discretization level error is reached
c     (a requirement for fourth-order mudpack solvers), 3 additional
c     cycles are executed from the finest grid level (iguess=1) with
c     cud3.  Finally, cud34 is called for a fourth-order estimate.
c
c ******************************************************
c     output (64 bit floating point arithmetic)
c *******************************************************
c
c     cud3 test
c
c     input arguments
c     intl =  0 nxa =  1 nxb =  1 nyc =  1 nyd =  1
c     nze =  0 nzf =  0
c     ixp =  2 jyq =  2 kzr =  3
c     iex =  5 jey =  5 kez =  6
c     nx =  33 ny =  33 nz =  97 iguess =  0 maxcy =  1
c     method =  3 work space length input = 1854498
c     xa =  0.50 xb =  1.00
c     yc =  0.50 yd =  1.00
c     ze =  0.00 zf =  1.00
c     tolmax =  0.000E+00
c
c     multigrid options
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     discretization call to cud3 intl =  0
c     ierror =  0 minimum work space = 1854498
c
c     approximation call to cud3
c     intl =  1 method =  3 iguess =  0 maxcy =  1
c     ierror =  0
c     maximum error  =   0.380E-03
c
c     approximation call to cud3
c     intl =  1 method =  3 iguess =  1 maxcy =  3
c     ierror =  0
c     maximum error  =   0.381E-03
c
c     cud24 test  ierror =  0
c     maximum error  =   0.632E-06
c
c ************************************************************
c     end of output
c ************************************************************
c
      program tcud34
      implicit none
c
c     set grid sizes with parameter statements
c
      integer iixp,jjyq,kkzr,iiex,jjey,kkez,llwork,nnx,nny,nnz
      parameter(iixp=2,jjyq=2,kkzr=3)
      parameter(iiex=5,jjey=5,kkez=6)
      parameter (nnx = iixp*2**(iiex-1)+1)
      parameter (nny = jjyq*2**(jjey-1)+1)
      parameter (nnz = kkzr*2**(kkez-1)+1)
c
c     set minimal required work space (see tcud3.f) for this grid
c
      parameter (llwork = 1854498 )
c
c
c     dimension solution,right hand side, and work arrays
c
      complex phi(nnx,nny,nnz),rhs(nnx,nny,nnz),work(llwork)
      integer iprm(23),mgopt(4)
      real fprm(8)
c
c     put integer and floating point arguments names in contiguous
c     storeage labelling
c
      integer intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,
     +              lwrkqd,itero
      common/itcud3/intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,
     +              lwrkqd,itero

      real xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      common/ftcud3/xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      real dlx,dly,dlz,x,y,z,errm
      complex cxx,cyy,czz,cx,cy,cz,ce, pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k,ierror
      equivalence(intl,iprm)
      equivalence(xa,fprm)
c
c     declare coefficient and boundary condition input subroutines external
c
      external cof,bndc
      tpi = 8.0*atan(1.0)
c
c     set for initial call
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 1
      nyc = 1
      nyd = 1
      nze = 0
      nzf = 0
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      kzr = kkzr
      iex = iiex
      jey = jjey
      kez = kkez
      nx = nnx
      ny = nny
      nz = nnz
c
c     set for one multigrid cycles
c
      maxcy = 1
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set method of relaxation--line in the z direction
c
      method = 3
c
c     meth2 only used in planar relaxation--but set
c
      meth2 = 0
c
c     set full multigrid cycling by flagging no initial guess at the finest
c     grid level
c
      iguess = 0
c
c     set end points of solution region in (x,y,z) space
c
      xa = 0.5
      xb = 1.0
      yc = 0.5
      yd = 1.0
      ze = 0.0
      zf = 1.0
c
c     set default multigrid options
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
      dlz = (zf-ze)/float(nz-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in rhs and phi to zero
c
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    rhs(i,j,k) = cxx*pxx+cyy*pyy+czz*pzz+cx*px+cy*py+cz*pz+ce*pe
	    phi(i,j,k) = (0.,0.)
	  end do
	end do
      end do
c
c     set specified values at x and y boundaries in phi
c
      x = xa
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(1,j,k) = pe
	end do
      end do
      x = xb
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(nx,j,k) = pe
	end do
      end do
      y = yc
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,1,k) = pe
	end do
      end do
      y = yd
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,ny,k) = pe
	end do
      end do
      write(6,50)
   50 format(//' cud3 test ')
c
c     print input arguments
c
      write(6,100)intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,kez,
     +            nx,ny,nz,iguess,maxcy,method,nwork,xa,xb,yc,yd,ze,zf,
     +            tolmax,mgopt(1),mgopt(2),mgopt(3),mgopt(4)
  100 format(/' input arguments ',
     +/' intl = ',i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = 'i2,
     +/' nze = ',i2, ' nzf = ',i2,
     +/' ixp = ',i2,' jyq = 'i2,' kzr = 'i2,
     +/' iex = ',i2, ' jey = 'i2, ' kez = 'i2,
     +/' nx = 'i3,' ny = 'i3,' nz = 'i3, ' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space length input = ',i7,
     +/' xa = 'f5.2,' xb = 'f5.2,
     +/' yc = 'f5.2,' yd = 'f5.2,
     +/' ze = 'f5.2,' zf = 'f5.2,
     +/' tolmax = ' ,e10.3
     +//' multigrid options '
     +/' kcycle = ',i2
     +/' iprer = ',i2
     +/' ipost = ',i2
     +/' intpol = ',i2 )
c
c     discretize pde
c
      write(*,104) intl
  104 format(/' discretization call to cud3', ' intl = ', i2)
      call cud3(iprm,fprm,work,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,105) ierror,iprm(22)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     approximate pde
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to cud3 ',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call cud3(iprm,fprm,work,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum error
c
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
  108 format(' maximum error  =  ',e10.3)
c
c     execut three more cycles from finest grid level to ensure
c     second-order approximation is reached
c
      iguess = 1
      maxcy = 3
      write(*,106) intl,method,iguess,maxcy
      call cud3(iprm,fprm,work,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,107) ierror
      if (ierror.gt.0) call exit(0)
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
c
c     attempt to compute fourth-order estimate
c
      call cud34(work,phi,ierror)
      write(*,109) ierror
  109 format (/ ' cud24 test ', ' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
      end

      subroutine error(nx,ny,nz,phi,errm)
c
c     compute the error in the estimate in phi
c
      implicit none
      integer nx,ny,nz
      complex phi(nx,ny,nz)
      real xa,xb,yc,yd,ze,zf,tolmax,relmax,errm,tpi
      common/ftcud3/xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      real dlx,dly,dlz,x,y,z
      complex pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k
      dlx = (xb-xa)/(nx-1)
      dly = (yd-yc)/(ny-1)
      dlz = (zf-ze)/(nz-1)
      errm = 0.0
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    errm = amax1(errm,abs(phi(i,j,k)-pe))
	  end do
	end do
      end do
      return
      end

      subroutine cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
c
c     input pde coefficients at grid point (x,y,z) in the solution region
c     to subroutine cud3
c
      implicit none
      complex cxx,cyy,czz,cx,cy,cz,ce
      real x,y,z
      cxx = cmplx(y,z)
      cyy = cmplx(x,z)
      czz = cmplx(x,y)
      cx = (0.,0.)
      cy = cx
      cz = cz
      ce = -cmplx(y+z,x+z)
      return
      end

      subroutine bndc(kbdy,xory,yorz,alfa,gbdy)
c
c     dummy subroutine since no mixed derivative b.c.
c
      implicit none
      integer kbdy
      real xory,yorz
      complex alfa,gbdy
      return
      end

      subroutine exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
c
c     this subroutine is used to set an exact solution for testing cud3
c
      implicit none
      real x,y,z
      complex pxx,pyy,pzz,px,py,pz,pe
      real xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      common/ftcud3/xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      pe = exp(x*y)*cmplx(cos(tpi*z),sin(tpi*z))
      px = y*pe
      py = x*pe
      pz = tpi*exp(x*y)*cmplx(-sin(tpi*z),cos(tpi*z))
      pxx = y*y*pe
      pyy = x*x*pe
      pzz = -tpi*tpi*pe
      return
      end

</PRE>
<HR>
 
<a name="tcud34sp.txt"><b>TCUD34SP</b></a>
<PRE>
c
c     file tcud34sp.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver cud34sp
c
c ... required MUDPACK files
c
c     cud34sp.f, cud3sp.f, cudcom.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cud34sp
c
c **********************************************************
************************************************************
c
c     a sample program/test driver for cud34sp is below. it can be
c     executed as an initial test.  the output is listed for the
c     test case described.
c
c     test cud34sp below by solving the complex separable elliptic pde
c
c        d(cmplx(x,-x)*dp/dx)/dx + d(cmplx(y,-y)*dp/dy)/dy +
c
c        d(cmplx(z,-z)*dp/dz)/dz + cmplx(1.,-1.)*(dp/dx + dp/dy + dp/dz) +
c
c        cmplx(-(x+y+z),x+y+z)*p(x,y,z) = r(x,y,z)
c
c     on the (x,y,z) region
c
c       1/4 < x < 3/4, 1/3 < y < 2/3, 1/5 < z < 4/5
c
c     with dirchlet boundary conditions at the upper x,y,z boundaries
c     and the mixed complex derirvative boundary conditions:
c
c          (1) dp/dx + cmplx(1.,1.)*p(0.5,y,z) = gbdxa(y,z) at x = 1/4
c
c          (2) dp/dy + cmplx(-1.,-1.)*p(x,0.5,z) = gbdyc(x,z) at y = 1/3
c
c          (3) dp/dz + cmplx(1.,-1.)*p(x,y,0.5) = gbdze(x,y) at z = 1/5
c
c     note the complex number multiplying "p" must be constant along
c     each surface.
c
c     use the exact solution
c
c          pe(x,y,z) = cmplx(exp(x+y),exp(y+z))
c
c     for testing and choose a 49 by 33 by 41 grid.  First cud3sp
c     is called with 5 cycles to ensure second-order discretization
c     level error is reached (a requirement for mudpack fourth-order
c     solvers).  Then cud34sp is called for a fourth-order estimate.
c
c ******************************************************
c     output (64 bit floating point arithmetic)
c *******************************************************
c
c     cud3sp test
c
c     input arguments
c     intl =  0 nxa =  2 nxb =  1 nyc =  2 nyd =  1
c     nze =  2 nzf =  1
c     ixp =  3 jyq =  2 kzr =  3
c     iex =  5 jey =  5 kez =  5
c     nx =  49 ny =  33 nz =  49 iguess =  0 maxcy =  5
c     method =  0 work space length input =  291605
c     xa =  0.25 xb =  0.75
c     yc =  0.33 yd =  0.67
c     ze =  0.20 zf =  0.80
c     tolmax =  0.000E+00
c
c     multigrid options
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     discretization call to cud3sp intl =  0
c     ierror =  0 minimum work space =  291605
c
c     approximation call to cud3sp
c     intl =  1 method =  0 iguess =  0 maxcy =  5
c     ierror =  0
c     maximum error  =   0.287E-04
c
c     cud34sp test  ierror =  0
c     maximum error  =   0.592E-07
c
c ************************************************************
c     end of output
c ************************************************************
c
c
      program tcud34sp
      implicit none
c
c     set grid sizes with parameter statements
c
      integer iixp,jjyq,kkzr,iiex,jjey,kkez,llwork,nnx,nny,nnz
      parameter(iixp=3,jjyq=2,kkzr=3)
      parameter(iiex=5,jjey=5,kkez=5)
      parameter (nnx = iixp*2**(iiex-1)+1)
      parameter (nny = jjyq*2**(jjey-1)+1)
      parameter (nnz = kkzr*2**(kkez-1)+1)
c
c     set minimal work space (see tcud3sp.f)
c
      parameter (llwork = 291605)
c
c     dimension solution,right hand side, and work arrays
c
      complex phi(nnx,nny,nnz),rhs(nnx,nny,nnz),work(llwork)
      integer iprm(23),mgopt(4)
      real fprm(8)
c
c     put integer and floating point arguments names in contiguous
c     storeage for labelling purposes
c
      integer intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,nwork,
     +              lwrkqd,itero
      common/itcd3sp/intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,nwork,
     +              lwrkqd,itero
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftcud3sp/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real dlx,dly,dlz,x,y,z,errm
      complex cxx,cyy,czz,cx,cy,cz,ce,cex,cey,cez
      complex pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k,ierror
      equivalence(intl,iprm)
      equivalence(xa,fprm)
c
c     declare coefficient and boundary condition input subroutines external
c
      external cfx,cfy,cfz,bndc
c
c     set for initial call
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 2
      nxb = 1
      nyc = 2
      nyd = 1
      nze = 2
      nzf = 1
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      kzr = kkzr
      iex = iiex
      jey = jjey
      kez = kkez
      nx = nnx
      ny = nny
      nz = nnz
c
c     set  5 multigrid cycles
c
      maxcy = 5
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set point relaxation (only choice with cud3sp)
c
      method = 0
c
c     set full multigrid cycling beginning at coarsest grid
c
      iguess = 0
c
c     set end points of solution region in (x,y,z) space
c
      xa = 0.25
      xb = 0.75
      yc = 1.0/3.0
      yd = 2.0/3.0
      ze = 0.20
      zf = 0.80
c
c     set default multigrid options
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
      dlz = (zf-ze)/float(nz-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in rhs and phi to zero
c
      do k=1,nz
	z = ze+(k-1)*dlz
	call cfz(z,czz,cz,cez)
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cfy(y,cyy,cy,cey)
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call cfx(x,cxx,cx,cex)
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    ce = cex+cey+cez
	    rhs(i,j,k) = cxx*pxx+cyy*pyy+czz*pzz+cx*px+cy*py+cz*pz+ce*pe
	    phi(i,j,k) = (0.,0.)
	  end do
	end do
      end do
c
c     set specified values at upper x,y,z boundaries in phi
c
      x = xb
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(nx,j,k) = pe
	end do
      end do
      y = yd
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,ny,k) = pe
	end do
      end do
      z = zf
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,j,nz) = pe
	end do
      end do
      write(6,50)
   50 format(//' cud3sp test ')
c
c     print input arguments
c
      write(6,100)intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,kez,
     +            nx,ny,nz,iguess,maxcy,method,nwork,xa,xb,yc,yd,ze,zf,
     +            tolmax,mgopt(1),mgopt(2),mgopt(3),mgopt(4)
  100 format(/' input arguments ',
     +/' intl = ',i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = 'i2,
     +/' nze = ',i2, ' nzf = ',i2,
     +/' ixp = ',i2,' jyq = 'i2,' kzr = 'i2,
     +/' iex = ',i2, ' jey = 'i2, ' kez = 'i2,
     +/' nx = 'i3,' ny = 'i3,' nz = 'i3, ' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space length input = ',i7,
     +/' xa = 'f5.2,' xb = 'f5.2,
     +/' yc = 'f5.2,' yd = 'f5.2,
     +/' ze = 'f5.2,' zf = 'f5.2,
     +/' tolmax = ' ,e10.3
     +//' multigrid options '
     +/' kcycle = ',i2
     +/' iprer = ',i2
     +/' ipost = ',i2
     +/' intpol = ',i2 )
c
c     discretize pde only
c
      write(*,104) intl
  104 format(/' discretization call to cud3sp', ' intl = ', i2)
      call cud3sp(iprm,fprm,work,cfx,cfy,cfz,bndc,rhs,phi,mgopt,ierror)
      write (*,105) ierror,iprm(21)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     approximate pde
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to cud3sp ',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call cud3sp(iprm,fprm,work,cfx,cfy,cfz,bndc,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum error
c
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
  108 format(' maximum error  =  ',e10.3)
c
c     attempt fourth-order estimate
c
      call cud34sp(work,phi,ierror)
      write(*,109) ierror
  109 format(/ ' cud34sp test ', ' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
      end

      subroutine error(nx,ny,nz,phi,errm)
c
c     compute the error in the estimate in phi
c
      implicit none
      integer nx,ny,nz
      complex phi(nx,ny,nz)
      real xa,xb,yc,yd,ze,zf,tolmax,relmax,errm
      common/ftcud3sp/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real dlx,dly,dlz,x,y,z
      complex pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k
      dlx = (xb-xa)/(nx-1)
      dly = (yd-yc)/(ny-1)
      dlz = (zf-ze)/(nz-1)
      errm = 0.0
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    errm = amax1(errm,abs(phi(i,j,k)-pe))
	  end do
	end do
      end do
      return
      end
c
c     complex coefficient subroutines
c
      subroutine cfx(x,cxx,cx,cex)
      implicit none
      real x
      complex cxx,cx,cex
      cxx = cmplx(x,-x)
      cx = (1.,-1.)
      cex = cmplx(-x,x)
      return
      end
      subroutine cfy(y,cyy,cy,cey)
      implicit none
      real y
      complex cyy,cy,cey
      cyy= cmplx(y,-y)
      cy = (1.,-1.)
      cey = cmplx(-y,y)
      return
      end
      subroutine cfz(z,czz,cz,cez)
      implicit none
      real z
      complex czz,cz,cez
      czz = cmplx(z,-z)
      cz = (1.,-1.)
      cez = cmplx(-z,z)
      return
      end

      subroutine bndc(kbdy,xory,yorz,cons,gbdy)
c
c     input complex derivative boundary conditions to cud3sp
c
      implicit none
      integer kbdy
      real xory,yorz,x,y,z
      complex cons,gbdy,pe,px,py,pz,pxx,pyy,pzz
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftcud3sp/xa,xb,yc,yd,ze,zf,tolmax,relmax
      if (kbdy.eq.1) then
c
c     x=xa surface
c
	x = xa
	y = xory
	z = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	cons = (1.,1.)
	gbdy = px+cons*pe
	return
      end if
      if (kbdy.eq.3) then
c
c     y=yc surface
c
	y = yc
	x = xory
	z = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	cons = (-1.,-1.)
	gbdy = py+cons*pe
	return
      end if
      if (kbdy.eq.5) then
c
c     z=ze surface
c
	z = ze
	x = xory
	y = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	cons = (1.,-1.)
	gbdy = pz + cons*pe
	return
      end if
      end

      subroutine exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
c
c     this subroutine is used to set an exact solution for testing cud3sp
c     (i.e., setting the rhs, boundary conditions and computing the exact
c     error)
c
      implicit none
      real x,y,z,exy,eyz
      complex pe,px,py,pz,pxx,pyy,pzz
      exy = exp(x+y)
      eyz = exp(y+z)
      pe = cmplx(exy,eyz)
      px = cmplx(exy,0.)
      pxx = px
      py = pe
      pyy = pe
      pz = cmplx(0.,eyz)
      pzz = pz
      return
      end

</PRE>
<HR>
 
<a name="tcud3cr.txt"><b>TCUD3CR</b></a>
<PRE>
c
c     file tcud3cr.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver cud3cr
c
c ... required MUDPACK files
c
c     cud3cr.f, cudcom.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cud3cr (see cud3cr.d)
c
c **********************************************************
c **********************************************************
c
c     a sample program/test driver for cud3cr is below. it can be
c     executed as an initial test.  The output from executing
c     the code in this file is listed after the problem description.
c
c     Problem Description:
c
c     test cud3cr by solving the complex nonseparable 3-d elliptic pde
c     with cross derivative terms:
c
c          cxx*pxx + cyy*pyy + czz*pzz + cx*px + cy*py + cz*pz + ce*pe +
c
c          cxy*pxy + cxz*pxz + cyz*pyz = r(x,y,z).
c
c     on the region 0 < x < 1, 0 < y < (pi+pi), 0 < z < 1.
c     let s = sin(y), c = cos(y).  the complex coefficients are
c     given by:
c
c          cxx = cmplx(1.0+0.5*s*z,1.0+0.5*c*z)
c
c          cyy = (1.,1.)+cmplx(x,z)
c
c          czz = cmplx(1.0+0.5*s*x,1.0+0.5*c*x)
c
c          cx = cy = cz = (0.0,0.0)
c
c          ce = -cmplx(z,x)
c
c          cxy = cmplx(sqrt(real(cxx)*real(cyy),sqrt(aimag(cxx)*aimag(cyy))
c
c          cxz = (0.0,0.0)
c
c          cyz = cmplx(sqrt(real(cyy)*real(czz),sqrt(aimag(cyy)*aimag(czz))
c
c     assume the solution is periodic in y and is specified at x=0 and z=0.
c     further assume mixed oblique derivative conditions of the form
c
c          px + cmplx(z,1-z)*py + cmplx(s,c)*pz - p(1,y,z) = g(y,z)
c
c     at x=1 and mixed normal derivative conditions of the form
c
c          pz + cmplx(x,s*s)*p(x,y,1)  = h(x,y)
c
c     at z=1.  for testing purposes, use the exact solution
c
c          p(x,y,z) = exp(x*z)*cmplx(c,s)
c
c     to set boundary conditions, the right hand side, and compute
c     exact error.  results from approximating this problem on a
c     25 by 65 by 25 x-y-z grid using cud3cr are given below.  point
c     relaxation and an error tolerance of .001 are used.
c
c ******************************************************
c     output (32 bit floating point arithmetic)
c *******************************************************
c
c      cud3cr test
c
c      input arguments
c      intl =  0
c      nxa =  1 nxb =  2
c      nyc =  0 nyd =  0
c      nze =  1 nzf =  2
c      ixp =  3 jyq =  2 kzr =  3
c      iex =  3 jey =  6 kez =  3
c      nx =  13 ny =  65 nz =  13
c      iguess =  0 maxcy =  2
c      method =  0 work space input =  173394
c      xa =  0.00 xb =  1.00
c      yc =  0.00 yd =  6.28
c      ze =  0.00 zf =  1.00
c      tolmax =  0.000E+00
c
c      multigrid options
c      mgopt(1)  =  0
c
c      new cud3cr arguments
c      icrs
c         1    0    1
c      tol = 0.0010
c      maxit =  10
c
c      initial call
c      intl =  0
c      iguess =  0
c      ierror =  0
c      minimum required work space length =   173394
c
c      approximation call
c      intl =  1
c      iguess =  0
c      ierror =   0
c      number of outer iterations executed =   9
c      relative difference profile:
c      0.6567  0.1462  0.0638  0.0203  0.0099  0.0051  0.0016  0.0011  0.0004
c      exact least squares error =  0.127E-02
c
c ************************************************************
c     end of output
c ************************************************************
c
      program tcd3cr
      implicit none
c
c     set grid sizes and predetermined minimal required equired work
c     with parameter statements
c
      integer iixp,jjyq,kkzr,iiex,jjey,kkez,nnx,nny,nnz,llengt,mmaxit
      parameter(iixp=3,jjyq=2,kkzr=3)
      parameter (iiex=3,jjey=6,kkez=3)
      parameter(nnx = iixp*2**(iiex-1)+1)
      parameter(nny = jjyq*2**(jjey-1)+1)
      parameter(nnz = kkzr*2**(kkez-1)+1)
      parameter(llengt=173394)
      parameter(mmaxit = 10)
      complex rhs(nnx,nny,nnz),phi(nnx,nny,nnz),work(llengt)
      integer iparm(23),mgopt(4),icrs(3)
      integer i,j,k,ierror,maxit,iouter
      real fparm(8),rmax(mmaxit)

c
c     use labelled common to identify integer and floating point arguments
c
      integer intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,lwkmin,itero
      common /iprm/intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,lwkmin,itero
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/fprm/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real pi,dx,dy,dz,c,s,x,y,z,tol,err2
      complex cxx,cyy,czz,cx,cy,cz,ce,cxy,cyz
      complex pxx,pyy,pzz,px,py,pz,pxy,pxz,pyz,pe
      equivalence(iparm,intl)
      equivalence(fparm,xa)
      external cof,bd3cr,cxyf,cxzf,cyzf
      pi = 4.*atan(1.)
c
c     set interval end points
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = pi+pi
      ze = 0.0
      zf = 1.0
c
c     set required no error control within multigrid cycling
c
      tolmax = 0.0
c
c     set integer input arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 2
      nyc = 0
      nyd = 0
      nze = 1
      nzf = 2
c
c     set grid size arguments from parameter statements
c
      ixp = iixp
      jyq = jjyq
      kzr = kkzr
      iex = iiex
      jey = jjey
      kez = kkez
      nx = nnx
      ny = nny
      nz = nnz
c
c     flag nonzero xy and yz and zero xz cross derivatives terms
c
      icrs(1) = 1
      icrs(2) = 0
      icrs(3) = 1
c
c     set two multigrid cycles per outer iteration
c
      maxcy = 2
c
c     set point relaxation
c
      method = 0
      meth2 = 0
c
c     set work space length input
c
      nwork = llengt
c
c     set uniform grid interval lengths in each dimension
c
      dx = (xb-xa)/(nx-1)
      dy = (yd-yc)/(ny-1)
      dz = (zf-ze)/(nz-1)
c
c     set right hand side and preset solution to zero
c     this also sets specified (Dirchlet) b.c. in phi
c
      do j=1,ny
	y = (j-1)*dy
	s = sin(y)
	do k=1,nz
	  z = (k-1)*dz
	  do i=1,nx
	    x = (i-1)*dx
	    call exact(x,y,z,pe,px,py,pz,pxx,pyy,pzz,pxy,pxz,pyz)
	    call cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
	    call cxyf(x,y,z,cxy)
	    call cyzf(x,y,z,cyz)
	    rhs(i,j,k) = cxx*pxx+cyy*pyy+czz*pzz+cxy*pxy+cyz*pyz+
     +                   cx*px+cy*py+cz*pz+ce*pe
	    phi(i,j,k) = 0.0
	  end do
	end do
      end do
c
c     set default multigrid options
c
      mgopt(1) = 0
c
c     set error control tolerance and outer iteration limit of 10
c
      tol = .001
      maxit = mmaxit
c
c     print input arguments shared with cud3
c
      write(*,50)
   50 format(//' cud3cr test ' )
      write(6,100)intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,kez,
     +            nx,ny,nz,iguess,maxcy,method,nwork,xa,xb,yc,yd,ze,zf,
     +            tolmax,mgopt(1)
  100 format(/' input arguments ',
     +/' intl = ',i2,
     +/' nxa = ',i2,' nxb = ',i2,
     +/' nyc = ',i2,' nyd = ',i2,
     +/' nze = ',i2,' nzf = ',i2,
     +/' ixp = ',i2,' jyq = 'i2,' kzr = 'i2,
     +/' iex = ',i2, ' jey = 'i2, ' kez = 'i2,
     +/' nx = 'i3,' ny = 'i3,' nz = 'i3,
     +/' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space input = ',i7,
     +/' xa = 'f5.2,' xb = 'f5.2,
     +/' yc = 'f5.2,' yd = 'f5.2,
     +/' ze = 'f5.2,' zf = 'f5.2,
     +/' tolmax = ' ,e10.3
     +//' multigrid options '
     +/' mgopt(1)  = ',i2)
c
c     print new cud3cr arguments
c
      write(*,101) (icrs(i),i=1,3),tol,maxit
  101 format(/' new cud3cr arguments ', / ' icrs '/ 3i5,
     +/' tol = ',f6.4 /' maxit = ',i3)
c
c *** initialization call
c
      intl = 0
      iguess = 0
      call cud3cr(iparm,fparm,work,cof,bd3cr,rhs,phi,mgopt,icrs,
     +cxyf,cxzf,cyzf,tol,maxit,iouter,rmax,ierror)
      write (6,200) intl,iguess,ierror,iparm(22)
  200 format(/' initial call', /' intl = ',i2, /' iguess = ',i2,
     +/' ierror = ',i2, /' minimum required work space length = ',i8)
      if (ierror.gt.0) call exit(0)
c
c *** noninitial call
c
      intl = 1
      iguess = 0
      call cud3cr(iparm,fparm,work,cof,bd3cr,rhs,phi,mgopt,icrs,
     +cxyf,cxzf,cyzf,tol,maxit,iouter,rmax,ierror)
      write (6,201) intl,iguess,ierror,iouter,(rmax(i),i=1,iouter)
  201 format(/' approximation call ', /' intl = ',i2, /' iguess = ',i2,
     +/' ierror = ',i3,
     +/' number of outer iterations executed = ',i3,
     +/' relative difference profile:', /(10(f6.4,2x)))
c
c     compute and print exact least squares error after iouter iterations
c
      err2 = 0.
      do j=1,ny
	y = (j-1)*dy
	c = cos(y)
	do k=1,nz
	  z = (k-1)*dz
	  do i=1,nx
	    x = (i-1)*dx
	    pe = cmplx((x*c*z)**3,0.0)
	    err2 = err2 + cabs(pe - phi(i,j,k))**2
	  end do
	end do
      end do
      err2 = sqrt(err2/(nx*ny*nz))
      write(6,202) err2
  202 format(' exact least squares error = ',e10.3)
      end

      subroutine exact(x,y,z,pe,px,py,pz,pxx,pyy,pzz,pxy,pxz,pyz)
c
c     set exact solution and partial derivatives: p(x,y,z) = (x*cos(y)*z)**3
c
      implicit none
      real x,y,z
      complex pe,px,py,pz,pxx,pyy,pzz,pxy,pxz,pyz
      real s,c,exz
      real xc,xz,cz,xcz
      c = cos(y)
      s = sin(y)
      xc = x*c
      xz = x*z
      cz = c*z
      xcz = xc*z
      pe = cmplx(xcz**3,0.0)
      px = cmplx(3.*x*x*cz**3,0.0)
      pxx = cmplx(6.*x*cz**3,0.0)
      py =cmplx( -3.*c*c*s*xz**3,0.0)
      pyy = cmplx(-3.*xz**3*(c**3-2.*c*s**2),0.0)
      pz = cmplx(3.*z*z*xc**3,0.0)
      pzz = cmplx(6.*z*xc**3,0.0)
      pxy = cmplx(-9.*x**2*c*c*s*z**3,0.0)
      pxz = cmplx(9.*xz**2*c**3,0.0)
      pyz =cmplx( -9.*c*c*s*x**3*z**2,0.0)
      return
      exz = exp(x*z)
      pe = exz*cmplx(c,z)
      px = z*pe
      py = -exz*s
      pz = x*pe +exz*cmplx(c,1.0)
      pxx = z*px
      pyy = -exz*c
      pzz =  x*(pz+exz*cmplx(c,1.0))
      return
      end

      subroutine cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
c
c     set noncross derivative pde coefficients
c
      implicit none
      real x,y,z,s,c
      complex cxx,cyy,czz,cx,cy,cz,ce
      s = sin(y)
      c = cos(y)
c     cxx = 1.+0.5*s*z
c     cyy = 1.+x*z
c     czz = 1.+0.5*x*s
c     cx = 0.0
c     cy = -x*z
c     cz = 0.0
c     ce = -(x+z)
c     return
      cxx = cmplx(1.+0.5*s*z, 1.+0.5*c*z)
      cyy = cmplx(1.+x,1.+z)
      czz = cmplx(1+0.5*s*x,1.+0.5*c*x)
      cx = (0.,0.)
      cy = cx
      cz = cz
      ce = -cmplx(x+z,0.0)
      return

      cxx = cmplx(1.+0.5*s*z,0.0)
      cyy = cmplx(1.+x*z,0.0)
      czz = cmplx(1.+0.5*x*s,0.0)
      cx = (0.0,0.0)
      cy = cmplx(-x*z,0.0)
      cz = (0.0,0.0)
      ce = cmplx(-(x+z),0.0)
      return

      cxx = (1.0,1.0)+0.5*cmplx(s*z,c*z)
      cyy = (1.0,1.0)+cmplx(x,z)
      czz = (1.0,1.0)+0.5*cmplx(x*s,x*c)
      cx = (0.0,0.0)
      cy = cmplx(-x*z,x*z)
      cz = (0.0,0.0)
      ce = -cmplx((x+z),0.0)
      return
      end

      subroutine cxyf(x,y,z,cxy)
c
c     set x-y cross term coefficient at (x,y,z)
c
      implicit none
      real x,y,z,cxxr,cxxi,cyyr,cyyi,cxyr,cxyi
      complex cxx,cyy,czz,cx,cy,cz,ce,cxy
      call cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
      cxxr = cxx
      cxxi = aimag(cxx)
      cyyr = cyy
      cyyi = aimag(cyy)
      cxyr = sqrt(cxxr*cyyr)
      cxyi = sqrt (cxxi*cyyi)
      cxy = cmplx(cxyr,cxyi)
      return
      end

      subroutine cxzf(x,y,z,cxz)
c
c     this is a dummy subroutine since cxz=0.0 for all (x,y,z)
c
      return
      end

      subroutine cyzf(x,y,z,cyz)
c
c     set y-z cross term coefficient at (x,y,z)
c
      real x,y,z,czzr,czzi,cyyr,cyyi,cyzr,cyzi
      complex cxx,cyy,czz,cx,cy,cz,ce,cyz
      call cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
      cyyr = cyy
      cyyi = aimag(cyy)
      czzr = czz
      czzi = imag(czz)
      cyzr = sqrt(cyyr*cyyi)
      cyzi = sqrt (cyyi*czzi)
      cyz = cmplx(cyzr,cyzi)
      return
      end

      subroutine bd3cr(kbdy,xory,yorz,a,b,c,g)
c
c     pass mixed derivative boundary conditions to cud3cr
c
      implicit none
      integer kbdy
      real xory, yorz
      complex a,b,c,g,x,y,z
      complex pe,px,py,pz,pxx,pyy,pzz,pxy,pxz,pyz
      if (kbdy.eq.2) then
c
c     upper x boundary (mixed oblique)
c
	x = 1.0
	y = xory
	z = yorz
c       a = cmplx(z*(1.-z),0.0)
c       b = cmplx(sin(y)*cos(y),0.0)
c       c = -(1.0,0.0)
	a = cmplx(z,1.-z)
	b = cmplx(sin(y),cos(y))
	c = - (1.0,1.0)
	call exact(x,y,z,pe,px,py,pz,pxx,pyy,pzz,pxy,pxz,pyz)
	g = px + a*py + b*pz + c*pe
	return
      else if (kbdy.eq.6) then
c
c     upper z boundary (mixed normal)
c
	z = 1.0
	x = xory
	y = yorz
c       a = (0.0,0.0)
c       b = (0.0,0.0)
	c = cmplx(x,sin(y)**2)
c       c = x*sin(y)**2
	call exact(x,y,z,pe,px,py,pz,pxx,pyy,pzz,pxy,pxz,pyz)
	g = pz + a*px + b*py + c*pe
	return
      end if
      end

</PRE>
<HR>
 
<a name="tcud3sp.txt"><b>TCUD3SP</b></a>
<PRE>
c
c     file tcud3sp.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver cud3sp
c
c ... required MUDPACK files
c
c     cud3sp.f, cudcom.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cud3sp
c
c **********************************************************
c **********************************************************
c
c     a sample program/test driver for cud3sp is below. it can be
c     executed as an initial test.  the output is listed for the
c     test case described.
c
c     test cud3sp below by solving the complex separable elliptic pde
c
c        d(cmplx(x,-x)*dp/dx)/dx + d(cmplx(y,-y)*dp/dy)/dy +
c
c        d(cmplx(z,-z)*dp/dz)/dz + cmplx(1.,-1.)*(dp/dx + dp/dy + dp/dz) +
c
c        cmplx(-(x+y+z),x+y+z)*p(x,y,z) = r(x,y,z)
c
c     on the (x,y,z) region
c
c       1/4 < x < 3/4, 1/3 < y < 2/3, 1/5 < z < 4/5
c
c     with dirchlet boundary conditions at the upper x,y,z boundaries
c     and the mixed complex derirvative boundary conditions:
c
c          (1) dp/dx + cmplx(1.,1.)*p(0.5,y,z) = gbdxa(y,z) at x = 1/4
c
c          (2) dp/dy + cmplx(-1.,-1.)*p(x,0.5,z) = gbdyc(x,z) at y = 1/3
c
c          (3) dp/dz + cmplx(1.,-1.)*p(x,y,0.5) = gbdze(x,y) at z = 1/5
c
c     note the complex number multiplying "p" must be constant along
c     each surface.
c
c     use the exact solution
c
c          pe(x,y,z) = cmplx(exp(x+y),exp(y+z))
c
c     for testing and choose a 49 by 33 by 49 grid.
c
c ******************************************************
c     output (32 bit floating point arithmetic)
c *******************************************************
c
c     cud3sp test
c
c     input arguments
c     intl =  0 nxa =  2 nxb =  1 nyc =  2 nyd =  1
c     nze =  2 nzf =  1
c     ixp =  3 jyq =  2 kzr =  3
c     iex =  5 jey =  5 kez =  5
c     nx =  49 ny =  33 nz =  49 iguess =  0 maxcy =  3
c     method =  0 work space length input =  318622
c     xa =  0.25 xb =  0.75
c     yc =  0.33 yd =  0.67
c     ze =  0.20 zf =  0.80
c     tolmax =  0.000E+00
c
c     multigrid options
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     discretization call to cud3sp intl =  0
c     ierror =  0 minimum work space =  291605
c
c     approximation call to cud3sp
c     intl =  1 method =  0 iguess =  0 maxcy =  3
c     ierror =  0
c     maximum error  =   0.330E-04
c
c ************************************************************
c     end of output
c ************************************************************
c
c
      program tcud3sp
      implicit none
c
c     set grid sizes with parameter statements
c
      integer iixp,jjyq,kkzr,iiex,jjey,kkez,llwork,nnx,nny,nnz
      parameter(iixp=3,jjyq=2,kkzr=3)
      parameter(iiex=5,jjey=5,kkez=5)
      parameter (nnx = iixp*2**(iiex-1)+1)
      parameter (nny = jjyq*2**(jjey-1)+1)
      parameter (nnz = kkzr*2**(kkez-1)+1)
c
c     set work space length estimate (see cud3sp.d).
c     this will probably overestimate required space
c
      parameter (llwork = 7*(nnx+2)*(nny+2)*(nnz+2)/2 )
c
c
c     dimension solution,right hand side, and work arrays
c
      complex phi(nnx,nny,nnz),rhs(nnx,nny,nnz),work(llwork)
      integer iprm(23),mgopt(4)
      real fprm(8)
c
c     put integer and floating point arguments names in contiguous
c     storeage labelling
c
      integer intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,nwork,
     +              lwrkqd,itero
      common/itcd3sp/intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,nwork,
     +              lwrkqd,itero
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftcud3sp/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real dlx,dly,dlz,x,y,z,errm
      complex cxx,cyy,czz,cx,cy,cz,ce,cex,cey,cez
      complex pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k,ierror
      equivalence(intl,iprm)
      equivalence(xa,fprm)
c
c     declare coefficient and boundary condition input subroutines external
c
      external cfx,cfy,cfz,bndc
c
c     set for initial call
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 2
      nxb = 1
      nyc = 2
      nyd = 1
      nze = 2
      nzf = 1
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      kzr = kkzr
      iex = iiex
      jey = jjey
      kez = kkez
      nx = nnx
      ny = nny
      nz = nnz
c
c     set for 3 multigrid cycles
c
      maxcy = 3
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set point relaxation (only choice with cud3sp)
c
      method = 0
c
c     set full multigrid cycling by flagging no initial guess at the finest
c     grid level
c
      iguess = 0
c
c     set end points of solution region in (x,y,z) space
c
      xa = 0.25
      xb = 0.75
      yc = 1.0/3.0
      yd = 2.0/3.0
      ze = 0.20
      zf = 0.80
c
c     set default multigrid options
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
      dlz = (zf-ze)/float(nz-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in rhs and phi to zero
c
      do k=1,nz
	z = ze+(k-1)*dlz
	call cfz(z,czz,cz,cez)
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cfy(y,cyy,cy,cey)
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call cfx(x,cxx,cx,cex)
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    ce = cex+cey+cez
	    rhs(i,j,k) = cxx*pxx+cyy*pyy+czz*pzz+cx*px+cy*py+cz*pz+ce*pe
	    phi(i,j,k) = (0.,0.)
	  end do
	end do
      end do
c
c     set specified values at upper x,y,z boundaries in phi
c
      x = xb
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(nx,j,k) = pe
	end do
      end do
      y = yd
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,ny,k) = pe
	end do
      end do
      z = zf
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,j,nz) = pe
	end do
      end do
      write(6,50)
   50 format(//' cud3sp test ')
c
c     print input arguments
c
      write(6,100)intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,kez,
     +            nx,ny,nz,iguess,maxcy,method,nwork,xa,xb,yc,yd,ze,zf,
     +            tolmax,mgopt(1),mgopt(2),mgopt(3),mgopt(4)
  100 format(/' input arguments ',
     +/' intl = ',i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = 'i2,
     +/' nze = ',i2, ' nzf = ',i2,
     +/' ixp = ',i2,' jyq = 'i2,' kzr = 'i2,
     +/' iex = ',i2, ' jey = 'i2, ' kez = 'i2,
     +/' nx = 'i3,' ny = 'i3,' nz = 'i3, ' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space length input = ',i7,
     +/' xa = 'f5.2,' xb = 'f5.2,
     +/' yc = 'f5.2,' yd = 'f5.2,
     +/' ze = 'f5.2,' zf = 'f5.2,
     +/' tolmax = ' ,e10.3
     +//' multigrid options '
     +/' kcycle = ',i2
     +/' iprer = ',i2
     +/' ipost = ',i2
     +/' intpol = ',i2 )
c
c     discretize pde
c
      write(*,104) intl
  104 format(/' discretization call to cud3sp', ' intl = ', i2)
      call cud3sp(iprm,fprm,work,cfx,cfy,cfz,bndc,rhs,phi,mgopt,ierror)
      write (*,105) ierror,iprm(21)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     approximate pde
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to cud3sp ',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call cud3sp(iprm,fprm,work,cfx,cfy,cfz,bndc,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum error
c
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
  108 format(' maximum error  =  ',e10.3)
      end

      subroutine error(nx,ny,nz,phi,errm)
c
c     compute the error in the estimate in phi
c
      implicit none
      integer nx,ny,nz
      complex phi(nx,ny,nz)
      real xa,xb,yc,yd,ze,zf,tolmax,relmax,errm
      common/ftcud3sp/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real dlx,dly,dlz,x,y,z
      complex pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k
      dlx = (xb-xa)/(nx-1)
      dly = (yd-yc)/(ny-1)
      dlz = (zf-ze)/(nz-1)
      errm = 0.0
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    errm = amax1(errm,abs(phi(i,j,k)-pe))
	  end do
	end do
      end do
      return
      end
c
c     complex coefficient subroutines
c
      subroutine cfx(x,cxx,cx,cex)
      implicit none
      real x
      complex cxx,cx,cex
      cxx = cmplx(x,-x)
      cx = (1.,-1.)
      cex = cmplx(-x,x)
      return
      end
      subroutine cfy(y,cyy,cy,cey)
      implicit none
      real y
      complex cyy,cy,cey
      cyy= cmplx(y,-y)
      cy = (1.,-1.)
      cey = cmplx(-y,y)
      return
      end
      subroutine cfz(z,czz,cz,cez)
      implicit none
      real z
      complex czz,cz,cez
      czz = cmplx(z,-z)
      cz = (1.,-1.)
      cez = cmplx(-z,z)
      return
      end

      subroutine bndc(kbdy,xory,yorz,cons,gbdy)
c
c     input complex derivatives of the form
c
c          dp/dw + cons*p = gbdy  (w=x,y,z)
c
c     to cud3sp.  "cons" must be a complex constant at each surface
c
      implicit none
      integer kbdy
      real xory,yorz,x,y,z
      complex cons,gbdy,pe,px,py,pz,pxx,pyy,pzz
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftcud3sp/xa,xb,yc,yd,ze,zf,tolmax,relmax
      if (kbdy.eq.1) then
c
c     x=xa surface
c
	x = xa
	y = xory
	z = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	cons = (1.,1.)
	gbdy = px+cons*pe
	return
      end if
      if (kbdy.eq.3) then
c
c     y=yc surface
c
	y = yc
	x = xory
	z = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	cons = (-1.,-1.)
	gbdy = py+cons*pe
	return
      end if
      if (kbdy.eq.5) then
c
c     z=ze surface
c
	z = ze
	x = xory
	y = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	cons = (1.,-1.)
	gbdy = pz + cons*pe
	return
      end if
      end

      subroutine exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
c
c     this subroutine is used to set an exact solution for testing cud3sp
c     (i.e., setting the rhs, boundary conditions and computing the exact
c     error)
c
      implicit none
      real x,y,z,exy,eyz
      complex pe,px,py,pz,pxx,pyy,pzz
      exy = exp(x+y)
      eyz = exp(y+z)
      pe = cmplx(exy,eyz)
      px = cmplx(exy,0.)
      pxx = px
      py = pe
      pyy = pe
      pz = cmplx(0.,eyz)
      pzz = pz
      return
      end

</PRE>
<HR>
 
<a name="tcuh2.txt"><b>TCUH2</b></a>
<PRE>
c
c     file tcuh2.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the hybrid complex MUDPACK solver cuh2
c
c ... required MUDPACK files
c
c     cuh2.f, cudcom.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cuh2
c
c **********************************************************
c **********************************************************
c
c     a sample program/test driver for cuh2 is below.  it can be
c     executed as an initial test.  the output is listed for the
c     test case described.
c
c     test the driver below by solving the complex linear elliptic pde
c
c        cmplx(1.+x*x,1.+y*y)*pxx +
c
c        cmplx(exp(-x),exp(-y))*(pyy - py) +
c
c        cmplx(y,x)*p(x,y) = r(x,y)
c
c     on a 46 by 57 grid superimposed on the unit square.
c     Assume specified boundary conditions at xb=1.0,
c     yc = 1.0 and mixed boundary conditions
c
c           dp/dx - cmplx(y,y)*p(xa,y) = g(y) at x = xa
c     and
c
c           dp/dy + cmplx(x,x)*p(x,yd) = h(x) at y = yd.
c
c     the exact solution
c
c          p(x,y) = cmplx(x**5,y**5) + 1.0
c
c     is used for testing.  one full multigrid cycle (no initial guess)
c     with red/black gauss-seidel point relaxation and the default multigrid
c     options is sufficient to reach discretization level error.
c
c     choosing the grid size arguments
c
c          ixp = iparm(6) = 11, jpy = iparm(7) = 7
c
c          iex = iparm(8) = 3,  jey = iparm(9) = 4
c
c     fits the 46 X 57 grid exactly.  This choice results in the
c     grid coarsening:
c
c       45 X 57 > 23 X 29 > 12 X 15 > 12 X 8
c
c     The coarsest 12 X 8 grid has too many points for effective error
c     reducting with relaxation only.  cuh2 uses a direct method whenever
c     the 12 X 8 grid is encountered which maintains multigrid convergence
c     efficiency.
c
c ******************************************************
c     output (32 bit floating point arithmetic)
c *******************************************************
c
c     cuh2 test
c
c     integer input arguments
c     intl =  0 nxa =  2 nxb =  1 nyc =  1 nyd =  2
c     ixp = 11 jyq =  7 iex =  3 jey =  4
c     nx =  45 ny =  57 iguess =  0 maxcy =  1
c     method =  0 work space estimate =   34797
c
c     multigrid option arguments
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     xa =  0.000 xb =  1.000 yc =  0.000 yd =  1.000
c     tolerance (error control) =    0.000E+00
c
c     discretization call to cuh2 intl =  0
c     ierror =  0 minimum work space =   30053
c
c     approximation call to cuh2
c     intl =  1 method =  0 iguess =  0
c     ierror =  0
c     maximum error  =   0.803E-03
c
c ************************************************************
c     end of output
c ************************************************************
c
      program tcuh2
      implicit none
      integer iixp,jjyq,iiex,jjey,nnx,nny,llwrk,llwork,lldir
      integer mmx,mmy
c
c     set grid sizes with parameter statements
c
      parameter (iixp = 11, jjyq = 7 , iiex =3, jjey = 4)
      parameter (mmx = iixp+1, mmy=jjyq+1)
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     set work space estimate (see cuh2.d)
c
      parameter (llwrk=(40*nnx*nny+8*(nnx+nny+2))/3)
      parameter(lldir=(2*(iixp+1)*(2*jjyq-1)+jjyq+1))
      parameter (llwork = llwrk+lldir)
c
c     dimension solution,right hand side, and work arrays
c
      complex p(nnx,nny),r(nnx,nny),w(llwork)
      integer iw(mmx,mmy)
c     put integer and floating point parameter names in contiguous
c     storeage for labelling purposes
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itcud2/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftcud2/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      complex pe,px,py,pxx,pyy,cxx,cyy,cx,cy,ce
      real dlx,dly,x,y,errmax
c
c     declare coefficient and boundary condition input subroutines external
c
      external cof,bndc
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 2
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set for one multigrid cycle
c
      maxcy = 1
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set point relaxation
c
      method = 0
c
c     flag no initial guess (this sets full multigrid cycling)
c
      iguess = 0
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in r
c     initialize p to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cof(x,y,cxx,cyy,cx,cy,ce)
	  call exact(x,y,pxx,pyy,px,py,pe)
	  r(i,j) = cxx*pxx+cyy*pyy+cx*px+cy*py+ce*pe
	  p(i,j) = (0.0,0.0)
	end do
      end do
c
c     set specified boundaries in p
c
      x = xb
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pyy,px,py,pe)
	p(nx,j) = pe
      end do
      y = yc
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exact(x,y,pxx,pyy,px,py,pe)
	p(i,1) = pe
      end do
c
c     set default multigrid opitons
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     print input parameters (except multigrid options which are default)
c
      write(6,100)
  100 format(//' cuh2 test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to cuh2', ' intl = ', i2)
      call cuh2(iprm,fprm,w,iw,cof,bndc,r,p,mgopt,ierror)
c
c     print error parameter and minimum work space requirement
c
      write (*,105) ierror,iprm(16)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess
  106 format(/' approximation call to cuh2',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2)
      call cuh2(iprm,fprm,w,iw,cof,bndc,r,p,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
c
c     compute and print exact maximum error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pyy,px,py,pe)
	  errmax = amax1(errmax,cabs((p(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
  108 format(' maximum error  =  ',e10.3)
      end

      subroutine cof(x,y,cxx,cyy,cx,cy,ce)
c
c     input pde coefficients at any grid point (x,y) in the solution region
c     (xa.le.x.le.xb,yc.le.y.le.yd) to cud2
c
      implicit none
      real x,y
      complex cxx,cyy,cx,cy,ce
      cxx = cmplx(1.+x*x,1.+y*y)
      cyy = cmplx(exp(-x),exp(-y))
      cx = (0.,0.)
      cy = -cyy
      ce = -cmplx(y,x)
      return
      end

      subroutine bndc(kbdy,xory,alfa,gbdy)
c
c     input mixed derivative b.c. to cud2
c
      implicit none
      integer kbdy
      real xory,x,y
      complex alfa,gbdy
      real xa,xb,yc,yd,tolmax,relmax
      common/ftcud2/xa,xb,yc,yd,tolmax,relmax
      complex pe,px,py,pxx,pyy
      if (kbdy.eq.1) then
c
c     x=xa boundary (nxa must equal 2)
c     b.c. has the form px + alfxa(y)*pe = gbdxa(y)
c     alfa and gbdy corresponding to alfxa(y),gbdxa(y)
c     must be output
c
	y = xory
	x = xa
	call exact(x,y,pxx,pyy,px,py,pe)
	alfa = -cmplx(y,y)
	gbdy = px + alfa*pe
	return
      end if
      if (kbdy.eq.4) then
c
c     y = yd boundary (nyd must equal 2)
c     b.c. has the form py + alfyd(x)*pe = gbdyd(x)
c     alfa and gbdy corresponding to alfyd(x),gbdyd(x)
c     must be output
c
	y = yd
	x = xory
	call exact(x,y,pxx,pyy,px,py,pe)
	alfa = cmplx(x,x)
	gbdy = py + alfa*pe
      return
      end if
      end

      subroutine exact(x,y,pxx,pyy,px,py,pe)
c
c     this subroutine is used to set an exact solution for testing cud2
c
      implicit none
      real x,y
      complex pxx,pyy,px,py,pe
      pe = cmplx(x**5,y**5)+1.0
      px = cmplx(5*x**4,0.)
      py = cmplx(0.,5*y**4)
      pxx = cmplx(20.*x**3,0.)
      pyy = cmplx(0.,20.*y**3)
      return
      end
</PRE>
<HR>
 
<a name="tcuh24.txt"><b>TCUH24</b></a>
<PRE>
c
c     file tcuh24.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the hybrid complex MUDPACK solver cuh24
c
c ... required MUDPACK files
c
c     cuh24.f, cuh2.f, cudcom.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cuh24
c
c **********************************************************
c **********************************************************
c
c     a sample program/test driver for cuh24 is below.  it can be
c     executed as an initial test.  the output is listed for the
c     test case described.
c
c     test the driver below by solving the complex linear elliptic pde
c
c        cmplx(1.+x*x,1.+y*y)*pxx +
c
c        cmplx(exp(-x),exp(-y))*(pyy - py) +
c
c        cmplx(y,x)*p(x,y) = r(x,y)
c
c     on a 46 by 57 grid superimposed on the unit square.
c     Assume specified boundary conditions at xb=1.0,
c     yc = 1.0 and mixed boundary conditions
c
c           dp/dx - cmplx(y,y)*p(xa,y) = g(y) at x = xa
c     and
c
c           dp/dy + cmplx(x,x)*p(x,yd) = h(x) at y = yd.
c
c     the exact solution
c
c          p(x,y) = cmplx(x**5,y**5) + 1.0
c
c     is used for testing.  Three multigrid cycles (no initial guess)
c     with red/black gauss-seidel point relaxation and the default multigrid
c     options are executed using cuh2 to reach discretization level error.
c     Then cuh24 is called to improve the second-order estimate to
c     fourth-order

c     choosing the grid size arguments
c
c          ixp = iparm(6) = 11, jpy = iparm(7) = 7
c
c          iex = iparm(8) = 3,  jey = iparm(9) = 4
c
c     fits the 46 X 57 grid exactly.  This choice results in the
c     grid coarsening:
c
c       45 X 57 > 23 X 29 > 12 X 15 > 12 X 8
c
c     The coarsest 12 X 8 grid has too many points for effective error
c     reducting with relaxation only.  cuh24 uses a direct method whenever
c     the 12 X 8 grid is encountered which maintains multigrid convergence
c     efficiency.
c
c ******************************************************
c     output (64 bit floating point arithmetic)
c *******************************************************
c
c     cuh2 test
c
c     integer input arguments
c     intl =  0 nxa =  2 nxb =  1 nyc =  1 nyd =  2
c     ixp = 11 jyq =  7 iex =  3 jey =  4
c     nx =  45 ny =  57 iguess =  0 maxcy =  3
c     method =  0 work space estimate =   30053
c
c     multigrid option arguments
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     xa =  0.000 xb =  1.000 yc =  0.000 yd =  1.000
c     tolerance (error control) =    0.000E+00
c
c     discretization call to cuh2 intl =  0
c     ierror =  0 minimum work space =   30053
c
c     approximation call to cuh2
c     intl =  1 method =  0 iguess =  0 maxcy =  3
c     ierror =  0
c     maximum error  =   0.825E-03
c
c     cuh24 test ierror =  0
c     maximum error  =   0.501E-05
c
c ************************************************************
c     end of output
c ************************************************************
c
      program tcuh24
      implicit none
      integer iixp,jjyq,iiex,jjey,nnx,nny,llwork
      integer mmx,mmy
c
c     set grid sizes with parameter statements
c
      parameter (iixp = 11, jjyq = 7 , iiex =3, jjey = 4)
      parameter (mmx = iixp+1, mmy=jjyq+1)
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     set exact minimal work space required (see tcuh2.f)
c
      parameter (llwork = 30053)
c
c     dimension solution,right hand side, and work arrays
c
      complex p(nnx,nny),r(nnx,nny),w(llwork)
      integer iw(mmx,mmy)
c
c     put integer and floating point parameter names in contiguous
c     storeage for labelling purposes
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itcud2/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftcud2/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      complex pe,px,py,pxx,pyy,cxx,cyy,cx,cy,ce
      real dlx,dly,x,y,errmax
c
c     declare coefficient and boundary condition input subroutines external
c
      external cof,bndc
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 2
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set three multigrid cycles
c
      maxcy = 3
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set point relaxation
c
      method = 0
c
c     flag no initial guess (this sets full multigrid cycling)
c
      iguess = 0
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in r
c     initialize p to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cof(x,y,cxx,cyy,cx,cy,ce)
	  call exact(x,y,pxx,pyy,px,py,pe)
	  r(i,j) = cxx*pxx+cyy*pyy+cx*px+cy*py+ce*pe
	  p(i,j) = (0.0,0.0)
	end do
      end do
c
c     set specified boundaries in p
c
      x = xb
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pyy,px,py,pe)
	p(nx,j) = pe
      end do
      y = yc
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exact(x,y,pxx,pyy,px,py,pe)
	p(i,1) = pe
      end do
c
c     set default multigrid opitons
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     print input parameters (except multigrid options which are default)
c
      write(6,100)
  100 format(//' cuh2 test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to cuh2', ' intl = ', i2)
      call cuh2(iprm,fprm,w,iw,cof,bndc,r,p,mgopt,ierror)
c
c     print error parameter and minimum work space requirement
c
      write (*,105) ierror,iprm(16)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to cuh2',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call cuh2(iprm,fprm,w,iw,cof,bndc,r,p,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
c
c     compute and print exact maximum error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pyy,px,py,pe)
	  errmax = amax1(errmax,cabs((p(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
  108 format(' maximum error  =  ',e10.3)
c
c     attempt fourth-order estimate
c
      call cuh24(w,iw,p,ierror)
      write(*,109) ierror
  109 format(/' cuh24 test', ' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print exact maximum error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pyy,px,py,pe)
	  errmax = amax1(errmax,cabs((p(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
      end

      subroutine cof(x,y,cxx,cyy,cx,cy,ce)
c
c     input pde coefficients at any grid point (x,y) in the solution region
c     (xa.le.x.le.xb,yc.le.y.le.yd) to cud2
c
      implicit none
      real x,y
      complex cxx,cyy,cx,cy,ce
      cxx = cmplx(1.+x*x,1.+y*y)
      cyy = cmplx(exp(-x),exp(-y))
      cx = (0.,0.)
      cy = -cyy
      ce = -cmplx(y,x)
      return
      end

      subroutine bndc(kbdy,xory,alfa,gbdy)
c
c     input mixed derivative b.c. to cud2
c
      implicit none
      integer kbdy
      real xory,x,y
      complex alfa,gbdy
      real xa,xb,yc,yd,tolmax,relmax
      common/ftcud2/xa,xb,yc,yd,tolmax,relmax
      complex pe,px,py,pxx,pyy
      if (kbdy.eq.1) then
c
c     x=xa boundary (nxa must equal 2)
c     b.c. has the form px + alfxa(y)*pe = gbdxa(y)
c     alfa and gbdy corresponding to alfxa(y),gbdxa(y)
c     must be output
c
	y = xory
	x = xa
	call exact(x,y,pxx,pyy,px,py,pe)
	alfa = -cmplx(y,y)
	gbdy = px + alfa*pe
	return
      end if
      if (kbdy.eq.4) then
c
c     y = yd boundary (nyd must equal 2)
c     b.c. has the form py + alfyd(x)*pe = gbdyd(x)
c     alfa and gbdy corresponding to alfyd(x),gbdyd(x)
c     must be output
c
	y = yd
	x = xory
	call exact(x,y,pxx,pyy,px,py,pe)
	alfa = cmplx(x,x)
	gbdy = py + alfa*pe
      return
      end if
      end

      subroutine exact(x,y,pxx,pyy,px,py,pe)
c
c     this subroutine is used to set an exact solution for testing cud2
c
      implicit none
      real x,y
      complex pxx,pyy,px,py,pe
      pe = cmplx(x**5,y**5)+1.0
      px = cmplx(5*x**4,0.)
      py = cmplx(0.,5*y**4)
      pxx = cmplx(20.*x**3,0.)
      pyy = cmplx(0.,20.*y**3)
      return
      end
</PRE>
<HR>
 
<a name="tcuh24cr.txt"><b>TCUH24CR</b></a>
<PRE>
c
c     file tcuh24cr.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the complex MUDPACK solver cuh24cr
c
c ... required MUDPACK files
c
c     cuh24cr.f, cuh2cr.f, cudcom.f
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cuh24cr
c
c **********************************************************
c **********************************************************
c
c     a sample program/test driver for cuh24cr is below.  it can
c     be executed as an initial test.  the output is listed for
c     the test case described.
c
c     test the driver below by solving the elliptic pde
c
c      cmplx(1.+y*y,1.-y*y)*d(dp/dx)/dx + cmplx(x*y,-x*y)*d(dp/dx)/dy
c
c      cmplx(1.+x*x,1.-x*x)*d(dp/dy)/dy + cmplx(y,-y)*dp/dx +
c
c      cmplx(x,-x)*dp/dy + cmplx(x+y,-x-y)*p(x,y) = r(x,y)
c
c     on the region
c
c       0.25 < x < 1.0, 0.0 < y < 0.50
c
c     with specified boundary conditions at xa=0.25, xb=1.0, yc=0.0
c     and mixed boundary conditions at yd=0.5 of the form:
c
c     cmplx(-x,x)*dp/dx+cmplx(1.+x,1.-x)*dp/dy+cmplx(-x,x)*p(x,yd)=gbdyd(x)
c
c     choose a 45 x 73 grid and use line relaxation in the y direction.
c     forr testing purposes use the exact solution
c
c       p(x,y) = cmplx((x*y)**3,-(x*y)**3) + (1.,1.)
c
c     Choosing grid arguments
c
c       ixp = 11, iex = 3, jyq = 9, jey = 4
c
c     fits the required 45 X 73 grid exactly with the coarsening
c
c       45 X 73 > 23 X 37 > 12 X 19 > 12 X 10
c
c     The 12 X 10 coarsest grid has too many points for effective
c     error reduction with relaxation alone.  cuh2cr maintains
c     multigrid convergence efficiency by utilitzing a direct method
c     (Gaussian elimination) whenever the coarsest grid is encountered
c     within multigrid cycling.  Two cycles with cuh2cr are executed
c     and then cuh24cr is called for a fourth-order estimate
c
c
c ******************************************************
c     output (64 bit floating point arithmetic)
c *******************************************************
c
c     cuh2cr test
c
c     integer input arguments
c     intl =  0 nxa =  1 nxb =  1 nyc =  1 nyd =  2
c     ixp = 11 jyq =  9 iex =  3 jey =  4
c     nx =  45 ny =  73 iguess =  0 maxcy =  2
c     method =  2 work space estimate =   69661
c
c     multigrid option arguments
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     xa =  0.250 xb =  1.000 yc =  0.000 yd =  0.500
c     tolerance (error control) =    0.000E+00
c
c     discretization call to cuh2cr intl =  0
c     ierror =  0 minimum work space =   69661
c
c     approximation call to cuh2cr
c     intl =  1 method =  2 iguess =  0 maxcy =  2
c     ierror =  0
c     maximum error  =   0.114E-04
c
c     cuh24cr test  ierror =  0
c     maximum error  =   0.739E-07
c
c **********************************************************
c     end of output
c **********************************************************
c
      program tcuh24cr
      implicit none
      integer iixp,jjyq,iiex,jjey,nnx,nny,llw,mmx,mmy
c
c     set grid sizes with parameter statements
c
      parameter (iixp =11 , jjyq = 9 , iiex =3, jjey = 4)
      parameter (mmx = iixp+1,mmy = jjyq+1)
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     set exact minimal required work space (see tcuh2cr.f)
c
      parameter (llw = 69661)
c
c     dimension solution,right hand side, and work arrays
c
      complex p(nnx,nny),r(nnx,nny),w(llw)
      integer iw(mmx,mmy)
c
c     put integer and floating point parameter names in contiguous
c     storeage for labelling purposes
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itcuh2cr/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftcur2/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      complex cxx,cxy,cyy,cx,cy,ce,pxx,pxy,pyy,px,py,pe
      real dlx,dly,x,y,errmax
c
c     declare coefficient and boundary condition input subroutines external
c
      external cofcr,bndcr
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set two multigrid cycles
c
      maxcy = 2
c
c     set work space length approximation from parameter statement
c
      nwork = llw
c
c     set point relaxation
c
      method = 2
c
c     flag no initial guess (this sets full multigrid cycling)
c
      iguess = 0
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.25
      xb = 1.0
      yc = 0.0
      yd = 0.50
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in r
c     initialize p to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cofcr(x,y,cxx,cxy,cyy,cx,cy,ce)
	  call exact(x,y,pxx,pxy,pyy,px,py,pe)
	  r(i,j) = cxx*pxx+cxy*pxy+cyy*pyy+cx*px+cy*py+ce*pe
	  p(i,j) = (0.0,0.0)
	end do
      end do
c
c     set specified boundaries in p
c
      x = xa
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pxy,pyy,px,py,pe)
	p(1,j) = pe
      end do
      x = xb
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pxy,pyy,px,py,pe)
	p(nx,j) = pe
      end do
      y = yc
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exact(x,y,pxx,pxy,pyy,px,py,pe)
	p(i,1) = pe
      end do
c
c     set default multigrid opitons
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     print input arguments
c
      write(6,100)
  100 format(//' cuh2cr test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to cuh2cr', ' intl = ', i2)
      call cuh2cr(iprm,fprm,w,iw,cofcr,bndcr,r,p,mgopt,ierror)
c
c     print error parameter and minimum work space requirement
c
      write (*,105) ierror,iprm(16)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to cuh2cr',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call cuh2cr(iprm,fprm,w,iw,cofcr,bndcr,r,p,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
c
c     compute and print exact maximum error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pxy,pyy,px,py,pe)
	  errmax = amax1(errmax,cabs((p(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
  108 format(' maximum error  =  ',e10.3)
c
c     attempt fourth-order estimate with difference corrections
c
      call cuh24cr(w,iw,cofcr,bndcr,p,ierror)
      write (*,109) ierror
  109 format(/ ' cuh24cr test ', ' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pxy,pyy,px,py,pe)
	  errmax = amax1(errmax,cabs((p(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
      end

      subroutine cofcr(x,y,cxx,cxy,cyy,cx,cy,ce)
c
c     input pde coefficients at any point (x,y) in the solution region
c     (xa.le.x.le.xb,yc.le.y.le.yd) to cuh2cr
c
      implicit none
      complex cxx,cxy,cyy,cx,cy,ce
      real x,y,xa,xb,yc,yd,tolmax,relmax
      common/ftcur2/xa,xb,yc,yd,tolmax,relmax
      cxx = cmplx(1.+y**2,1.-y**2)
      cxy = cmplx(x*y,-x*y)
      cyy = cmplx(1.+x**2,1.-x*x)
      cx = cmplx(y,-y)
      cy = cmplx(x,-x)
      ce = -cmplx((x+y),-x-y)
      return
      end

      subroutine bndcr(kbdy,xory,alfa,beta,gama,gbdy)
c
c     input mixed "oblique" derivative b.c. to cuh2cr
c
      implicit none
      integer kbdy
      real xory,x,y,xa,xb,yc,yd,tolmax,relmax
      complex alfa,beta,gama,gbdy,pe,px,py,pxx,pxy,pyy
      common/ftcur2/xa,xb,yc,yd,tolmax,relmax
      if (kbdy.eq.4) then
c
c     y=yd boundary (nyd must equal 2 if this code is to be executed).
c     b.c. has the form alfyd(x)*px+betyd(x)*py+gamyd(x)*pe = gbdyd(x)
c     where x = yorx.   alfa,beta,gama,gbdy corresponding to alfyd(x),
c     betyd(x),gamyd(x),gbdyd(y) must be output.
c
	y = yd
	x = xory
	alfa = -cmplx(x,-x)
	beta = cmplx(1.+x,1.-x)
	gama = -cmplx(x,-x)
	call exact(x,y,pxx,pxy,pyy,px,py,pe)
	gbdy = alfa*px + beta*py + gama*pe
	return
      end if
      end

      subroutine exact(x,y,pxx,pxy,pyy,px,py,pe)
c
c     this subroutine is used for setting an exact solution in order
c     to test subroutine cuh2cr.
c
      implicit none
      real x,y,xy,xy2,xy3
      complex pxx,pxy,pyy,px,py,pe
      xy = x*y
      xy2 = xy*xy
      xy3 = xy2*xy
      pe = cmplx(xy3,-xy3)
      px = 3.*y*cmplx(xy2,-xy2)
      py = 3.*x*cmplx(xy2,-xy2)
      pxx = 6.*y*y*cmplx(xy,-xy)
      pxy = 9.*xy*cmplx(xy,-xy)
      pyy = 6.*x*x*cmplx(xy,-xy)
      return
      end

</PRE>
<HR>
 
<a name="tcuh2cr.txt"><b>TCUH2CR</b></a>
<PRE>
c
c     file tcuh2cr.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the complex MUDPACK solver cuh2cr
c
c ... required MUDPACK files
c
c     cuh2cr.f, cudcom.f
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cuh2cr
c
c **********************************************************
c **********************************************************
c
c     a sample program/test driver for cuh2cr is below.  it can
c     be executed as an initial test.  the output is listed for
c     the test case described.
c
c     test the driver below by solving the elliptic pde
c
c      cmplx(1.+y*y,1.-y*y)*d(dp/dx)/dx + cmplx(x*y,-x*y)*d(dp/dx)/dy
c
c      cmplx(1.+x*x,1.-x*x)*d(dp/dy)/dy + cmplx(y,-y)*dp/dx +
c
c      cmplx(x,-x)*dp/dy + cmplx(x+y,-x-y)*p(x,y) = r(x,y)
c
c     on the region
c
c       0.25 < x < 1.0, 0.0 < y < 0.50
c
c     with specified boundary conditions at xa=0.25, xb=1.0, yc=0.0
c     and mixed boundary conditions at yd=0.5 of the form:
c
c     cmplx(-x,x)*dp/dx+cmplx(1.+x,1.-x)*dp/dy+cmplx(-x,x)*p(x,yd)=gbdyd(x)
c
c     choose a 45 x 73 grid and use line relaxation in the y direction.
c     forr testing purposes use the exact solution
c
c       p(x,y) = cmplx((x*y)**3,-(x*y)**3) + (1.,1.)
c
c     Choosing grid arguments
c
c       ixp = 11, iex = 3, jyq = 9, jey = 4
c
c     fits the required 45 X 73 grid exactly with the coarsening
c
c       45 X 73 > 23 X 37 > 12 X 19 > 12 X 10
c
c     The 12 X 10 coarsest grid has too many points for effective
c     error reduction with relaxation alone.  cuh2cr maintains
c     multigrid convergence efficiency by utilitzing a direct method
c     (Gaussian elimination) whenever the coarsest grid is encountered
c     within multigrid cycling
c
c ******************************************************
c     output (32 bit floating point arithmetic)
c *******************************************************
c
c     cuh2cr test
c
c     integer input arguments
c     intl =  0 nxa =  1 nxb =  1 nyc =  1 nyd =  2
c     ixp = 11 jyq =  9 iex =  3 jey =  4
c     nx =  45 ny =  73 iguess =  0 maxcy =  1
c     method =  2 work space estimate =   72545
c
c     multigrid option arguments
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     xa =  0.250 xb =  1.000 yc =  0.000 yd =  0.500
c     tolerance (error control) =    0.000E+00
c
c     discretization call to cuh2cr intl =  0
c     ierror =  0 minimum work space =   69661
c
c     approximation call to cuh2cr
c     intl =  1 method =  2 iguess =  0 maxcy =  1
c     ierror =  0
c     maximum error  =   0.112E-04
c
c **********************************************************
c     end of output
c **********************************************************
c
      program tcuh2cr
      implicit none
      integer iixp,jjyq,iiex,jjey,nnx,nny,llen,lldir,llw
      integer mmx,mmy
c
c     set grid sizes with parameter statements
c
      parameter (iixp =11 , jjyq = 9 , iiex =3, jjey = 4)
      parameter (mmx = iixp+1,mmy = jjyq+1)
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     estimate work length approximation for method=0 (see cuh2cr.d)
c
      parameter (llen=4*((nnx+2)*(nny+2)+14*nnx*nny)/3+(nnx+2)*(nny+2))
      parameter (lldir = (iixp+1)*(jjyq+1)*(2*iixp+3))
      parameter (llw = llen + lldir)
c
c     dimension solution,right hand side, and work arrays
c
      complex p(nnx,nny),r(nnx,nny),w(llw)
      integer iw(mmx,mmy)
c
c     put integer and floating point parameter names in contiguous
c     storeage for labelling purposes
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itcuh2cr/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftcur2/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      complex cxx,cxy,cyy,cx,cy,ce,pxx,pxy,pyy,px,py,pe
      real dlx,dly,x,y,errmax
c
c     declare coefficient and boundary condition input subroutines external
c
      external cofcr,bndcr
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set for one multigrid cycle
c
      maxcy = 1
c
c     set work space length approximation from parameter statement
c
      nwork = llw
c
c     set point relaxation
c
      method = 2
c
c     flag no initial guess (this sets full multigrid cycling)
c
      iguess = 0
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.25
      xb = 1.0
      yc = 0.0
      yd = 0.50
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in r
c     initialize p to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cofcr(x,y,cxx,cxy,cyy,cx,cy,ce)
	  call exact(x,y,pxx,pxy,pyy,px,py,pe)
	  r(i,j) = cxx*pxx+cxy*pxy+cyy*pyy+cx*px+cy*py+ce*pe
	  p(i,j) = (0.0,0.0)
	end do
      end do
c
c     set specified boundaries in p
c
      x = xa
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pxy,pyy,px,py,pe)
	p(1,j) = pe
      end do
      x = xb
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pxy,pyy,px,py,pe)
	p(nx,j) = pe
      end do
      y = yc
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exact(x,y,pxx,pxy,pyy,px,py,pe)
	p(i,1) = pe
      end do
c
c     set default multigrid opitons
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     print input arguments
c
      write(6,100)
  100 format(//' cuh2cr test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to cuh2cr', ' intl = ', i2)
      call cuh2cr(iprm,fprm,w,iw,cofcr,bndcr,r,p,mgopt,ierror)
c
c     print error parameter and minimum work space requirement
c
      write (*,105) ierror,iprm(16)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to cuh2cr',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call cuh2cr(iprm,fprm,w,iw,cofcr,bndcr,r,p,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
c
c     compute and print exact maximum error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pxy,pyy,px,py,pe)
	  errmax = amax1(errmax,cabs((p(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
  108 format(' maximum error  =  ',e10.3)
      end

      subroutine cofcr(x,y,cxx,cxy,cyy,cx,cy,ce)
c
c     input pde coefficients at any point (x,y) in the solution region
c     (xa.le.x.le.xb,yc.le.y.le.yd) to cuh2cr
c
      implicit none
      complex cxx,cxy,cyy,cx,cy,ce
      real x,y,xa,xb,yc,yd,tolmax,relmax
      common/ftcur2/xa,xb,yc,yd,tolmax,relmax
      cxx = cmplx(1.+y**2,1.-y**2)
      cxy = cmplx(x*y,-x*y)
      cyy = cmplx(1.+x**2,1.-x*x)
      cx = cmplx(y,-y)
      cy = cmplx(x,-x)
      ce = -cmplx((x+y),-x-y)
      return
      end

      subroutine bndcr(kbdy,xory,alfa,beta,gama,gbdy)
c
c     input mixed "oblique" derivative b.c. to cuh2cr
c
      implicit none
      integer kbdy
      real xory,x,y,xa,xb,yc,yd,tolmax,relmax
      complex alfa,beta,gama,gbdy,pe,px,py,pxx,pxy,pyy
      common/ftcur2/xa,xb,yc,yd,tolmax,relmax
      if (kbdy.eq.4) then
c
c     y=yd boundary (nyd must equal 2 if this code is to be executed).
c     b.c. has the form alfyd(x)*px+betyd(x)*py+gamyd(x)*pe = gbdyd(x)
c     where x = yorx.   alfa,beta,gama,gbdy corresponding to alfyd(x),
c     betyd(x),gamyd(x),gbdyd(y) must be output.
c
	y = yd
	x = xory
	alfa = -cmplx(x,-x)
	beta = cmplx(1.+x,1.-x)
	gama = -cmplx(x,-x)
	call exact(x,y,pxx,pxy,pyy,px,py,pe)
	gbdy = alfa*px + beta*py + gama*pe
	return
      end if
      end

      subroutine exact(x,y,pxx,pxy,pyy,px,py,pe)
c
c     this subroutine is used for setting an exact solution in order
c     to test subroutine cuh2cr.
c
      implicit none
      real x,y,xy,xy2,xy3
      complex pxx,pxy,pyy,px,py,pe
      xy = x*y
      xy2 = xy*xy
      xy3 = xy2*xy
      pe = cmplx(xy3,-xy3)
      px = 3.*y*cmplx(xy2,-xy2)
      py = 3.*x*cmplx(xy2,-xy2)
      pxx = 6.*y*y*cmplx(xy,-xy)
      pxy = 9.*xy*cmplx(xy,-xy)
      pyy = 6.*x*x*cmplx(xy,-xy)
      return
      end

</PRE>
<HR>
 
<a name="tcuh3.txt"><b>TCUH3</b></a>
<PRE>
c
c     file tcuh3.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver cuh3
c
c ... required MUDPACK files
c
c     cuh3.f, cudcom.f, cud3ln.f, cud3pn.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cuh3
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for cuh3 is below. it can be
c     executed as an initial test.  the output is listed for the
c     test case described.
c
c     test the driver below by solving the complex nonseparable
c     linear elliptic pde
c
c          cmplx(y,z)*d(dp/dx)/dx + cmplx(x,z)*d(dp/dy)/dy +
c
c          cmplx(x,y)*d(dp/dz)/dz - cmplx(y+z,x+y)*pe(x,y,z)
c
c          = r(x,y,z)
c
c     on a 21 X 21 X 57 uniform grid superimposed on the region
c
c                [0.5,1.0] x [0.5,1.0] x [0.0,1.0]
c
c     Assume specified boundary conditions at all x and y boundaries
c     and periodic in the z direction.  Use line relaxation in the
c     z direction.  The exact solution
c
c          pe(x,y,z) = exp(x*y)*cmplx(cos(tpi*z),sin(tpi*z))
c
c     is used for testing (tpi = 8.0*atan(1.0)).  Choosing grid
c     size arguments
c
c       ixp = 5, jyq = 5, kzr = 7, iex = 3, jey = 3, kez = 4
c
c     will give the gridcoarsening
c
c       21 X 21 X 57 > 11 X 11 X 29 > 6 X 6 X 15 > 6 X 6 X 8
c
c     The coarsest 6 by 6 by 8 (x,y,z) grid has too many points
c     for effective error reduction with relaxation alone.  cuh3
c     uses a direct method when this grid is encountered within
c     multigrid cycling thus maintaining multigrid convergence rates.
c
c ******************************************************
c     output (32 bit floating point arithmetic)
c *******************************************************
c
c     cuh3 test
c
c     input arguments
c     intl =  0 nxa =  1 nxb =  1 nyc =  1 nyd =  1
c     nze =  0 nzf =  0
c     ixp =  5 jyq =  5 kzr =  7
c     iex =  3 jey =  3 kez =  4
c     nx =  21 ny =  21 nz =  57 iguess =  0 maxcy =  1
c     method =  3 work space length input =  499376
c     xa =  0.50 xb =  1.00
c     yc =  0.50 yd =  1.00
c     ze =  0.00 zf =  1.00
c     tolmax =  0.000E+00
c
c     multigrid options
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     discretization call to cuh3 intl =  0
c     ierror =  0 minimum work space =  488841
c
c     approximation call to cuh3
c     intl =  1 method =  3 iguess =  0 maxcy =  1
c     ierror =  0
c     maximum error  =   0.112E-02
c
c ************************************************************
c     end of output
c ************************************************************
c
      program tcuh3
      implicit none
c
c     set grid sizes with parameter statements
c
      integer iixp,jjyq,kkzr,iiex,jjey,kkez,llwork,nnx,nny,nnz
      integer mmx,mmy,mmz
      parameter(iixp=5,jjyq=5,kkzr=7)
      parameter (mmx=iixp+1,mmy=jjyq+1,mmz=kkzr+1)
      parameter(iiex=3,jjey=3,kkez=4)
      parameter (nnx = iixp*2**(iiex-1)+1)
      parameter (nny = jjyq*2**(jjey-1)+1)
      parameter (nnz = kkzr*2**(kkez-1)+1)
c
c     set work space length estimate for method=3 (see cuh3.d).
c     this will probably overestimate required space
c
      parameter (llwork = 16*(nnx+2)*(nny+2)*(nnz+2) )
c
c
c     dimension solution,right hand side, and work arrays
c
      complex phi(nnx,nny,nnz),rhs(nnx,nny,nnz),work(llwork)
      integer iw(mmx,mmy,mmz),iprm(23),mgopt(4)
      real fprm(8)
c
c     put integer and floating point arguments names in contiguous
c     storeage labelling
c
      integer intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,
     +              lwrkqd,itero
      common/itcud3/intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,
     +              lwrkqd,itero

      real xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      common/ftcud3/xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      real dlx,dly,dlz,x,y,z,errm
      complex cxx,cyy,czz,cx,cy,cz,ce, pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k,ierror
      equivalence(intl,iprm)
      equivalence(xa,fprm)
c
c     declare coefficient and boundary condition input subroutines external
c
      external cof,bndc
      tpi = 8.0*atan(1.0)
c
c     set for initial call
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 1
      nyc = 1
      nyd = 1
      nze = 0
      nzf = 0
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      kzr = kkzr
      iex = iiex
      jey = jjey
      kez = kkez
      nx = nnx
      ny = nny
      nz = nnz
c
c     set for one multigrid cycles
c
      maxcy = 1
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set method of relaxation--line in the z direction
c
      method = 3
c
c     meth2 only used in planar relaxation--but set
c
      meth2 = 0
c
c     set full multigrid cycling by flagging no initial guess at the finest
c     grid level
c
      iguess = 0
c
c     set end points of solution region in (x,y,z) space
c
      xa = 0.5
      xb = 1.0
      yc = 0.5
      yd = 1.0
      ze = 0.0
      zf = 1.0
c
c     set default multigrid options
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
      dlz = (zf-ze)/float(nz-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in rhs and phi to zero
c
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    rhs(i,j,k) = cxx*pxx+cyy*pyy+czz*pzz+cx*px+cy*py+cz*pz+ce*pe
	    phi(i,j,k) = (0.,0.)
	  end do
	end do
      end do
c
c     set specified values at x and y boundaries in phi
c
      x = xa
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(1,j,k) = pe
	end do
      end do
      x = xb
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(nx,j,k) = pe
	end do
      end do
      y = yc
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,1,k) = pe
	end do
      end do
      y = yd
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,ny,k) = pe
	end do
      end do
      write(6,50)
   50 format(//' cuh3 test ')
c
c     print input arguments
c
      write(6,100)intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,kez,
     +            nx,ny,nz,iguess,maxcy,method,nwork,xa,xb,yc,yd,ze,zf,
     +            tolmax,mgopt(1),mgopt(2),mgopt(3),mgopt(4)
  100 format(/' input arguments ',
     +/' intl = ',i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = 'i2,
     +/' nze = ',i2, ' nzf = ',i2,
     +/' ixp = ',i2,' jyq = 'i2,' kzr = 'i2,
     +/' iex = ',i2, ' jey = 'i2, ' kez = 'i2,
     +/' nx = 'i3,' ny = 'i3,' nz = 'i3, ' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space length input = ',i7,
     +/' xa = 'f5.2,' xb = 'f5.2,
     +/' yc = 'f5.2,' yd = 'f5.2,
     +/' ze = 'f5.2,' zf = 'f5.2,
     +/' tolmax = ' ,e10.3
     +//' multigrid options '
     +/' kcycle = ',i2
     +/' iprer = ',i2
     +/' ipost = ',i2
     +/' intpol = ',i2 )
c
c     discretize pde
c
      write(*,104) intl
  104 format(/' discretization call to cuh3', ' intl = ', i2)
      call cuh3(iprm,fprm,work,iw,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,105) ierror,iprm(22)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     approximate pde
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to cuh3 ',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call cuh3(iprm,fprm,work,iw,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum error
c
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
  108 format(' maximum error  =  ',e10.3)
      end

      subroutine error(nx,ny,nz,phi,errm)
c
c     compute the error in the estimate in phi
c
      implicit none
      integer nx,ny,nz
      complex phi(nx,ny,nz)
      real xa,xb,yc,yd,ze,zf,tolmax,relmax,errm,tpi
      common/ftcud3/xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      real dlx,dly,dlz,x,y,z
      complex pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k
      dlx = (xb-xa)/(nx-1)
      dly = (yd-yc)/(ny-1)
      dlz = (zf-ze)/(nz-1)
      errm = 0.0
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    errm = amax1(errm,abs(phi(i,j,k)-pe))
	  end do
	end do
      end do
      return
      end

      subroutine cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
c
c     input pde coefficients at grid point (x,y,z) in the solution region
c     to subroutine cuh3
c
      implicit none
      complex cxx,cyy,czz,cx,cy,cz,ce
      real x,y,z
      cxx = cmplx(y,z)
      cyy = cmplx(x,z)
      czz = cmplx(x,y)
      cx = (0.,0.)
      cy = cx
      cz = cz
      ce = -cmplx(y+z,x+z)
      return
      end

      subroutine bndc(kbdy,xory,yorz,alfa,gbdy)
c
c     dummy subroutine since no mixed derivative b.c.
c
      implicit none
      integer kbdy
      real xory,yorz
      complex alfa,gbdy
      return
      end

      subroutine exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
c
c     this subroutine is used to set an exact solution for testing cuh3
c
      implicit none
      real x,y,z
      complex pxx,pyy,pzz,px,py,pz,pe
      real xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      common/ftcud3/xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      pe = exp(x*y)*cmplx(cos(tpi*z),sin(tpi*z))
      px = y*pe
      py = x*pe
      pz = tpi*exp(x*y)*cmplx(-sin(tpi*z),cos(tpi*z))
      pxx = y*y*pe
      pyy = x*x*pe
      pzz = -tpi*tpi*pe
      return
      end

</PRE>
<HR>
 
<a name="tcuh34.txt"><b>TCUH34</b></a>
<PRE>
c
c     file tcuh34.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver cuh34
c
c ... required MUDPACK files
c
c     cuh34.f, cuh3.f, cudcom.f, cud3ln.f, cud3pn.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for cuh34
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for cuh34 is below. it can be
c     executed as an initial test.  the output is listed for the
c     test case described.
c
c     test the driver below by solving the complex nonseparable
c     linear elliptic pde
c
c          cmplx(y,z)*d(dp/dx)/dx + cmplx(x,z)*d(dp/dy)/dy +
c
c          cmplx(x,y)*d(dp/dz)/dz - cmplx(y+z,x+y)*pe(x,y,z)
c
c          = r(x,y,z)
c
c     on a 21 X 21 X 57 uniform grid superimposed on the region
c
c                [0.5,1.0] x [0.5,1.0] x [0.0,1.0]
c
c     Assume specified boundary conditions at all x and y boundaries
c     and periodic in the z direction.  Use line relaxation in the
c     z direction.  The exact solution
c
c          pe(x,y,z) = exp(x*y)*cmplx(cos(tpi*z),sin(tpi*z))
c
c     is used for testing (tpi = 8.0*atan(1.0)).  Choosing grid
c     size arguments
c
c       ixp = 5, jyq = 5, kzr = 7, iex = 3, jey = 3, kez = 4
c
c     will give the gridcoarsening
c
c       21 X 21 X 57 > 11 X 11 X 29 > 6 X 6 X 15 > 6 X 6 X 8
c
c     The coarsest 6 by 6 by 8 (x,y,z) grid has too many points
c     for effective error reduction with relaxation alone.  cuh3
c     uses a direct method when this grid is encountered within
c     multigrid cycling thus maintaining multigrid convergence rates.
c     After two cycles are executed with cuh3, cuh34 is called to
c     compute a fourth-order estimate
c
c ******************************************************
c     output (64 bit floating point arithmetic)
c *******************************************************
c
c     cuh3 test
c
c     input arguments
c     intl =  0 nxa =  1 nxb =  1 nyc =  1 nyd =  1
c     nze =  0 nzf =  0
c     ixp =  5 jyq =  5 kzr =  7
c     iex =  3 jey =  3 kez =  4
c     nx =  21 ny =  21 nz =  57 iguess =  0 maxcy =  2
c     method =  3 work space length input =  488841
c     xa =  0.50 xb =  1.00
c     yc =  0.50 yd =  1.00
c     ze =  0.00 zf =  1.00
c     tolmax =  0.000E+00
c
c     multigrid options
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     discretization call to cuh3 intl =  0
c     ierror =  0 minimum work space =  488841
c
c     approximation call to cuh3
c     intl =  1 method =  3 iguess =  0 maxcy =  2
c     ierror =  0
c     maximum error  =   0.112E-02
c
c     cuh34 test  ierror =  0
c     maximum error  =   0.510E-05
c
c ************************************************************
c     end of output
c ************************************************************
c
      program tcuh34
      implicit none
c
c     set grid sizes with parameter statements
c
      integer iixp,jjyq,kkzr,iiex,jjey,kkez,llwork,nnx,nny,nnz
      integer mmx,mmy,mmz
      parameter(iixp=5,jjyq=5,kkzr=7)
      parameter (mmx=iixp+1,mmy=jjyq+1,mmz+kkzr+1)
      parameter(iiex=3,jjey=3,kkez=4)
      parameter (nnx = iixp*2**(iiex-1)+1)
      parameter (nny = jjyq*2**(jjey-1)+1)
      parameter (nnz = kkzr*2**(kkez-1)+1)
c
c     set minimal work space required (see tcuh3.f)
c
      parameter (llwork = 488841)
c
c
c     dimension solution,right hand side, and work arrays
c
      complex phi(nnx,nny,nnz),rhs(nnx,nny,nnz),work(llwork)
      integer iw(mmx,mmy,mmz),iprm(23),mgopt(4)
      real fprm(8)
c
c     put integer and floating point arguments names in contiguous
c     storeage labelling
c
      integer intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,
     +              lwrkqd,itero
      common/itcud3/intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,
     +              lwrkqd,itero

      real xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      common/ftcud3/xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      real dlx,dly,dlz,x,y,z,errm
      complex cxx,cyy,czz,cx,cy,cz,ce, pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k,ierror
      equivalence(intl,iprm)
      equivalence(xa,fprm)
c
c     declare coefficient and boundary condition input subroutines external
c
      external cof,bndc
      tpi = 8.0*atan(1.0)
c
c     set for initial call
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 1
      nyc = 1
      nyd = 1
      nze = 0
      nzf = 0
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      kzr = kkzr
      iex = iiex
      jey = jjey
      kez = kkez
      nx = nnx
      ny = nny
      nz = nnz
c
c     set two multigrid cycles
c
      maxcy = 2
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set method of relaxation--line in the z direction
c
      method = 3
c
c     meth2 only used in planar relaxation--but set
c
      meth2 = 0
c
c     set full multigrid cycling by flagging no initial guess at the finest
c     grid level
c
      iguess = 0
c
c     set end points of solution region in (x,y,z) space
c
      xa = 0.5
      xb = 1.0
      yc = 0.5
      yd = 1.0
      ze = 0.0
      zf = 1.0
c
c     set default multigrid options
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
      dlz = (zf-ze)/float(nz-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in rhs and phi to zero
c
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    rhs(i,j,k) = cxx*pxx+cyy*pyy+czz*pzz+cx*px+cy*py+cz*pz+ce*pe
	    phi(i,j,k) = (0.,0.)
	  end do
	end do
      end do
c
c     set specified values at x and y boundaries in phi
c
      x = xa
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(1,j,k) = pe
	end do
      end do
      x = xb
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(nx,j,k) = pe
	end do
      end do
      y = yc
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,1,k) = pe
	end do
      end do
      y = yd
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,ny,k) = pe
	end do
      end do
      write(6,50)
   50 format(//' cuh3 test ')
c
c     print input arguments
c
      write(6,100)intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,kez,
     +            nx,ny,nz,iguess,maxcy,method,nwork,xa,xb,yc,yd,ze,zf,
     +            tolmax,mgopt(1),mgopt(2),mgopt(3),mgopt(4)
  100 format(/' input arguments ',
     +/' intl = ',i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = 'i2,
     +/' nze = ',i2, ' nzf = ',i2,
     +/' ixp = ',i2,' jyq = 'i2,' kzr = 'i2,
     +/' iex = ',i2, ' jey = 'i2, ' kez = 'i2,
     +/' nx = 'i3,' ny = 'i3,' nz = 'i3, ' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space length input = ',i7,
     +/' xa = 'f5.2,' xb = 'f5.2,
     +/' yc = 'f5.2,' yd = 'f5.2,
     +/' ze = 'f5.2,' zf = 'f5.2,
     +/' tolmax = ' ,e10.3
     +//' multigrid options '
     +/' kcycle = ',i2
     +/' iprer = ',i2
     +/' ipost = ',i2
     +/' intpol = ',i2 )
c
c     discretize pde
c
      write(*,104) intl
  104 format(/' discretization call to cuh3', ' intl = ', i2)
      call cuh3(iprm,fprm,work,iw,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,105) ierror,iprm(22)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     approximate pde
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to cuh3 ',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call cuh3(iprm,fprm,work,iw,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum error
c
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
  108 format(' maximum error  =  ',e10.3)
c
c     fourth-order computation
c
      call cuh34(work,iw,phi,ierror)
      write (*,109) ierror
  109 format(/' cuh34 test ', ' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
      end

      subroutine error(nx,ny,nz,phi,errm)
c
c     compute the error in the estimate in phi
c
      implicit none
      integer nx,ny,nz
      complex phi(nx,ny,nz)
      real xa,xb,yc,yd,ze,zf,tolmax,relmax,errm,tpi
      common/ftcud3/xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      real dlx,dly,dlz,x,y,z
      complex pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k
      dlx = (xb-xa)/(nx-1)
      dly = (yd-yc)/(ny-1)
      dlz = (zf-ze)/(nz-1)
      errm = 0.0
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    errm = amax1(errm,abs(phi(i,j,k)-pe))
	  end do
	end do
      end do
      return
      end

      subroutine cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
c
c     input pde coefficients at grid point (x,y,z) in the solution region
c     to subroutine cuh3
c
      implicit none
      complex cxx,cyy,czz,cx,cy,cz,ce
      real x,y,z
      cxx = cmplx(y,z)
      cyy = cmplx(x,z)
      czz = cmplx(x,y)
      cx = (0.,0.)
      cy = cx
      cz = cz
      ce = -cmplx(y+z,x+z)
      return
      end

      subroutine bndc(kbdy,xory,yorz,alfa,gbdy)
c
c     dummy subroutine since no mixed derivative b.c.
c
      implicit none
      integer kbdy
      real xory,yorz
      complex alfa,gbdy
      return
      end

      subroutine exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
c
c     this subroutine is used to set an exact solution for testing cuh3
c
      implicit none
      real x,y,z
      complex pxx,pyy,pzz,px,py,pz,pe
      real xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      common/ftcud3/xa,xb,yc,yd,ze,zf,tolmax,relmax,tpi
      pe = exp(x*y)*cmplx(cos(tpi*z),sin(tpi*z))
      px = y*pe
      py = x*pe
      pz = tpi*exp(x*y)*cmplx(-sin(tpi*z),cos(tpi*z))
      pxx = y*y*pe
      pyy = x*x*pe
      pzz = -tpi*tpi*pe
      return
      end

</PRE>
<HR>
 
<a name="tmud2.txt"><b>TMUD2</b></a>
<PRE>
c
c     file tmud2.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver mud2
c
c ... required MUDPACK files
c
c     mud2.f, mudcom.f
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for mud2
c
c **********************************************************
c **********************************************************
c
c     a sample program/test driver for mud2 is below. it can be
c     executed as an initial test.  output is listed for the test
c     case.  test mud2 by solving the elliptic pde
c
c          (1.+y**2)*pxx + exp(-(x+y))*(pyy-py) - (x+y)*pe = r(x,y)
c
c     on the unit square with specified boundary conditions at
c     xb = 1.0, yc = 0.0 and mixed boundary conditions
c
c          dp/dx - y*p(0,y) = g(y)  (at x=0.)
c
c     and
c
c          dp/dy + x*p(x,1) = h(x)  (at y=1.).
c
c     use line relaxation in the y direction and choose a grid as close
c     to 50 by 100 as the grid size arguments allow. use the exact
c     solution
c
c          pe(x,y) = x**5 + y**5 + 1.0
c
c     for testing.  one full multigrid cycle (no initial guess) with
c     the default multigrid options is executed and reaches discretization
c     level error.
c
c
c ******************************************************************
c     output (32 bit floating point arithmetic)
c ******************************************************************
c
c     mud2 test
c
c     integer input arguments
c     intl =  0 nxa =  2 nxb =  1 nyc =  1 nyd =  2
c     ixp =  3 jyq =  3 iex =  5 jey =  6
c     nx =  49 ny =  97 iguess =  0 maxcy =  1
c     method =  2 work space estimate =   83964
c
c     multigrid option arguments
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  1
c
c     floating point input parameters
c     xa =  0.000 xb =  1.000 yc =  0.000 yd =  1.000
c     tolerance (error control) =    0.000E+00
c
c     discretization call to mud2 intl =  0
c     ierror =  0 minimum work space =   70048
c
c     approximation call to mud2
c     intl =  1 method =  2 iguess =  0
c     ierror =  0
c     maximum error  =   0.333E-03
c
c ************************************************************
c     end of output
c ************************************************************
c
c
      program tmud2
      implicit none
      integer iixp,jjyq,iiex,jjey,nnx,nny,isx,jsy,llwork
c
c     set grid sizes with parameter statements
c
      parameter (iixp = 3 , jjyq = 3 , iiex = 5, jjey = 6)
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     set work space length approximation for line-y relaxation (see mud2.d)
c
      parameter(isx=0,jsy=3)
      parameter (llwork=4*(nnx*nny*(10+isx+jsy)+8*(nnx+nny+2))/3)
      real phi(nnx,nny),rhs(nnx,nny),work(llwork)
c
c     put integer and floating point argument names in contiguous
c     storeage for labelling in vectors iprm,fprm
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itmud2/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftmud2/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      real dlx,dly,x,y,cxx,cyy,cx,cy,ce,pxx,pyy,px,py,pe,errmax
c
c     declare coefficient and boundary condition input subroutines external
c
      external cof,bndc
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 2
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set multigrid arguments (w(2,1) cycling with fully weighted
c     residual restriction and cubic prolongation)
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set for one cycle
c
      maxcy = 1
c
c     set no initial guess forcing full multigrid cycling
c
      iguess = 0
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set line-y relaxation
c
      method = 2
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control flag
c
      tolmax = 0.0
c
c     set right hand side in rhs
c     initialize phi to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cof(x,y,cxx,cyy,cx,cy,ce)
	  call exact(x,y,pxx,pyy,px,py,pe)
	  rhs(i,j) = cxx*pxx+cyy*pyy+cx*px+cy*py+ce*pe
	  phi(i,j) = 0.0
	end do
      end do
c
c     set specified boundaries in phi
c
      x = xb
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pyy,px,py,pe)
	phi(nx,j) = pe
      end do
      y = yc
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exact(x,y,pxx,pyy,px,py,pe)
	phi(i,1) = pe
      end do
      write(*,100)
  100 format(//' mud2 test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to mud2', ' intl = ', i2)
      call mud2(iprm,fprm,work,cof,bndc,rhs,phi,mgopt,ierror)
c
c     print error parameter and minimum work space requirement
c
      write (*,105) ierror,iprm(16)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess
  106 format(/' approximation call to mud2',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2)
      call mud2(iprm,fprm,work,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum norm of error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pyy,px,py,pe)
	  errmax = amax1(errmax,abs((phi(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
  108 format(' maximum error  =  ',e10.3)
      end

      subroutine cof(x,y,cxx,cyy,cx,cy,ce)
c
c     input pde coefficients at any grid point (x,y) in the solution region
c
      implicit none
      real x,y,cxx,cyy,cx,cy,ce
      cxx = 1.+y*y
      cyy = exp(-(x+y))
      cx = 0.
      cy = -cyy
      ce = -(x+y)
      return
      end

      subroutine bndc(kbdy,xory,alfa,gbdy)
c
c     input mixed derivative b.c. to mud2
c
      implicit none
      integer kbdy
      real xory,alfa,gbdy,x,y,pe,px,py,pxx,pyy
      real xa,xb,yc,yd,tolmax,relmax
      common/ftmud2/xa,xb,yc,yd,tolmax,relmax
      if (kbdy.eq.1) then  ! x=xa boundary
	y = xory
	x = xa
	call exact(x,y,pxx,pyy,px,py,pe)
	alfa = -y
	gbdy = px + alfa*pe
	return
      end if
      if (kbdy.eq.4) then  ! y=yd boundary
	y = yd
	x = xory
	call exact(x,y,pxx,pyy,px,py,pe)
	alfa = x
	gbdy = py + alfa*pe
	return
      end if
      end

      subroutine exact(x,y,pxx,pyy,px,py,pe)
c
c     this subroutine is used to set an exact solution for testing mud2
c
      implicit none
      real x,y,pxx,pyy,px,py,pe
      pe = x**5+y**5+1.
      px = 5.*x**4
      py = 5.*y**4
      pxx = 20.*x**3
      pyy = 20.*y**3
      return
      end

</PRE>
<HR>
 
<a name="tmud24.txt"><b>TMUD24</b></a>
<PRE>
c
c     file tmud24.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the mudpack solver mud24
c
c ... required files
c
c     mud24.f, mud2.f, mudcom.f
c
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for mud24
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for mud24 is below. it can be
c     executed as an initial test.  output is listed for the case
c     described.
c
c     test the driver below by solving the elliptic pde
c
c          (1.+y**2)*pxx + exp(-(x+y))*(pyy-py) - (x+y)*pe = r(x,y)
c
c     on the unit square with specified boundary conditions at
c     xb = 1.0, yc = 0.0 and mixed boundary conditions
c
c          dp/dx - y*p(xa,y) = g(y)  (at x=0)
c
c     and
c
c          dp/dy + x*p(x,yd) = h(x)  (at y=1).
c
c     use line relaxation in the y direction and choose a grid as close
c     to 50 by 100 as the grid size parameters allow. use the exact
c     solution
c
c          pe(x,y) = x**5 + y**5 + 1.0
c
c     for testing.
c
c     the default multigrid options with no initial guess and two
c     cycles are used when first calling mud2 to yield a second-
c     order estimate.  then mud24 is called to produce a fourth-order
c     approximation.
c
c
c ***************************************************************
c     output (64 bit floating point arithmetic)
c ****************************************************************
c
c     mud2 test
c
c     integer input arguments
c     intl =  0 nxa =  2 nxb =  1 nyc =  1 nyd =  2
c     ixp =  3 jyq =  3 iex =  5 jey =  6
c     nx =  49 ny =  97 iguess =  0 maxcy =  2
c     method =  2 work space estimate =   70048

c
c     multigrid option arguments
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     xa =  0.000 xb =  1.000 yc =  0.000 yd =  1.000
c     tolerance (error control) =    0.000E+00
c
c     discretization call to mud2 intl =  0
c     ierror =  0 minimum work space =   70048
c
c     approximation call to mud2
c     intl =  1 method =  2 iguess =  0
c     ierror =  0
c     maximum error  =   0.342E-03
c
c     mud24 test  ierror =  0
c     maximum error  =   0.337E-05
c
c ************************************************************
c     end of output
c ************************************************************
c
c
      program tmud24
      implicit none
      integer iixp,jjyq,iiex,jjey,nnx,nny,llwork
c
c     set grid sizes with parameter statements
c
      parameter (iixp = 3 , jjyq = 3 , iiex = 5, jjey = 6)
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     set minimal required work space length (see tmud2.f)
c
      parameter (llwork=70048)
      real phi(nnx,nny),rhs(nnx,nny),work(llwork)
c
c     put integer and floating point argument names in contiguous
c     storeage for labelling in vectors iprm,fprm
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itmud2/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftmud2/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      real dlx,dly,x,y,cxx,cyy,cx,cy,ce,pxx,pyy,px,py,pe,errmax
c
c     declare coefficient and boundary condition input subroutines external
c
      external cof,bndc
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 2
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set multigrid arguments (w(2,1) cycling with fully weighted
c     residual restriction and cubic prolongation)
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set two mg cycles for second-order approximation
c
      maxcy = 2
c
c     set no initial guess forcing full multigrid cycling
c     on initial call
c
      iguess = 0
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set line-y relaxation
c
      method = 2
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control flag
c
      tolmax = 0.0
c
c     set right hand side in rhs
c     initialize phi to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cof(x,y,cxx,cyy,cx,cy,ce)
	  call exact(x,y,pxx,pyy,px,py,pe)
	  rhs(i,j) = cxx*pxx+cyy*pyy+cx*px+cy*py+ce*pe
	  phi(i,j) = 0.0
	end do
      end do
c
c     set specified boundaries in phi
c
      x = xb
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pyy,px,py,pe)
	phi(nx,j) = pe
      end do
      y = yc
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exact(x,y,pxx,pyy,px,py,pe)
	phi(i,1) = pe
      end do
      write(*,100)
  100 format(//' mud2 test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to mud2', ' intl = ', i2)
      call mud2(iprm,fprm,work,cof,bndc,rhs,phi,mgopt,ierror)
c
c     print error parameter and minimum work space requirement
c
      write (*,200) ierror,iprm(16)
  200 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess
  106 format(/' approximation call to mud2',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2)
      call mud2(iprm,fprm,work,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum norm of error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pyy,px,py,pe)
	  errmax = amax1(errmax,abs((phi(i,j)-pe)))
	end do
      end do
      write(*,201) errmax
  201 format(' maximum error  =  ',e10.3)
c
c      attempt to improve approximation to fourth order
c
      call mud24(work,phi,ierror)
      write (*,108) ierror
  108 format(/' mud24 test ', ' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum norm of error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pyy,px,py,pe)
	  errmax = amax1(errmax,abs((phi(i,j)-pe)))
	end do
      end do
      write(*,201) errmax
      end

      subroutine cof(x,y,cxx,cyy,cx,cy,ce)
c
c     input pde coefficients at any grid point (x,y) in the solution region
c
      implicit none
      real x,y,cxx,cyy,cx,cy,ce
      cxx = 1.+y*y
      cyy = exp(-(x+y))
      cx = 0.
      cy = -cyy
      ce = -(x+y)
      return
      end

      subroutine bndc(kbdy,xory,alfa,gbdy)
c
c     input mixed derivative b.c. to mud2
c
      implicit none
      integer kbdy
      real xory,alfa,gbdy,x,y,pe,px,py,pxx,pyy
      real xa,xb,yc,yd,tolmax,relmax
      common/ftmud2/xa,xb,yc,yd,tolmax,relmax
      if (kbdy.eq.1) then  ! x=xa boundary
	y = xory
	x = xa
	call exact(x,y,pxx,pyy,px,py,pe)
	alfa = -y
	gbdy = px + alfa*pe
	return
      end if
      if (kbdy.eq.4) then  ! y=yd boundary
	y = yd
	x = xory
	call exact(x,y,pxx,pyy,px,py,pe)
	alfa = x
	gbdy = py + alfa*pe
	return
      end if
      end

      subroutine exact(x,y,pxx,pyy,px,py,pe)
c
c     this subroutine is used to set an exact solution for testing mud2
c
      implicit none
      real x,y,pxx,pyy,px,py,pe
      pe = x**5+y**5+1.
      px = 5.*x**4
      py = 5.*y**4
      pxx = 20.*x**3
      pyy = 20.*y**3
      return
      end

</PRE>
<HR>
 
<a name="tmud24cr.txt"><b>TMUD24CR</b></a>
<PRE>
c
c     file tmud24cr.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the mudpack solver mud2cr
c
c ... required MUDPACK files
c
c     mud2cr.f, mudcom.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for mud24cr
c
c **********************************************************
c **********************************************************
c
c     a sample program/test driver for mud24cr is listed below.  it
c     can be executed as an initial test.  the output is listed for
c     test case described.
c
c     test mud24cr below by solving the nonseparable elliptic pde
c     with cross derivative term
c
c          (1.+y**2)*pxx + (1.+x**2)*pyy + 2.*x*y*pxy +
c
c          y*px + x*py - (x*y)*pe = r(x,y)
c
c     on a grid as close to 50 by 64 as the mudpack size constraints
c     allow.  the solution region is the unit square.  assume a
c     mixed derivative boundary condition at y=1 of the form
c
c          -x * dp/dx + (1+x) * dp/dy - x * pe = gbdyd(x)
c
c     and specified (Dirchlet) boundary conditions elsewhere.  the
c     exact solution
c
c          p(x,y) = (x*y)**5
c
c     is used to set the right hand side, boundary conditions, and
c     compute the error.
c
c     red/black gauss-seidel point relaxation is used along with the
c     the default multigrid options.  first mud2cr is called to generate
c     a second-order approximation.  then mud24cr is called to improve
c     the estimate to fourth-order.
c
c
c ******************************************************
c     output (64 bit floating point arithmetic)
c *******************************************************
c
c     mud2cr test
c
c     integer input arguments
c     intl =  0 nxa =  1 nxb =  1 nyc =  1 nyd =  2
c     ixp =  3 jyq =  2 iex =  5 jey =  6
c     nx =  49 ny =  65 iguess =  0 maxcy =  3
c     method =  0 work space estimate =   51496
c
c     multigrid option arguments
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     xa =  0.000 xb =  1.000 yc =  0.000 yd =  1.000
c     tolerance (error control) =    0.000E+00
c
c     discretization call to mud2cr intl =  0
c     ierror =  0 minimum work space =   51496
c
c     approximation call to mud2cr
c     intl =  1 method =  0 iguess =  0
c     ierror =  0
c     maximum error  =   0.626E-03
c
c     mud24cr test  ierror =  0
c     maximum error  =   0.584E-05
c
c **********************************************************
c      end of output
c **********************************************************
c
c
      program tmud24cr
      implicit none
c
c     set grid size params
c
      integer iixp,jjyq,iiex,jjey,nnx,nny,llwork
      parameter (iixp = 3 , jjyq = 2, iiex = 5, jjey = 6 )
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     set minimum required work space (see tmud2cr.f)
c
      parameter (llwork=51496)
      real phi(nnx,nny),rhs(nnx,nny),work(llwork)
c
c     put integer and floating point argument names in contiguous
c     storeage for labelling in vectors iprm,fprm
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itmud2cr/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftmud2cr/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      real dlx,dly,x,y,cxx,cxy,cyy,cx,cy,ce,pxx,pxy,pyy,px,py,pe,errmax
c
c     declare coefficient and boundary condition input subroutines external
c
      external cofcr,bndcr
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set multigrid arguments (w(2,1) cycling with fully weighted
c     residual restriction and cubic prolongation)
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set three cycles to ensure second-order approx
c
      maxcy = 3
c
c     set no initial guess forcing full multigrid cycling
c
      iguess = 0
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set point relaxation
c
      method = 0
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control flag
c
      tolmax = 0.0
c
c     set right hand side in rhs
c     initialize phi to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cofcr(x,y,cxx,cxy,cyy,cx,cy,ce)
	  call exacr(x,y,pxx,pxy,pyy,px,py,pe)
	  rhs(i,j) = cxx*pxx+cxy*pxy+cyy*pyy+cx*px+cy*py+ce*pe
	  phi(i,j) = 0.0
	end do
      end do
c
c     set specified boundaries in phi at x=xa,xb and y=yc
c
      do j=1,ny
	y = yc+float(j-1)*dly
	call exacr(xa,y,pxx,pxy,pyy,px,py,pe)
	phi(1,j) = pe
	call exacr(xb,y,pxx,pxy,pyy,px,py,pe)
	phi(nx,j) = pe
      end do
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exacr(x,yc,pxx,pxy,pyy,px,py,pe)
	phi(i,1) = pe
      end do
      write(*,100)
  100 format(//' mud2cr test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to mud2cr', ' intl = ', i2)
      call mud2cr(iprm,fprm,work,cofcr,bndcr,rhs,phi,mgopt,ierror)
      write (*,200) ierror,iprm(16)
  200 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess
  106 format(/' approximation call to mud2cr',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2)
      call mud2cr(iprm,fprm,work,cofcr,bndcr,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
      if (ierror .le. 0) then
c
c     compute and print maximum norm of error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exacr(x,y,pxx,pxy,pyy,px,py,pe)
	  errmax = amax1(errmax,abs((phi(i,j)-pe)))
	end do
      end do
      write(*,201) errmax
  201 format(' maximum error  =  ',e10.3)
      end if
c
c     attempt fourth order approximation
c
      call mud24cr(work,cofcr,bndcr,phi,ierror)
      write (*,108) ierror
  108 format(/' mud24cr test', '  ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum norm of error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exacr(x,y,pxx,pxy,pyy,px,py,pe)
	  errmax = amax1(errmax,abs((phi(i,j)-pe)))
	end do
      end do
      write(*,201) errmax
      end

      subroutine cofcr(x,y,cxx,cxy,cyy,cx,cy,ce)
c
c     input pde coefficients at any grid point (x,y) in the solution region
c     (xa.le.x.le.xb,yc.le.y.le.yd) to mud2cr
c
      implicit none
      real x,y,cxx,cxy,cyy,cx,cy,ce
      cxx = 1.+y**2
      cxy = 2.*x*y
      cyy = 1.+x**2
      cx = y
      cy = x
      ce = -(x*y)
      return
      end

      subroutine bndcr(kbdy,xory,alfa,beta,gama,gbdy)
c
c     input mixed "oblique" derivative b.c. to mud2cr
c     at upper y boundary
c
      implicit none
      integer kbdy
      real xory,alfa,beta,gama,gbdy
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itmud2cr/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftmud2cr/xa,xb,yc,yd,tolmax,relmax
      real x,y,pxx,pxy,pyy,px,py,pe
      if (kbdy.eq.4) then
c
c     y=yd boundary (nyd must equal 2 if this code is to be executed).
c     b.c. has the form alfyd(x)*px+betyd(x)*py+gamyd(x)*pe = gbdyd(x)
c     where x = yorx.   alfa,beta,gama,gbdy corresponding to alfyd(x),
c     betyd(x),gamyd(x),gbdyd(y) must be output.
c
      y = yd
      x = xory
      alfa = -x
      beta = 1.+x
      gama = -x
      call exacr(x,y,pxx,pxy,pyy,px,py,pe)
      gbdy = alfa*px + beta*py + gama*pe
      return
      end if
      end

      subroutine exacr(x,y,pxx,pxy,pyy,px,py,pe)
c
c     this subroutine is used for setting an exact solution
c     to test subroutine mud2cr.
c
      implicit none
      real x,y,pxx,pxy,pyy,px,py,pe
      pe = (x*y)**5
      px = 5.*(x*y)**4*y
      py = 5.*(x*y)**4*x
      pxx = 20.*(x*y)**3*y*y
      pxy = 25.*(x*y)**4
      pyy = 20.*(x*y)**3*x*x
      return
      end
</PRE>
<HR>
 
<a name="tmud24sp.txt"><b>TMUD24SP</b></a>
<PRE>
c
c     file tmud24sp.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the mudpack solver mud24sp
c
c ... required MUDPACK files
c
c     mud24sp.f, mud2sp.f, mudcom.f
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for mud24sp
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for mud24sp is listed below.  it
c     can be executed as an initial test.  the output is listed for
c     the test case described.
c
c     test the driver below by solving the separable elliptic pde
c
c     (1.+x**2)*pxx + exp(1.-y)*(pyy-py) - (x+y)*pe = r(x,y)
c
c     on the unit square with specified boundary conditions at
c     xb = 1.0, yc = 0.0 and mixed boundary conditions
c
c          dp/dx - pe(0.0,y) =  ga(y)  (at x = 0.0)
c
c          dp/dy + pe(x,1.0) = gd(x)  (at y = 1.0)
c
c     use point relaxation and choose a grid as close to 60 x 50
c     as the grid size constraints allow.  use the exact solution
c
c          pe(x,y) = (x**3+y**3+1.0)/3
c
c     for testing.  first mud2sp is called to yield a second-order
c     approximation.  then mud24sp is called to improve the estimate.
c
c *************************************************************
c     output (64 bit floating point arithmetic)
c *************************************************************
c
c     mud2sp test
c
c     integer input arguments
c     intl =  0 nxa =  2 nxb =  1 nyc =  1 nyd =  2
c     ixp =  2 jyq =  3 iex =  6 jey =  5
c     nx =  65 ny =  49 iguess =  0 maxcy =  3
c     method =  0 work space estimate =   13264
c
c     multigrid option arguments
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     xa =  0.000 xb =  1.000 yc =  0.000 yd =  1.000
c     tolerance (error control) =    0.000E+00
c
c     discretization call to mud2sp intl =  0
c     ierror =  0 minimum work space =   13264
c
c     approximation call to mud2sp
c     intl =  1 method =  0 iguess =  0
c     ierror =  0
c     maximum error  =   0.496E-04
c
c     mud24sp test  ierror =  0
c     maximum error  =   0.123E-06
c
c ***************************************************************
c      end of output
c ***************************************************************
c
c
      program tmud24sp
      implicit none
      integer iixp,jjyq,iiex,jjey,nnx,nny,llwork
c
c     set grid sizes with parameter statements
c
      parameter (iixp = 2 , jjyq = 3 , iiex = 6, jjey = 5)
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     set minimal required work space (see tmud2sp.f)
c
      parameter (llwork = 13264)
      real phi(nnx,nny),rhs(nnx,nny),work(llwork)
c
c     put integer and floating point argument names in contiguous
c     storeage for labelling in vectors iprm,fprm
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itmud2sp/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftmud2sp/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      real dlx,dly,x,y,cxx,cyy,cx,cy,ce,pxx,pyy,px,py,pe,errmax
      real cex,cey
c
c     declare coefficient and boundary condition input subroutines external
c
      external cofx,cofy,bndsp
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 2
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set multigrid arguments (w(2,1) cycling with fully weighted
c     residual restriction and cubic prolongation)
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set for three cycles to ensure second-order approximation
c     is computed
c
      maxcy = 3
c
c     set no initial guess forcing full multigrid cycling
c
      iguess = 0
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set point relaxation
c
      method = 0
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control flag
c
      tolmax = 0.0
c
c     set right hand side in rhs
c     initialize phi to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	call cofx(x,cxx,cx,cex)
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cofy(y,cyy,cy,cey)
	  ce = cex+cey
	  call exact(x,y,pxx,pyy,px,py,pe)
	  rhs(i,j) = cxx*pxx+cyy*pyy+cx*px+cy*py+ce*pe
	  phi(i,j) = 0.0
	end do
      end do
c
c     set specified boundaries in phi
c
      x = xb
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pyy,px,py,pe)
	phi(nx,j) = pe
      end do
      y = yc
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exact(x,y,pxx,pyy,px,py,pe)
	phi(i,1) = pe
      end do
      write(*,100)
  100 format(//' mud2sp test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to mud2sp', ' intl = ', i2)
      call mud2sp(iprm,fprm,work,cofx,cofy,bndsp,rhs,phi,mgopt,ierror)
c
c     print error parameter and minimum work space requirement
c
      write (*,200) ierror,iprm(16)
  200 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess
  106 format(/' approximation call to mud2sp',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2)
      call mud2sp(iprm,fprm,work,cofx,cofy,bndsp,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
      if (ierror .le. 0) then
c
c     compute and print maximum norm of error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pyy,px,py,pe)
	  errmax = amax1(errmax,abs((phi(i,j)-pe)))
	end do
      end do
      write(*,201) errmax
  201 format(' maximum error  =  ',e10.3)
      end if
c
c      attempt to improve approximation to fourth order
c
      call mud24sp(work,phi,ierror)
      write (*,108) ierror
  108 format(/' mud24sp test ', ' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
      if (ierror .le. 0) then
c
c     compute and print maximum norm of error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pyy,px,py,pe)
	  errmax = amax1(errmax,abs((phi(i,j)-pe)))
	end do
      end do
      write(*,201) errmax
      end if
      end

      subroutine cofx(x,cxx,cx,cex)
c
c     input x dependent coefficients
c
      implicit none
      real x,cxx,cx,cex
      cxx = 1.0+x*x
      cx = 0.0
      cex = -x
      return
      end

      subroutine cofy(y,cyy,cy,cey)
c
c     input y dependent coefficients
c
      implicit none
      real y,cyy,cy,cey
      cyy = exp(1.0-y)
      cy = -cyy
      cey = -y
      return
      end

      subroutine bndsp(kbdy,xory,alfa,gbdy)
c
c     input mixed derivative b.c. to mud2sp
c
      implicit none
      integer kbdy
      real xory,alfa,gbdy,x,y,pe,px,py,pxx,pyy
      real xa,xb,yc,yd,tolmax,relmax
      common/ftmud2sp/xa,xb,yc,yd,tolmax,relmax
      if (kbdy.eq.1) then  ! x=xa boundary
	y = xory
	x = xa
	call exact(x,y,pxx,pyy,px,py,pe)
	alfa = -1.0
	gbdy = px + alfa*pe
	return
      end if
      if (kbdy.eq.4) then  ! y=yd boundary
	y = yd
	x = xory
	call exact(x,y,pxx,pyy,px,py,pe)
	alfa = 1.0
	gbdy = py + alfa*pe
	return
      end if
      end

      subroutine exact(x,y,pxx,pyy,px,py,pe)
c
c     set an exact solution for testing mud2sp
c
      implicit none
      real x,y,pxx,pyy,px,py,pe
      pe = (x**3+y**3+1.0)/3.0
      px = x*x
      py = y*y
      pxx = x+x
      pyy = y+y
      return
      end

</PRE>
<HR>
 
<a name="tmud2cr.txt"><b>TMUD2CR</b></a>
<PRE>
c
c     file tmud2cr.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the mudpack solver mud2cr
c
c ... required MUDPACK files
c
c     mud2cr.f, mudcom.f
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for mud2cr
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for mud2cr is listed below.  it
c     can be executed as an initial test.  the output is listed
c     for the test case described.
c
c     test mud2cr below by solving the nonseparable elliptic pde
c     with cross derivative term
c
c          (1.+y**2)*pxx + (1.+x**2)*pyy + 2.*x*y*pxy +
c
c          y*px + x*py - (x*y)*pe = r(x,y)
c
c     on a grid as close to 50 by 64 as the mudpack size constraints
c     allow.  the solution region is the unit square.  assume a
c     mixed derivative boundary condition at y=1 of the form
c
c          -x * dp/dx + (1+x) * dp/dy - x * pe = gbdyd(x).
c
c     and specified (Dirchlet) boundary conditions elsewhere.  the
c     exact solution
c
c          p(x,y) = (x*y)**5
c
c     is used to set the right hand side, boundary conditions, and
c     compute the error.
c
c     red/black gauss-seidel point relaxation is used along with the
c     the default multigrid options.  one full multigrid cycle reaches
c     discretization level error for this problem.
c
c
c ******************************************************
c     output (32 bit floating point arithmetic)
c *******************************************************
c
c
c     mud2cr test
c
c     integer input arguments
c     intl =  0 nxa =  1 nxb =  1 nyc =  1 nyd =  2
c     ixp =  3 jyq =  2 iex =  5 jey =  6
c     nx =  49 ny =  65 iguess =  0 maxcy =  1
c     method =  0 work space estimate =   54686
c
c     multigrid option arguments
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     xa =  0.000 xb =  1.000 yc =  0.000 yd =  1.000
c     tolerance (error control) =    0.000E+00
c
c     discretization call to mud2cr intl =  0
c     ierror =  0 minimum work space =   51496
c
c     approximation call to mud2cr
c     intl =  1 method =  0 iguess =  0
c     ierror =  0
c     maximum error  =   0.623E-03
c
c **********************************************************
c      end of output
c **********************************************************
c
      program tmud2cr
      implicit none
c
c     set grid size params
c
      integer iixp,jjyq,iiex,jjey,nnx,nny,llwork
      parameter (iixp = 3 , jjyq = 2, iiex = 5, jjey = 6 )
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     estimate work space for point relaxation (see mud2cr.d)
c
      parameter (llwork=(7*(nnx+2)*(nny+2)+44*nnx*nny)/3 )
      real phi(nnx,nny),rhs(nnx,nny),work(llwork)
c
c     put integer and floating point argument names in contiguous
c     storeage for labelling in vectors iprm,fprm
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itmud2cr/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftmud2cr/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      real dlx,dly,x,y,cxx,cxy,cyy,cx,cy,ce,pxx,pxy,pyy,px,py,pe,errmax
c
c     declare coefficient and boundary condition input subroutines external
c
      external cofcr,bndcr
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set multigrid arguments (w(2,1) cycling with fully weighted
c     residual restriction and cubic prolongation)
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set for one cycle
c
      maxcy = 1
c
c     set no initial guess forcing full multigrid cycling
c
      iguess = 0
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set point relaxation
c
      method = 0
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control flag
c
      tolmax = 0.0
c
c     set right hand side in rhs
c     initialize phi to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cofcr(x,y,cxx,cxy,cyy,cx,cy,ce)
	  call exacr(x,y,pxx,pxy,pyy,px,py,pe)
	  rhs(i,j) = cxx*pxx+cxy*pxy+cyy*pyy+cx*px+cy*py+ce*pe
	  phi(i,j) = 0.0
	end do
      end do
c
c     set specified boundaries in phi at x=xa,xb and y=yc
c
      do j=1,ny
	y = yc+float(j-1)*dly
	call exacr(xa,y,pxx,pxy,pyy,px,py,pe)
	phi(1,j) = pe
	call exacr(xb,y,pxx,pxy,pyy,px,py,pe)
	phi(nx,j) = pe
      end do
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exacr(x,yc,pxx,pxy,pyy,px,py,pe)
	phi(i,1) = pe
      end do
      write(*,100)
  100 format(//' mud2cr test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to mud2cr', ' intl = ', i2)
      call mud2cr(iprm,fprm,work,cofcr,bndcr,rhs,phi,mgopt,ierror)
      write (*,200) ierror,iprm(16)
  200 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess
  106 format(/' approximation call to mud2cr',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2)
      call mud2cr(iprm,fprm,work,cofcr,bndcr,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
      if (ierror .le. 0) then
c
c     compute and print maximum norm of error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exacr(x,y,pxx,pxy,pyy,px,py,pe)
	  errmax = amax1(errmax,abs((phi(i,j)-pe)))
	end do
      end do
      write(*,201) errmax
  201 format(' maximum error  =  ',e10.3)
      end if
      end

      subroutine cofcr(x,y,cxx,cxy,cyy,cx,cy,ce)
c
c     input pde coefficients at any grid point (x,y) in the solution region
c     (xa.le.x.le.xb,yc.le.y.le.yd) to mud2cr
c
      implicit none
      real x,y,cxx,cxy,cyy,cx,cy,ce
      cxx = 1.+y**2
      cxy = 2.*x*y
      cyy = 1.+x**2
      cx = y
      cy = x
      ce = -(x*y)
      return
      end

      subroutine bndcr(kbdy,xory,alfa,beta,gama,gbdy)
c
c     input mixed "oblique" derivative b.c. to mud2cr
c     at upper y boundary
c
      implicit none
      integer kbdy
      real xory,alfa,beta,gama,gbdy
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itmud2cr/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftmud2cr/xa,xb,yc,yd,tolmax,relmax
      real x,y,pxx,pxy,pyy,px,py,pe
      if (kbdy.eq.4) then
c
c     y=yd boundary (nyd must equal 2 if this code is to be executed).
c     b.c. has the form alfyd(x)*px+betyd(x)*py+gamyd(x)*pe = gbdyd(x)
c     where x = yorx.   alfa,beta,gama,gbdy corresponding to alfyd(x),
c     betyd(x),gamyd(x),gbdyd(y) must be output.
c
      y = yd
      x = xory
      alfa = -x
      beta = 1.+x
      gama = -x
      call exacr(x,y,pxx,pxy,pyy,px,py,pe)
      gbdy = alfa*px + beta*py + gama*pe
      return
      end if
      end

      subroutine exacr(x,y,pxx,pxy,pyy,px,py,pe)
c
c     this subroutine is used for setting an exact solution
c     to test subroutine mud2cr.
c
      implicit none
      real x,y,pxx,pxy,pyy,px,py,pe
      pe = (x*y)**5
      px = 5.*(x*y)**4*y
      py = 5.*(x*y)**4*x
      pxx = 20.*(x*y)**3*y*y
      pxy = 25.*(x*y)**4
      pyy = 20.*(x*y)**3*x*x
      return
      end
</PRE>
<HR>
 
<a name="tmud2sa.txt"><b>TMUD2SA</b></a>
<PRE>
c
c     file tmud2sa.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver mud2
c
c ... required MUDPACK files
c
c     mud2sa.f, mudcom.f
c
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for mud2sa
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for mud2sa is below. it can be
c     executed as an initial test.  output is listed for the test
c     case described.
c
c     test the nonseparable self-adjoint solver mud2sa by approximating
c     the solution to the following elliptic pde in divergence form on
c     the full surface of a sphere of radius one.
c
c          div(sigma(t,p)*grad(u(t,p))) - lambda(t,p)*u(t,p) = f(t,p)
c
c     t and p are colatitude and longitude in radians.  choose a grid
c     as close to 2.5 degrees radians (73 x 145) as the mudpack size
c     constraints allow. multiplying thru by sin(t) puts the pde in the
c     following self-adjoint form suitable for mud2sa:
c
c          d(sin(t)*sigma*du/dt)/dt + d(sigma/sin(t)*du/dp)/dp -
c
c          sin(t)*lambda*u(t,p) = sin(t)*f(t,p).
c
c
c     for testing use the coefficients and exact solution:
c
c          sigma(t,p) = 1.5 + (sin(t)*cos(p))**2
c
c          lambda(t,p) = - sigma(t,p)
c
c          u(t,p) =  [sin(t)*(sin(t)*cos(t)*sin(p)*cos(p))]**2
c
c     (the exact solution is the restriction of the solution u(x,y,z) =
c     (x*y*z)**2 in cartesian coordinates to the surface of the sphere
c     in spherical coordinates).  assume the solution u(t,p) is specified
c     at the poles and is periodic in longitude.
c
c ************************************************************
c     output (32 bit floating point arithmetic)
c ***********************************************************
c
c     mud2sa test
c
c     integer input parameters
c     intl =  0 nta =  1 ntb =  1 npc =  0 npd =  0
c     itp =  5 jpq =  5 iet =  5 jep =  6
c     nt =  81 np = 161 iguess =  0 maxcy =  1
c      method =  2 work space estimate =  260820

c
c     multigrid option parameters
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     ta =  0.000 tb =  3.142 pc =  0.000 pd =  6.283
c     tolerance (error control) =   0.000E+00
c
c     discretization call to mud2sa  intl =  0
c     ierror =  0 minimum work space =  225200
c
c     approximation call to mud2sa
c     intl =  1 method =  2 iguess =  0 maxcy =  1
c     tolmax =  0.00
c     ierror =  0
c     maximum error  =  0.655E-04
c
c ************************************************************
c ************************************************************
c
      program tmud2sa
      implicit none
      integer iitp,jjpq,iiet,jjep,nnt,nnp,llwork
c
c     set grid size with parameter statements
c
      parameter(iitp = 5, jjpq = 5, iiet = 5, jjep = 6)
      parameter ( nnt = iitp*2**(iiet-1) + 1)
      parameter ( nnp = jjpq*2**(jjep-1) + 1)
c
c     set work space for longitude relaxation only (see mud2sa.d)
c
      parameter (llwork = 20*nnt*nnp)
c
c     dimension solution,right hand side, and work arrays
c
      real u(nnt,nnp),r(nnt,nnp),w(llwork)
c
c     dimension input argument vectors and set up continguous storage
c     for labelling entries
c
      integer iparm(17),mgopt(4)
      real fparm(6)
      integer intl,nta,ntb,npc,npd,itp,jpq,iet,jep,nt,np,
     +                iguess,maxcy,method,nwork,lwork,iter
      common / iprm / intl,nta,ntb,npc,npd,itp,jpq,iet,jep,nt,np,
     +                iguess,maxcy,method,nwork,lwork,iter
      real ta,tb,pc,pd,tolmax,sinat,cosat,sinap,cosap,dlt,dlp
      common / fprm / ta,tb,pc,pd,tolmax,sinat(81),cosat(81),
     +                sinap(161),cosap(161),dlt,dlp
      integer i,j,ierror
      real pi,sint,cost,sinp,cosp,sigma,dsigdt,dsigdp
      real ctt,cpp,ct,cp,ce,tmp,dt,dp,dtt,dpp,ue,ut,up,utt,upp
      real sigt,sigp,xlmb,errm,p,t
c
c     equivlance iparm,fparm with labelled commons iprm,fprm
c
      equivalence (intl,iparm)
      equivalence (ta,fparm)
c
c     declare coefficient and boundary condition input subroutines external
c
      external sigt,sigp,xlmb,bndc
c
c     set input integer parameters
c
c     initialization
c
      intl = 0
c
c     set boundary condition flags: poles specified, longitude periodic
c
      nta = 1
      ntb = 1
      npc = 0
      npd = 0
c
c     set grid sizes from parameter statements
c
      itp = iitp
      jpq = jjpq
      iet = iiet
      jep = jjep
      nt = nnt
      np = nnp
c
c     full multigrid cycling (no initial guess at finest grid)
c
      iguess = 0
c
c     set one multigrid cycle
c
      maxcy = 1
c
c     set line relaxation in the longitude direction
c
      method = 2
c
c     set work space estimate
c
      nwork = llwork
c
c     set multigrid parameters (w(2,1) cycling with fully weighted
c     residual restriction and cubic prolongation).  this can also
c     be set by inputting mgopt(1) = 0 to mud2sa.
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set floating point input parameters
c
      pi = 4.0*atan(1.0)
c
c     interval end points (in radians)
c
      ta = 0.0
      tb = pi
      pc = 0.
      pd = pi+pi
c
c     no error control
c
      tolmax = 0.0
c
c     set mesh increments
c
      dlt = (tb-ta)/float(nt-1)
      dlp = (pd-pc)/float(np-1)
c
c     preset sin,cos vectors to save computation on grid points
c
      do i=1,nt
	t = ta+(i-1)*dlt
	sinat(i) = sin(t)
	cosat(i) = cos(t)
      end do
      do j=1,np
	p = pc+(j-1)*dlp
	sinap(j) = sin(p)
	cosap(j) = cos(p)
      end do
c
c     initialize right hand side and solution array except at poles
c
      do  i=2,nt-1
	sint = sinat(i)
	cost = cosat(i)
	do j=1,np
	  sinp = sinap(j)
	  cosp = cosap(j)
	  sigma = 1.5 + (sint*cosp)**2
	  dsigdt = 2.0*cosp*cosp*sint*cost
	  dsigdp = -2.0*sint*sint*cosp*sinp
c
c         compute expanded pde coefficients
c
	  ctt = sint*sigma
	  cpp = sigma/sint
	  ct = sint*dsigdt + cost*sigma
	  cp = dsigdp/sint
	  ce = -sint*sigma
c
c         set intermediate variables for exact solution
c
	  tmp = (sint*cosp*sint*sinp*cost)
	  dt = (2.*sint*cost*cost-sint**3)*(cosp*sinp)
	  dp = (cosp**2-sinp**2)*(sint**2*cost)
	  dtt = (2.*cost**3-4.*cost*sint**2-3.*sint**2*cost)*(cosp*sinp)
	  dpp = (-4.*cosp*sinp)*(sint**2*cost)
c
c         set continuous solution and partial derivatives
c
	  ue = tmp*tmp
	  ut = 2.*tmp*dt
	  up = 2.*tmp*dp
	  utt = 2.*(dt*dt+tmp*dtt)
	  upp = 2.*(dp*dp+tmp*dpp)
c
c         set right hand side of continuous pde on grid
c
	  r(i,j) = ctt*utt+cpp*upp+ct*ut+cp*up+ce*ue
c
c         initialize solution array to zero
c
	  u(i,j) = 0.0
	end do
      end do
c
c     set u, r(unused) at poles
c
      do j=1,np
	u(1,j) = 0.0
	r(1,j) = 0.0
	u(nt,j) = 0.0
	r(nt,j) = 0.0
      end do
c
c     print input parameters
c
      write(*,100)
  100 format(//' mud2sa test' )

      write (*,101) (iparm(i),i=1,15)
  101 format(/' integer input parameters ',
     +/' intl = ',i2,' nta = ',i2,' ntb = ',i2,' npc = ',i2,' npd = 'i2,
     +/' itp = ',i2,' jpq = 'i2,' iet = ',i2,' jep = ',i2
     +/' nt = 'i3,' np = 'i3,' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space estimate = ',i7)

      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option parameters ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)

      write(*,103) (fparm(i),i=1,5)
  103 format(/' floating point input parameters ',
     +/' ta = 'f6.3,' tb = 'f6.3,' pc = 'f6.3,' pd = 'f6.3,
     +/' tolerance (error control) =  ' ,e10.3)
c
c     discretization call to mud2sa
c
      write(*,104) intl
  104 format(/' discretization call to mud2sa ', ' intl = ',i2)
      call mud2sa(iparm,fparm,w,sigt,sigp,xlmb,bndc,r,u,mgopt,ierror)
      write (*,105) ierror,iparm(16)
  105 format(' ierror = 'i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     aprroximation call to mud2sa
c
      intl = 1
      write(*,106) intl, method, iguess, maxcy, tolmax
  106 format(/' approximation call to mud2sa ',
     +/' intl = ',i2, ' method = ',i2 , ' iguess = ',i2, ' maxcy = ',i2
     +/' tolmax = ',f5.2)
      call mud2sa(iparm,fparm,w,sigt,sigp,xlmb,bndc,r,u,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = 'i2 )
      if (ierror.gt.0) call exit(0)
      if (ierror .le. 0) then
c
c     compute and print exact maximum error
c
      errm = 0.0
      do j=1,np
	sinp = sinap(j)
	cosp = cosap(j)
	do i=1,nt
	  sint = sinat(i)
	  cost = cosat(i)
	  ue = (sint*cosp*sint*sinp*cost)**2
	  errm = amax1(errm,abs((u(i,j)-ue)))
	end do
      end do
      write(*,108) errm
  108 format(' maximum error  = ',e10.3 )
      end if
      end

      function sigt(t,p)
c
c     colatitude coefficient (this will be called off grid by mud2sa)
c
      implicit none
      real t,p,sigt,sint,cosp
      sint = sin(t)
      cosp = cos(p)
      sigt = sint*(1.5+(sint*cosp)**2)
      return
      end

      function sigp(t,p)
c
c     longitude coefficient (this will be called off grid by mud2sa)
c
      implicit none
      real t,p,sigp,sint,cosp
      sint = sin(t)
      cosp = cos(p)
c     avoid polar singularities and division by zero
      if (abs(sint) .gt. 1.e-7) then
      sigp = (1.5+(sint*cosp)**2)/sint
      else
      sigp = 1.0
      end if
      return
      end

      function xlmb(t,p)
c
c     zero order coefficient evaluated only on grid points
c
      implicit none
      real t,p,xlmb
      integer i,j
      integer intl,nta,ntb,npc,npd,itp,jpq,iet,jep,nt,np,
     +                iguess,maxcy,method,nwork,lwork,iter
      real ta,tb,pc,pd,tolmax,sinat,cosat,sinap,cosap,dlt,dlp
      common / iprm / intl,nta,ntb,npc,npd,itp,jpq,iet,jep,nt,np,
     +                iguess,maxcy,method,nwork,lwork,iter
      common / fprm / ta,tb,pc,pd,tolmax,sinat(81),cosat(81),
     +                sinap(161),cosap(161),dlt,dlp
      i = int((t-ta)/dlt+0.5)+1
      j = int((p-pc)/dlp+0.5)+1
      xlmb = sinat(i)*(1.5 + (sinat(i)*cosap(j))**2)
      return
      end

      subroutine bndc(kbdy,torp,alfa,gbdy)
c
c     this subroutine must be provided as a dummy argument even though
c     there are no mixed derivative b.c.
c
      implicit none
      integer kbdy
      real torp,alfa,gbdy
      return
      end


</PRE>
<HR>
 
<a name="tmud2sp.txt"><b>TMUD2SP</b></a>
<PRE>
c
c     file tmud2sp.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the mudpack solver mud2sp
c
c ... required mudpack files
c
c     mud2sp.f, mudcom.f
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for mud2sp
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for mud2sp is listed below.  it
c     can be executed as an initial test.  the output is listed for
c     listed for the test case described.
c
c     test the driver below by solving the separable elliptic pde
c
c     (1.+x**2)*pxx + exp(1.-y)*(pyy-py) - (x+y)*pe = r(x,y)
c
c     on the unit square with specified boundary conditions at
c     xb = 1.0, yc = 0.0 and mixed boundary conditions
c
c          dp/dx - pe(0.0,y) = ga(y)  (at x = 0.0)
c
c          dp/dy + pe(x,1.0) = gd(x)  (at y = 1.0)
c
c     use point relaxation and choose a grid as close to 60 x 50
c     as the grid size constraints allow.  use the exact solution
c
c          pe(x,y) = (x**3+y**3+1.0)/3
c
c     for testing.
c
c *************************************************************
c     output (32 bit floating point arithmetic)
c *************************************************************
c
c      mud2sp test
c
c     integer input arguments
c     intl =  0 nxa =  2 nxb =  1 nyc =  1 nyd =  2
c     ixp =  2 jyq =  3 iex =  6 jey =  5
c     nx =  65 ny =  49 iguess =  0 maxcy =  1
c     method =  0 work space estimate =   17065
c
c     multigrid option arguments
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     xa =  0.000 xb =  1.000 yc =  0.000 yd =  1.000
c     tolerance (error control) =    0.000E+00
c
c     discretization call to mud2sp intl =  0
c     ierror =  0 minimum work space =   13264
c
c     approximation call to mud2sp
c     intl =  1 method =  0 iguess =  0
c     ierror =  0
c     maximum error  =   0.520E-04
c
c ***************************************************************
c      end of output
c ***************************************************************
c
      program tmud2sp
      implicit none
      integer iixp,jjyq,iiex,jjey,nnx,nny,llwork
c
c     set grid sizes with parameter statements
c
      parameter (iixp = 2 , jjyq = 3 , iiex = 6, jjey = 5)
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     set work space length approximation for point relaxation
c     see (mud2sp.d)
c
      parameter (llwork=5*(nnx*nny+2*(nnx+nny)))
      real phi(nnx,nny),rhs(nnx,nny),work(llwork)
c
c     put integer and floating point argument names in contiguous
c     storeage for labelling in vectors iprm,fprm
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itmud2sp/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftmud2sp/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      real dlx,dly,x,y,cxx,cyy,cx,cy,ce,pxx,pyy,px,py,pe,errmax
      real cex,cey
c
c     declare coefficient and boundary condition input subroutines external
c
      external cofx,cofy,bndsp
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 2
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set multigrid arguments (w(2,1) cycling with fully weighted
c     residual restriction and cubic prolongation)
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set for one cycle
c
      maxcy = 1
c
c     set no initial guess forcing full multigrid cycling
c
      iguess = 0
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set point relaxation
c
      method = 0
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control flag
c
      tolmax = 0.0
c
c     set right hand side in rhs
c     initialize phi to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	call cofx(x,cxx,cx,cex)
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cofy(y,cyy,cy,cey)
	  ce = cex+cey
	  call exact(x,y,pxx,pyy,px,py,pe)
	  rhs(i,j) = cxx*pxx+cyy*pyy+cx*px+cy*py+ce*pe
	  phi(i,j) = 0.0
	end do
      end do
c
c     set specified boundaries in phi
c
      x = xb
      do j=1,ny
	y = yc+float(j-1)*dly
	call exact(x,y,pxx,pyy,px,py,pe)
	phi(nx,j) = pe
      end do
      y = yc
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exact(x,y,pxx,pyy,px,py,pe)
	phi(i,1) = pe
      end do
      write(*,100)
  100 format(//' mud2sp test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to mud2sp', ' intl = ', i2)
      call mud2sp(iprm,fprm,work,cofx,cofy,bndsp,rhs,phi,mgopt,ierror)
c
c     print error parameter and minimum work space requirement
c
      write (*,200) ierror,iprm(16)
  200 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess
  106 format(/' approximation call to mud2sp',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2)
      call mud2sp(iprm,fprm,work,cofx,cofy,bndsp,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
      if (ierror .le. 0) then
c
c     compute and print maximum norm of error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,pxx,pyy,px,py,pe)
	  errmax = amax1(errmax,abs((phi(i,j)-pe)))
	end do
      end do
      write(*,201) errmax
  201 format(' maximum error  =  ',e10.3)
      end if
      end

      subroutine cofx(x,cxx,cx,cex)
c
c     input x dependent coefficients
c
      implicit none
      real x,cxx,cx,cex
      cxx = 1.0+x*x
      cx = 0.0
      cex = -x
      return
      end

      subroutine cofy(y,cyy,cy,cey)
c
c     input y dependent coefficients
c
      implicit none
      real y,cyy,cy,cey
      cyy = exp(1.0-y)
      cy = -cyy
      cey = -y
      return
      end

      subroutine bndsp(kbdy,xory,alfa,gbdy)
c
c     input mixed derivative b.c. to mud2sp
c
      implicit none
      integer kbdy
      real xory,alfa,gbdy,x,y,pe,px,py,pxx,pyy
      real xa,xb,yc,yd,tolmax,relmax
      common/ftmud2sp/xa,xb,yc,yd,tolmax,relmax
      if (kbdy.eq.1) then  ! x=xa boundary
	y = xory
	x = xa
	call exact(x,y,pxx,pyy,px,py,pe)
	alfa = -1.0
	gbdy = px + alfa*pe
	return
      end if
      if (kbdy.eq.4) then  ! y=yd boundary
	y = yd
	x = xory
	call exact(x,y,pxx,pyy,px,py,pe)
	alfa = 1.0
	gbdy = py + alfa*pe
	return
      end if
      end

      subroutine exact(x,y,pxx,pyy,px,py,pe)
c
c     set an exact solution for testing mud2sp
c
      implicit none
      real x,y,pxx,pyy,px,py,pe
      pe = (x**3+y**3+1.0)/3.0
      px = x*x
      py = y*y
      pxx = x+x
      pyy = y+y
      return
      end

</PRE>
<HR>
 
<a name="tmud3.txt"><b>TMUD3</b></a>
<PRE>
c
c     file tmud3.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver mud3
c
c ... required MUDPACK files
c
c     mud3.f, mudcom.f, mud3ln.f, mud3pn.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for mud3
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for mud3 is below. it can be
c     executed as an initial test.  the output is listed for the
c     test case described.
c
c     test the driver below by solving the nonseparable 3-d elliptic pde
c
c          pxx+pyy+pzz-y*z*px-x*z*py-x*y*pz-x*y*z*pe = r(x,y,z)
c
c     on a 33 by 25 by 65 grid superimposed on the (x,y,z) region
c
c          [0.5,1.0] X [1.0,2.0] X [0.25,0.75]
c
c     the solution is specified at x=0.5,1.0 and y=1.0,2.0 and there are
c     mixed derivative conditions of the form
c
c          dp/dz - (x*y)*p = g(x,z) at z=0.25
c
c          dp/dz + (x*y)*p = h(x,y) at z=0.75
c
c     one full multigrid cycle using the default multigrid options
c     and line relaxation in the z direction is executed.  The
c     exact solution
c
c          pe(x,y,z) = exp(x*y*z)
c
c     is used to set the right hand side of the pde, boundary conditions
c     and compute error.
c
c ******************************************************
c     output (32 bit floating point arithmetic)
c *******************************************************
c
c     mud3 test
c
c     input arguments
c     intl =  0 nxa =  1 nxb =  1 nyc =  1 nyd =  1
c     nze =  2 nzf =  2
c     ixp =  2 jyq =  3 kzr =  2
c     iex =  5 jey =  4 kez =  6
c     nx =  33 ny =  25 nz =  65 iguess =  0 maxcy =  1
c     method =  3 work space length input =  949725
c     xa =  0.50 xb =  1.00
c     yc =  1.00 yd =  2.00
c     ze =  0.25 zf =  0.75
c     tolmax =  0.000E+00
c
c     multigrid options
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     discretization call to mud3 intl =  0
c     ierror =  0 minimum work space =  824224
c
c     approximation call to mud3
c     intl =  1 method =  3 iguess =  0 maxcy =  1
c     ierror =  0
c     maximum error  =   0.117E-04
c
c ************************************************************
c     end of output
c ************************************************************
c
      program tmud3
      implicit none
c
c     set grid sizes with parameter statements
c
      integer iixp,jjyq,kkzr,iiex,jjey,kkez,llwork,nnx,nny,nnz
      parameter(iixp=2,jjyq=3,kkzr=2)
      parameter(iiex=5,jjey=4,kkez=6)
      parameter (nnx = iixp*2**(iiex-1)+1)
      parameter (nny = jjyq*2**(jjey-1)+1)
      parameter (nnz = kkzr*2**(kkez-1)+1)
c
c     set work space length estimate for method=3 (see mud3.d).
c     this will probably overestimate required space
c
      parameter (llwork = 15*(nnx+2)*(nny+2)*(nnz+2) )
c
c
c     dimension solution,right hand side, and work arrays
c
      real phi(nnx,nny,nnz),rhs(nnx,nny,nnz),work(llwork)
      integer iprm(23),mgopt(4)
      real fprm(8)
c
c     put integer and floating point arguments names in contiguous
c     storeage labelling
c
      integer intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,
     +              lwrkqd,itero
      common/itmud3/intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,
     +              lwrkqd,itero

      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmud3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real dlx,dly,dlz,x,y,z,cxx,cyy,czz,cx,cy,cz,ce,errm
      real pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k,ierror
      equivalence(intl,iprm)
      equivalence(xa,fprm)
c
c     declare coefficient and boundary condition input subroutines external
c
      external cof,bndc
c
c     set for initial call
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 1
      nyc = 1
      nyd = 1
      nze = 2
      nzf = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      kzr = kkzr
      iex = iiex
      jey = jjey
      kez = kkez
      nx = nnx
      ny = nny
      nz = nnz
c
c     set for one multigrid cycles
c
      maxcy = 1
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set method of relaxation--line in the z direction
c
      method = 3
c
c     meth2 only used in planar relaxation--but set
c
      meth2 = 0
c
c     set full multigrid cycling by flagging no initial guess at the finest
c     grid level
c
      iguess = 0
c
c     set end points of solution region in (x,y,z) space
c
      xa = 0.5
      xb = 1.0
      yc = 1.0
      yd = 2.0
      ze = 0.25
      zf = 0.75
c
c     set default multigrid options
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
      dlz = (zf-ze)/float(nz-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in rhs and phi to zero
c
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    rhs(i,j,k) = cxx*pxx+cyy*pyy+czz*pzz+cx*px+cy*py+cz*pz+ce*pe
	    phi(i,j,k) = 0.0
	  end do
	end do
      end do
c
c     set specified values at x and y boundaries in phi
c
      x = xa
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(1,j,k) = pe
	end do
      end do
      x = xb
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(nx,j,k) = pe
	end do
      end do
      y = yc
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,1,k) = pe
	end do
      end do
      y = yd
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,ny,k) = pe
	end do
      end do
      write(6,50)
   50 format(//' mud3 test ')
c
c     print input arguments
c
      write(6,100)intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,kez,
     +            nx,ny,nz,iguess,maxcy,method,nwork,xa,xb,yc,yd,ze,zf,
     +            tolmax,mgopt(1),mgopt(2),mgopt(3),mgopt(4)
  100 format(/' input arguments ',
     +/' intl = ',i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = 'i2,
     +/' nze = ',i2, ' nzf = ',i2,
     +/' ixp = ',i2,' jyq = 'i2,' kzr = 'i2,
     +/' iex = ',i2, ' jey = 'i2, ' kez = 'i2,
     +/' nx = 'i3,' ny = 'i3,' nz = 'i3, ' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space length input = ',i7,
     +/' xa = 'f5.2,' xb = 'f5.2,
     +/' yc = 'f5.2,' yd = 'f5.2,
     +/' ze = 'f5.2,' zf = 'f5.2,
     +/' tolmax = ' ,e10.3
     +//' multigrid options '
     +/' kcycle = ',i2
     +/' iprer = ',i2
     +/' ipost = ',i2
     +/' intpol = ',i2 )
c
c     discretize pde
c
      write(*,104) intl
  104 format(/' discretization call to mud3', ' intl = ', i2)
      call mud3(iprm,fprm,work,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,105) ierror,iprm(22)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     approximate pde
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to mud3 ',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call mud3(iprm,fprm,work,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum error
c
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
  108 format(' maximum error  =  ',e10.3)
      end

      subroutine error(nx,ny,nz,phi,errm)
c
c     compute the error in the estimate in phi
c
      implicit none
      integer nx,ny,nz
      real phi(nx,ny,nz),errm
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmud3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real dlx,dly,dlz,x,y,z,pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k
      dlx = (xb-xa)/(nx-1)
      dly = (yd-yc)/(ny-1)
      dlz = (zf-ze)/(nz-1)
      errm = 0.0
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    errm = amax1(errm,abs(phi(i,j,k)-pe))
	  end do
	end do
      end do
      return
      end

      subroutine cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
c
c     input pde coefficients at grid point (x,y,z) in the solution region
c     to subroutine mud3
c
      implicit none
      real x,y,z,cxx,cyy,czz,cx,cy,cz,ce
      cxx = 1.0
      cyy = 1.0
      czz = 1.0
      cx = -y*z
      cy = -x*z
      cz = -x*y
      ce = -(x*y*z)
      return
      end

      subroutine bndc(kbdy,xory,yorz,alfa,gbdy)
c
c     input mixed derivative conditions at z boundaries to mud3
c
      implicit none
      integer kbdy
      real xory,yorz,alfa,gbdy
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmud3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real x,y,z,pxx,pyy,pzz,px,py,pz,pe
      if (kbdy.eq.5) then
c
c     z = ze (lower z boundary)
c
	z = ze
	x = xory
	y = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	alfa = -(x*y)
	gbdy = pz + alfa*pe
	return
      end if
      if (kbdy.eq.6) then
c
c     z=zf (upper z boundary)
c
	z = zf
	x = xory
	y = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	alfa = (x*y)
	gbdy = pz + alfa*pe
	return
      end if
      end

      subroutine exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
c
c     this subroutine is used to set an exact solution for testing mud3
c
      implicit none
      real x,y,z,pe,px,py,pz,pxx,pyy,pzz
      pe = exp(x*y*z)
      px = y*z*pe
      py = x*z*pe
      pz = x*y*pe
      pxx = (y*z)*px
      pyy = (x*z)*py
      pzz = (x*y)*pz
      return
      end

</PRE>
<HR>
 
<a name="tmud34.txt"><b>TMUD34</b></a>
<PRE>
c
c     file tmud34.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver mud34
c
c ... required MUDPACK files
c
c     mud34.f, mud3.f, mudcom.f, mud3ln.f, mud3pn.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for mud34
c
c **********************************************************
c **********************************************************
c
c     a sample program/test driver for mud34 is below. it can be
c     executed as an initial test.  the output is listed for the
c     test case described.
c
c     test the driver below by solving the nonseparable 3-d elliptic pde
c
c          pxx+pyy+pzz-y*z*px-x*z*py-x*y*pz-x*y*z*pe = r(x,y,z)
c
c     on a 33 by 25 by 65 grid superimposed on the (x,y,z) region
c
c          [0.5,1.0] X [1.0,2.0] X [0.25,0.75]
c
c     the solution is specified at x=0.5,1.0 and y=1.0,2.0 and there are
c     mixed derivative conditions of the form
c
c          dp/dz - (x*y)*p = g(x,z) at z=0.25
c
c          dp/dz + (x*y)*p = h(x,y) at z=0.75
c
c     One full multigrid cycle using the default multigrid options
c     and line relaxation in the z direction is first executed (see
c     tmud3.f) with mud3.  Then two additional cycles are executed
c     with iguess=1 to ensure that second-order discretization level
c     error is reached (a requirement for fourth-order mudpack solvers).
c     Finally mud34 is called to produce a fourth-order estimate.
c     the exact solution
c
c          pe(x,y,z) = exp(x*y*z)
c
c     is used to set the right hand side of the pde, boundary conditions
c     and compute error.
c
c
c ******************************************************
c     output (64 bit floating point arithmetic)
c *******************************************************
c
c     mud3 test
c
c     input arguments
c     intl =  0 nxa =  1 nxb =  1 nyc =  1 nyd =  1
c     nze =  2 nzf =  2
c     ixp =  2 jyq =  3 kzr =  2
c     iex =  5 jey =  4 kez =  6
c     nx =  33 ny =  25 nz =  65 iguess =  0 maxcy =  1
c     method =  3 work space length input =  824224
c     xa =  0.50 xb =  1.00
c     yc =  1.00 yd =  2.00
c     ze =  0.25 zf =  0.75
c     tolmax =  0.000E+00
c
c     multigrid options
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     discretization call to mud3 intl =  0
c     ierror =  0 minimum work space =  824224
c
c     approximation call to mud3
c     intl =  1 method =  3 iguess =  0 maxcy =  1
c     ierror =  0
c     maximum error  =   0.146E-04
c
c     approximation call to mud3
c     intl =  1 method =  3 iguess =  1 maxcy =  2
c     ierror =  0
c     maximum error  =   0.146E-04
c
c     mud34 test  ierror =  0
c     maximum error  =   0.373E-06
c
c ************************************************************
c     end of output
c ************************************************************
c
      program tmud34
      implicit none
c
c     set grid sizes with parameter statements
c
      integer iixp,jjyq,kkzr,iiex,jjey,kkez,llwork,nnx,nny,nnz
      parameter(iixp=2,jjyq=3,kkzr=2)
      parameter(iiex=5,jjey=4,kkez=6)
      parameter (nnx = iixp*2**(iiex-1)+1)
      parameter (nny = jjyq*2**(jjey-1)+1)
      parameter (nnz = kkzr*2**(kkez-1)+1)
c
c     set exact minimal work space (see tmud3.f)
c
      parameter (llwork = 824224 )
c
c     dimension solution,right hand side, and work arrays
c
      real phi(nnx,nny,nnz),rhs(nnx,nny,nnz),work(llwork)
      integer iprm(23),mgopt(4)
      real fprm(8)
c
c     put integer and floating point arguments names in contiguous
c     storeage for labelling purposes
c
      integer intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,
     +              lwrkqd,itero
      common/itmud3/intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,
     +              lwrkqd,itero
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmud3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real dlx,dly,dlz,x,y,z,cxx,cyy,czz,cx,cy,cz,ce,errm
      real pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k,ierror
      equivalence(intl,iprm)
      equivalence(xa,fprm)
c
c     declare coefficient and boundary condition input subroutines external
c
      external cof,bndc
c
c     set for initial call
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 1
      nyc = 1
      nyd = 1
      nze = 2
      nzf = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      kzr = kkzr
      iex = iiex
      jey = jjey
      kez = kkez
      nx = nnx
      ny = nny
      nz = nnz
c
c     set for one multigrid cycles
c
      maxcy = 1
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set method of relaxation--line in the z direction
c
      method = 3
c
c     meth2 only used in planar relaxation--but set
c
      meth2 = 0
c
c     set full multigrid cycling by flagging no initial guess at the finest
c     grid level
c
      iguess = 0
c
c     set end points of solution region in (x,y,z) space
c
      xa = 0.5
      xb = 1.0
      yc = 1.0
      yd = 2.0
      ze = 0.25
      zf = 0.75
c
c     set default multigrid options
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
      dlz = (zf-ze)/float(nz-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in rhs and phi to zero
c
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    rhs(i,j,k) = cxx*pxx+cyy*pyy+czz*pzz+cx*px+cy*py+cz*pz+ce*pe
	    phi(i,j,k) = 0.0
	  end do
	end do
      end do
c
c     set specified values at x and y boundaries in phi
c
      x = xa
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(1,j,k) = pe
	end do
      end do
      x = xb
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(nx,j,k) = pe
	end do
      end do
      y = yc
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,1,k) = pe
	end do
      end do
      y = yd
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,ny,k) = pe
	end do
      end do
      write(6,50)
   50 format(//' mud3 test ')
c
c     print input arguments
c
      write(6,100)intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,kez,
     +            nx,ny,nz,iguess,maxcy,method,nwork,xa,xb,yc,yd,ze,zf,
     +            tolmax,mgopt(1),mgopt(2),mgopt(3),mgopt(4)
  100 format(/' input arguments ',
     +/' intl = ',i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = 'i2,
     +/' nze = ',i2, ' nzf = ',i2,
     +/' ixp = ',i2,' jyq = 'i2,' kzr = 'i2,
     +/' iex = ',i2, ' jey = 'i2, ' kez = 'i2,
     +/' nx = 'i3,' ny = 'i3,' nz = 'i3, ' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space length input = ',i7,
     +/' xa = 'f5.2,' xb = 'f5.2,
     +/' yc = 'f5.2,' yd = 'f5.2,
     +/' ze = 'f5.2,' zf = 'f5.2,
     +/' tolmax = ' ,e10.3
     +//' multigrid options '
     +/' kcycle = ',i2
     +/' iprer = ',i2
     +/' ipost = ',i2
     +/' intpol = ',i2 )
c
c     discretize pde
c
      write(*,104) intl
  104 format(/' discretization call to mud3', ' intl = ', i2)
      call mud3(iprm,fprm,work,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,105) ierror,iprm(22)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     approximate pde
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to mud3 ',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call mud3(iprm,fprm,work,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
  108 format(' maximum error  =  ',e10.3)
c
c     execute two more cycles using this estimate to ensure second-order
c
      iguess = 1
      maxcy = 2
      write(*,106) intl,method,iguess,maxcy
      call mud3(iprm,fprm,work,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,107) ierror
      if (ierror.gt.0) call exit(0)
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
c
c     attempt fourth-order approximation
c
      call mud34(work,phi,ierror)
      write (*,109) ierror
  109 format(/ ' mud34 test ', ' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
      end

      subroutine error(nx,ny,nz,phi,errm)
c
c     compute the maximum error in the estimate in phi
c
      implicit none
      integer nx,ny,nz
      real phi(nx,ny,nz),errm
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmud3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real dlx,dly,dlz,x,y,z,pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k
      dlx = (xb-xa)/(nx-1)
      dly = (yd-yc)/(ny-1)
      dlz = (zf-ze)/(nz-1)
      errm = 0.0
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    errm = amax1(errm,abs(phi(i,j,k)-pe))
	  end do
	end do
      end do
      return
      end

      subroutine cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
c
c     input pde coefficients at grid point (x,y,z) in the solution region
c     to subroutine mud3
c
      implicit none
      real x,y,z,cxx,cyy,czz,cx,cy,cz,ce
      cxx = 1.0
      cyy = 1.0
      czz = 1.0
      cx = -y*z
      cy = -x*z
      cz = -x*y
      ce = -(x*y*z)
      return
      end

      subroutine bndc(kbdy,xory,yorz,alfa,gbdy)
c
c     input mixed derivative conditions at z boundaries to mud3
c
      implicit none
      integer kbdy
      real xory,yorz,alfa,gbdy
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmud3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real x,y,z,pxx,pyy,pzz,px,py,pz,pe
      if (kbdy.eq.5) then
c
c     z = ze (lower z boundary)
c
	z = ze
	x = xory
	y = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	alfa = -(x*y)
	gbdy = pz + alfa*pe
	return
      end if
      if (kbdy.eq.6) then
c
c     z=zf (upper z boundary)
c
	z = zf
	x = xory
	y = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	alfa = (x*y)
	gbdy = pz + alfa*pe
	return
      end if
      end

      subroutine exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
c
c     this subroutine sets an exact solution for testing mud34
c
      implicit none
      real x,y,z,pe,px,py,pz,pxx,pyy,pzz
      pe = exp(x*y*z)
      px = y*z*pe
      py = x*z*pe
      pz = x*y*pe
      pxx = (y*z)*px
      pyy = (x*z)*py
      pzz = (x*y)*pz
      return
      end

</PRE>
<HR>
 
<a name="tmud34sp.txt"><b>TMUD34SP</b></a>
<PRE>
c
c     file tmud34sp.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver mud34sp
c
c ... required MUDPACK files
c
c     mud34sp.f, mud3sp.f, mudcom.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for mud34sp
c
c **********************************************************
c **********************************************************
c
c     a sample program/test driver for mud3sp is below. it can be
c     executed as an initial test.  the output is listed for the
c     test case described.
c
c     test the driver below by solving the separable elliptic pde
c
c        d(x**2*dp/dx)/dx + d(y**2*dp/dy)/dy + d(z**2*dp/dz)/dz
c
c        - (x+y+z)*pe(x,y,z) = r(x,y,z)
c
c
c     on the cube [0.5,1.0]**3 with specified boundary conditions at x,y,z=1.0
c     and derivative boundary conditions of the form
c
c        dp/dx - pe(0.5,y,z) = f(0.5,y,z) at x = 0.5
c
c        dp/dy - pe(x,0.5,z) = g(x,0.5,z) at y = 0.5
c
c        dp/dz - pe(x,y,0.5) = h(x,y,0.5) at z = 0.5
c
c     generate the approximation on a  65 x 49 x 41 grid using the exact
c     solution
c
c          pe(x,y,z) = (x*y*z)**4
c
c     for testing.  First mud3sp is called to produce a second-order estimate.
c     Then mud34sp is called for the fourth-order approximation
c
c ******************************************************
c     output (64 bit floating point arithmetic)
c *******************************************************
c
c     mud3sp test
c
c     input arguments
c     intl =  0 nxa =  2 nxb =  1 nyc =  2 nyd =  1
c     nze =  2 nzf =  1
c     ixp =  2 jyq =  3 kzr =  5
c     iex =  6 jey =  5 kez =  4
c     nx =  65 ny =  49 nz =  41 iguess =  0 maxcy =  3
c     method =  0 work space length input =  514258
c     xa =  0.50 xb =  1.00
c     yc =  0.50 yd =  1.00
c     ze =  0.50 zf =  1.00
c     tolmax =  0.000E+00
c
c     multigrid options
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     discretization call to mud3sp intl =  0
c     ierror =  0 minimum work space =  472557
c
c     approximation call to mud3sp
c     intl =  1 method =  0 iguess =  0 maxcy =  3
c     ierror =  0
c     maximum error  =   0.741E-05
c
c     mud34sp test  ierror =  0
c     maximum error  =   0.207E-06
c
c ************************************************************
c     end of output
c ************************************************************
c
c
      program tmud34sp
c
c     set grid sizes with parameter statements
c
      implicit none
c
c     set grid sizes with parameter statements
c
      integer iixp,jjyq,kkzr,iiex,jjey,kkez,llwork,nnx,nny,nnz
      parameter(iixp=2,jjyq=3,kkzr=5)
      parameter(iiex=6,jjey=5,kkez=4)
      parameter (nnx = iixp*2**(iiex-1)+1)
      parameter (nny = jjyq*2**(jjey-1)+1)
      parameter (nnz = kkzr*2**(kkez-1)+1)
c
c     set work space length approximation (see mud3sp.d)
c
      parameter(llwork = 7*(nnx+2)*(nny+2)*(nnz+2)/2 )
c
c
c     dimension solution,right hand side, and work arrays
c
      real phi(nnx,nny,nnz),rhs(nnx,nny,nnz),work(llwork)
      integer iprm(22),mgopt(4)
      real fprm(8)
c
c     put integer and floating point arguments names in contiguous
c     storeage for labelling
c
      integer intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,nwork,lwrkqd,itero
      common/itmsp3/intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmsp3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real dlx,dly,dlz,x,y,z,cxx,cyy,czz,cx,cy,cz,cex,cey,cez,ce,errm
      real pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k,ierror
      equivalence(intl,iprm)
      equivalence(xa,fprm)
c
c     declare coefficient and boundary condition input subroutines external
c
      external cfx,cfy,cfz,bndc
c
c
c     set input integer parameters
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 2
      nxb = 1
      nyc = 2
      nyd = 1
      nze = 2
      nzf = 1

c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      kzr = kkzr
      iex = iiex
      jey = jjey
      kez = kkez
      nx = nnx
      ny = nny
      nz = nnz
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set method of relaxation--point gauss/seidel only for mud3sp
c
      method = 0
c
c     set default multigrid options
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set full multigrid cycling by flagging no initial guess
c
      iguess = 0
c
c     set a limit of three w(2,1) cycles from the finest level
c
      maxcy = 3
c
c     set end points of solution cube in (x,y,z) space
c
      xa = 0.5
      xb = 1.0
      yc = 0.5
      yd = 1.0
      ze = 0.5
      zf = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
      dlz = (zf-ze)/float(nz-1)
c
c     set for no error control (this allows phi to be equivlaenced with work)
c
      tolmax = 0.0
c
c     set right hand side in rhs using exact solution
c     and initialize phi to zero
c
      do k=1,nz
	z = ze+(k-1)*dlz
	call cfz(z,czz,cz,cez)
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cfy(y,cyy,cy,cey)
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call cfx(x,cxx,cx,cex)
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    ce = cex+cey+cez
	    rhs(i,j,k) = cxx*pxx+cyy*pyy+czz*pzz+cx*px+cy*py+cz*pz+ce*pe
	    phi(i,j,k) = 0.0
	  end do
	end do
      end do
c
c     set specified values at upper boundaries
c
      x = xb
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(nx,j,k) = pe
	end do
      end do
      y = yd
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,ny,k) = pe
	end do
      end do
      z = zf
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,j,nz) = pe
	end do
      end do
      write(6,50)
   50 format(//' mud3sp test ')
c
c     print input arguments
c
      write(6,100)intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,kez,
     +            nx,ny,nz,iguess,maxcy,method,nwork,xa,xb,yc,yd,ze,zf,
     +            tolmax,mgopt(1),mgopt(2),mgopt(3),mgopt(4)
  100 format(/' input arguments ',
     +/' intl = ',i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = 'i2,
     +/' nze = ',i2, ' nzf = ',i2,
     +/' ixp = ',i2,' jyq = 'i2,' kzr = 'i2,
     +/' iex = ',i2, ' jey = 'i2, ' kez = 'i2,
     +/' nx = 'i3,' ny = 'i3,' nz = 'i3, ' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space length input = ',i7,
     +/' xa = 'f5.2,' xb = 'f5.2,
     +/' yc = 'f5.2,' yd = 'f5.2,
     +/' ze = 'f5.2,' zf = 'f5.2,
     +/' tolmax = ' ,e10.3
     +//' multigrid options '
     +/' kcycle = ',i2
     +/' iprer = ',i2
     +/' ipost = ',i2
     +/' intpol = ',i2 )
c
c     discretize pde
c
      write(*,104) intl
  104 format(/' discretization call to mud3sp', ' intl = ', i2)
      call mud3sp(iprm,fprm,work,cfx,cfy,cfz,bndc,rhs,phi,mgopt,ierror)
      write (*,105) ierror,iprm(21)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     approximate pde
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to mud3sp ',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call mud3sp(iprm,fprm,work,cfx,cfy,cfz,bndc,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum error
c
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
  108 format(' maximum error  =  ',e10.3)
c
c     compute fourth-order approximation
c
      call mud34sp(work,phi,ierror)
      write (*,109) ierror
  109 format (/' mud34sp test ', ' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
      end

      subroutine error(nx,ny,nz,phi,errm)
c
c     compute the error in the estimate in phi
c
      implicit none
      integer nx,ny,nz
      real phi(nx,ny,nz),errm
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmsp3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real dlx,dly,dlz,x,y,z,pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k
      dlx = (xb-xa)/(nx-1)
      dly = (yd-yc)/(ny-1)
      dlz = (zf-ze)/(nz-1)
      errm = 0.0
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    errm = amax1(errm,abs(phi(i,j,k)-pe))
	  end do
	end do
      end do
      return
      end
c
c     coefficient subroutines
c
      subroutine cfx(x,cxx,cx,cex)
      implicit none
      real x,cxx,cx,cex
      cxx = x*x
      cx = x+x
      cex = -x
      return
      end

      subroutine cfy(y,cyy,cy,cey)
      implicit none
      real y,cyy,cy,cey
      cyy = y*y
      cy = y+y
      cey = -y
      return
      end

      subroutine cfz(z,czz,cz,cez)
      implicit none
      real z,czz,cz,cez
      czz = z*z
      cz = z+z
      cez = -z
      return
      end

      subroutine bndc(kbdy,xory,yorz,cons,gbdy)
c
c     input derivative boundary conditions to mud3sp
c     at lower x,y,z boundaries
c
      implicit none
      integer kbdy
      real xory,yorz,cons,gbdy,x,y,z,pxx,pyy,pzz,px,py,pz,pe
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmsp3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      if (kbdy.eq.1) then
c
c     x=xa surface
c
	x = xa
	y = xory
	z = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	cons = -1.0
	gbdy = px+cons*pe
	return
      end if
      if (kbdy.eq.3) then
c
c     y=yc surface
c
	y = yc
	x = xory
	z = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	cons = -1.0
	gbdy = py+cons*pe
	return
      end if
      if (kbdy.eq.5) then
c
c     z=ze surface
c
	z = ze
	x = xory
	y = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	cons = -1.0
	gbdy = pz + cons*pe
	return
      end if
      end

      subroutine exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
c
c     this subroutine is used to set an exact solution for testing mud3sp
c     (i.e., setting the rhs, boundary conditions and computing the exact
c     error)
c
      implicit none
      real x,y,z,pxx,pyy,pzz,px,py,pz,pe
      pe = (x*y*z)**4
      px = 4.*(x*y*z)**3*y*z
      py = 4.*(x*y*z)**3*x*z
      pz = 4.*(x*y*z)**3*x*y
      pxx = 12.*(x*y*z)**2*(y*z)**2
      pyy = 12.*(x*y*z)**2*(x*z)**2
      pzz = 12.*(x*y*z)**2*(x*y)**2
      return
      end
</PRE>
<HR>
 
<a name="tmud3cr.txt"><b>TMUD3CR</b></a>
<PRE>
c
c     file tmud3cr.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver mud3cr
c
c ... required MUDPACK files
c
c     mud3cr.f, mudcom.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for mud3cr (see mud3cr.d)
c
c **********************************************************
c **********************************************************
c
c     a sample program/test driver for mud3cr is below. it can be
c     executed as an initial test.  The output from executing
c     the code in this file is listed after the problem description.
c
c     Problem Description:
c
c     test mud3cr by solving the nonseparable 3-d elliptic pde
c     with cross derivative terms:
c
c          cxx*pxx + cyy*pyy + czz*pzz + cx*px + cy*py + cz*pz + ce*pe +
c
c          cxy*pxy + cxz*pxz + cyz*pyz = r(x,y,z).
c
c     on the region 0 < x < 1, 0 < y < (pi+pi), 0 < z < 1.
c     let s = sin(y).  the coefficients are given by:
c
c          cxx = 1.0+0.5*s*z, cyy = 1+x*z, czz = 1+0.5*s*x
c
c          cx = 0.0, cy = -x*z, cz = 0.0, ce = -(x+z)
c
c          cxy = sqrt(cxx*cyy), cxz = 0.0, cyz = sqrt(cyy*czz)
c
c     assume the solution is periodic in y and is specified at x=0 and z=0.
c     further assume mixed oblique derivative conditions of the form
c
c          px + (z*(1-z))*py + sin(y)*cos(y)*pz - p(1,y,z) = g(y,z)
c
c     at x=1 and mixed normal derivative conditions of the form
c
c          pz + x*s*s*p(x,y,1)  = h(x,y)
c
c     at z=1.  for testing purposes use the exact solution
c
c          p(x,y,z) = (x*cos(y)*z)**3
c
c     to set boundary conditions, the right hand side, and compute
c     exact error.  results from approximating this problem on a
c     25 by 129 by 25 x-y-z grid using mud3cr are given below.  point
c     relaxation and an error tolerance of .001 are used.
c
c ******************************************************
c     output (32 bit floating point arithmetic)
c *******************************************************
c
c     mud3cr test
c
c     input arguments
c     intl =  0
c     nxa =  1 nxb =  2
c     nyc =  0 nyd =  0
c     nze =  1 nzf =  2
c     ixp =  3 jyq =  2 kzr =  3
c     iex =  4 jey =  7 kez =  4
c     nx =  25 ny = 129 nz =  25
c     iguess =  0 maxcy =  2
c     method =  0 work space input = 1176431
c     xa =  0.00 xb =  1.00
c     yc =  0.00 yd =  6.28
c     ze =  0.00 zf =  1.00
c     tolmax =  0.000E+00
c
c     multigrid options
c     mgopt(1)  =  0
c
c     new mud3cr arguments
c     icrs
c        1    0    1
c     tol = 0.0010
c     maxit =  10
c
c     initial call
c     intl =  0
c     iguess =  0
c     ierror =  0
c     minimum required work space length =  1176431
c
c     approximation call
c     intl =  1
c     iguess =  0
c     ierror =   0
c     number of outer iterations executed =   8
c     relative difference profile:
c     0.2694  0.0853  0.0357  0.0135  0.0075  0.0031  0.0016  0.0008
c     exact least squares error =  0.228E-03
c
c ************************************************************
c     end of output
c ************************************************************
c
      program tmd3cr
      implicit none
c
c     set grid sizes and predetermined minimal required equired work
c     with parameter statements
c
      integer iixp,jjyq,kkzr,iiex,jjey,kkez,nnx,nny,nnz,llengt,mmaxit
      parameter(iixp=3 ,jjyq=2,kkzr=3 )
      parameter(iiex=4,jjey=7,kkez=4)
      parameter(nnx = iixp*2**(iiex-1)+1)
      parameter(nny = jjyq*2**(jjey-1)+1)
      parameter(nnz = kkzr*2**(kkez-1)+1)
      parameter(llengt=1176431)
      parameter(mmaxit = 10)
      real rhs(nnx,nny,nnz),phi(nnx,nny,nnz)
      integer iparm(23),mgopt(4),icrs(3)
      integer i,j,k,ierror,maxit,iouter
      real work(llengt),fparm(8),rmax(mmaxit)
c
c     use labelled common to identify integer and floating point arguments
c
      integer intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,lwkmin,itero
      common /iprm/intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,lwkmin,itero
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/fprm/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real pi,dx,dy,dz,c,s,x,y,z,tol,err2
      real cxx,cyy,czz,cx,cy,cz,ce,cxy,cyz
      real pxx,pyy,pzz,px,py,pz,pxy,pxz,pyz,pe
      equivalence(iparm,intl)
      equivalence(fparm,xa)
      external cof,bd3cr,cxyf,cxzf,cyzf
      pi = 4.*atan(1.)
c
c     set interval end points
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = pi+pi
      ze = 0.0
      zf = 1.0
c
c     set required no error control within multigrid cycling
c
      tolmax = 0.0
c
c     set integer input arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 2
      nyc = 0
      nyd = 0
      nze = 1
      nzf = 2
c
c     set grid size arguments from parameter statements
c
      ixp = iixp
      jyq = jjyq
      kzr = kkzr
      iex = iiex
      jey = jjey
      kez = kkez
      nx = nnx
      ny = nny
      nz = nnz
c
c     flag nonzero xy and yz and zero xz cross derivatives terms
c
      icrs(1) = 1
      icrs(2) = 0
      icrs(3) = 1
c
c     set two multigrid cycles per outer iteration
c
      maxcy = 2
c
c     set point relaxation
c
      method = 0
      meth2 = 0
c
c     set work space length input
c
      nwork = llengt
c
c     set uniform grid interval lengths in each dimension
c
      dx = (xb-xa)/(nx-1)
      dy = (yd-yc)/(ny-1)
      dz = (zf-ze)/(nz-1)
c
c     set right hand side and preset solution to zero
c     this also sets specified (Dirchlet) b.c. in phi
c
      do j=1,ny
	y = (j-1)*dy
	s = sin(y)
	do k=1,nz
	  z = (k-1)*dz
	  do i=1,nx
	    x = (i-1)*dx
	    call exact(x,y,z,pe,px,py,pz,pxx,pyy,pzz,pxy,pxz,pyz)
	    call cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
	    call cxyf(x,y,z,cxy)
	    call cyzf(x,y,z,cyz)
	    rhs(i,j,k) = cxx*pxx+cyy*pyy+czz*pzz+cxy*pxy+cyz*pyz+
     +                   cx*px+cy*py+cz*pz+ce*pe
	    phi(i,j,k) = 0.0
	  end do
	end do
      end do
c
c     set default multigrid options
c
      mgopt(1) = 0
c
c     set error control tolerance and outer iteration limit of 10
c
      tol = .001
      maxit = mmaxit
c
c     print input arguments shared with mud3
c
      write(*,50)
   50 format(//' mud3cr test ' )
      write(6,100)intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,kez,
     +            nx,ny,nz,iguess,maxcy,method,nwork,xa,xb,yc,yd,ze,zf,
     +            tolmax,mgopt(1)
  100 format(/' input arguments ',
     +/' intl = ',i2,
     +/' nxa = ',i2,' nxb = ',i2,
     +/' nyc = ',i2,' nyd = ',i2,
     +/' nze = ',i2,' nzf = ',i2,
     +/' ixp = ',i2,' jyq = 'i2,' kzr = 'i2,
     +/' iex = ',i2, ' jey = 'i2, ' kez = 'i2,
     +/' nx = 'i3,' ny = 'i3,' nz = 'i3,
     +/' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space input = ',i7,
     +/' xa = 'f5.2,' xb = 'f5.2,
     +/' yc = 'f5.2,' yd = 'f5.2,
     +/' ze = 'f5.2,' zf = 'f5.2,
     +/' tolmax = ' ,e10.3
     +//' multigrid options '
     +/' mgopt(1)  = ',i2)
c
c     print new mud3cr arguments
c
      write(*,101) (icrs(i),i=1,3),tol,maxit
  101 format(/' new mud3cr arguments ', / ' icrs '/ 3i5,
     +/' tol = ',f6.4 /' maxit = ',i3)
c
c *** initialization call
c
      intl = 0
      iguess = 0
      call mud3cr(iparm,fparm,work,cof,bd3cr,rhs,phi,mgopt,icrs,
     +cxyf,cxzf,cyzf,tol,maxit,iouter,rmax,ierror)
      write (6,200) intl,iguess,ierror,iparm(22)
  200 format(/' initial call', /' intl = ',i2, /' iguess = ',i2,
     +/' ierror = ',i2, /' minimum required work space length = ',i8)
      if (ierror.gt.0) call exit(0)
c
c *** noninitial call
c
      intl = 1
      iguess = 0
      call mud3cr(iparm,fparm,work,cof,bd3cr,rhs,phi,mgopt,icrs,
     +cxyf,cxzf,cyzf,tol,maxit,iouter,rmax,ierror)
      write (6,201) intl,iguess,ierror,iouter,(rmax(i),i=1,iouter)
  201 format(/' approximation call ', /' intl = ',i2, /' iguess = ',i2,
     +/' ierror = ',i3,
     +/' number of outer iterations executed = ',i3,
     +/' relative difference profile:', /(10(f6.4,2x)))
c
c     compute and print exact least squares error after iouter iterations
c
      err2 = 0.
      do j=1,ny
	y = (j-1)*dy
	c = cos(y)
	do k=1,nz
	  z = (k-1)*dz
	  do i=1,nx
	    x = (i-1)*dx
	    pe = (x*c*z)**3
	    err2 = err2 + (pe - phi(i,j,k))**2
	  end do
	end do
      end do
      err2 = sqrt(err2/(nx*ny*nz))
      write(6,202) err2
  202 format(' exact least squares error = ',e10.3)
      end

      subroutine exact(x,y,z,pe,px,py,pz,pxx,pyy,pzz,pxy,pxz,pyz)
c
c     set exact solution and partial derivatives: p(x,y,z) = (x*cos(y)*z)**3
c
      implicit none
      real x,y,z,pe,px,py,pz,pxx,pyy,pzz,pxy,pxz,pyz
      real s,c,x,xc,xz,cz,xcz
      c = cos(y)
      s = sin(y)
      xc = x*c
      xz = x*z
      cz = c*z
      xcz = xc*z
      pe = xcz**3
      px = 3.*x*x*cz**3
      pxx = 6.*x*cz**3
      py = -3.*c*c*s*xz**3
      pyy = -3.*xz**3*(c**3-2.*c*s**2)
      pz = 3.*z*z*xc**3
      pzz = 6.*z*xc**3
      pxy = -9.*x**2*c*c*s*z**3
      pxz = 9.*xz**2*c**3
      pyz = -9.*c*c*s*x**3*z**2
      return
      end

      subroutine cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
c
c     set noncross derivative pde coefficients
c
      implicit none
      real x,y,z,cxx,cyy,czz,cx,cy,cz,ce,s
      s = sin(y)
      cxx = 1.+0.5*s*z
      cyy = 1.+x*z
      czz = 1.+0.5*x*s
      cx = 0.0
      cy = -x*z
      cz = 0.0
      ce = -(x+z)
      return
      end

      subroutine cxyf(x,y,z,cxy)
c
c     set x-y cross term coefficient at (x,y,z)
c
      implicit none
      real x,y,z,cxx,cyy,czz,cx,cy,cz,ce,cxy
      call cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
      cxy = sqrt(cxx*cyy)
      return
      end

      subroutine cxzf(x,y,z,cxz)
c
c     this is a dummy subroutine since cxz=0.0 for all (x,y,z)
c
      return
      end

      subroutine cyzf(x,y,z,cyz)
c
c     set y-z cross term coefficient at (x,y,z)
c
      implicit none
      real x,y,z,cxx,cyy,czz,cx,cy,cz,ce,cyz
      call cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
      cyz = sqrt(cyy*czz)
      return
      end

      subroutine bd3cr(kbdy,xory,yorz,a,b,c,g)
c
c     pass mixed derivative boundary conditions to mud3cr
c
      implicit none
      integer kbdy
      real xory,yorz,a,b,c,g,x,y,z
      real pe,px,py,pz,pxx,pyy,pzz,pxy,pxz,pyz
      if (kbdy.eq.2) then
c
c     upper x boundary (mixed oblique)
c
	x = 1.0
	y = xory
	z = yorz
	a = (z*(1.-z))
	b = sin(y)*cos(y)
	c = -1.0
	call exact(x,y,z,pe,px,py,pz,pxx,pyy,pzz,pxy,pxz,pyz)
	g = px + a*py + b*pz + c*pe
	return
      else if (kbdy.eq.6) then
c
c     upper z boundary (mixed normal)
c
	z = 1.0
	x = xory
	y = yorz
	a = 0.0
	b = 0.0
	c = x*sin(y)**2
	call exact(x,y,z,pe,px,py,pz,pxx,pyy,pzz,pxy,pxz,pyz)
	g = pz + a*px + b*py + c*pe
	return
      end if
      end

</PRE>
<HR>
 
<a name="tmud3sa.txt"><b>TMUD3SA</b></a>
<PRE>
c
c     file tmud3sa.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver mud3sa
c
c ... required MUDPACK files
c
c     mud3sa.f, mudcom.f, mud3ln.f, mud3pn.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for mud3sa
c
c **********************************************************
c **********************************************************
c
c
c
c     a sample program/test driver for mud3sa is below. it can be
c     executed as an initial test.  the output is listed for the
c     the test case described.
c
c     solve the following helmholtz equation (divergence form) in
c     spherical coordinates.
c
c          div(grad(u(r,t,p)) - u(r,t,p) = f(r,t,p)  (original pde)
c
c     after multiplying the left and right hand sides by r*r*sin(t) this
c     becomes
c
c          r*r*sin(t)*div(grad(u(r,t,p)) - r*r*sin(t)*u(r,t,p)
c
c          = r*r*sin(t)*f(r,t,p)
c
c     or (expanded form)
c
c
c          d(r*r*sin(t)*du/dr)/dr + d(sin(t)*du/dt)/dt + d(1/sin(t)*du/dp)/dp
c
c          - r*r*sin(t)*u(r,t,p)  =  r*r*sin(t)*f(r,t,p).
c
c
c     this form is suitable for using mud3sa.  the solution region is:
c
c          (pi = 4.*atan(1.0) radians)
c
c          0.5  <  r  <  1.0       r is the "radius" coordinate
c
c          pi/4  <  t  <  3*pi/4   t is the colatitude coordinate
c
c          0  <  p  <  pi+pi       p is the longitude coordinate
c
c     asssume the solution is specified at the r,t boundaries and is periodic
c     in p.  use line relaxation in the r direction and choose a solution
c     grid as close to 50 x 30 x 60 as the mudpack size constraints allow.
c     the exact solution
c
c          u(r,t,p) = (r*sin(t)*sin(p)*r*sin(t)*cos(p)*r*cos(t))**2
c
c                   = (x*y*z)**2   (in cartesian coordinates)
c
c     is used for testing purposes. one full multigrid cycle (no initial
c     guess) with the default multigrid options is executed.  error control
c     is not used.
c
c ******************************************************
c     output (32 bit floating point arithmetic
c *******************************************************
c
c     mud3sa test
c
c     input arguments
c     intl =  0 nra =  1 nrb =  1 ntc =  1 ntd =  1
c     npe =  0 npf =  0
c     irp =  3 jtq =  2 kpr =  2
c     ier =  5 jet =  5 kep =  6
c     nr =  49 nt =  33 np =  65 iguess =  0 maxcy =  1
c     method =  1 work space length input = 1598164
c     ra =  0.50 rb =  1.00
c     tc =  0.79 td =  2.36
c     pe =  0.00 pf =  6.28
c     tolmax =  0.000E+00
c
c     multigrid options
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     discretization call to mud3sa intl =  0
c     ierror =  0 minimum work space = 1598164
c
c     approximation call to mud3sa
c     intl =  1 method =  1 iguess =  0 maxcy =  1
c     ierror =  0
c     maximum error  =   0.369E-03
c
c ************************************************************
c     end of output
c ************************************************************
c
      program tmud3sa
      implicit none
c
c     set grid sizes with parameter statements
c
      integer iirp,jjtq,kkpr,iier,jjet,kkep,nnr,nnt,nnp
      integer irp,jtq,kpr,ier,jet,kep,nr,nt,np
      parameter(iirp=3, jjtq=2, kkpr=2, iier=5, jjet=5, kkep=6)
      parameter (nnr = iirp*2**(iier-1)+1)
      parameter (nnt = jjtq*2**(jjet-1)+1)
      parameter (nnp = kkpr*2**(kkep-1)+1)
c
c     set predetermined minimum work space required
c
      integer llwork
      parameter (llwork = 1598164)
c
c     dimension solution,right hand side, and work arrays
c
      real uso(nnr,nnt,nnp),rhs(nnr,nnt,nnp),work(llwork)
c
c     put integer and floating point parameter names in contiguous
c     storeage for labelling in equivalenced vectors iprm,fprm
c
      real fprm(8)
      integer iprm(23),mgopt(5)
      integer intl,nra,nrb,ntc,ntd,npe,npf,irp,jtq,kpr,ier,jet,
     +              kep,nr,nt,np,iguess,maxcy,method,method2,nwork,
     +              lwrkqd,itero
      common/itmud3/intl,nra,nrb,ntc,ntd,npe,npf,irp,jtq,kpr,ier,jet,
     +              kep,nr,nt,np,iguess,maxcy,method,method2,nwork,
     +              lwrkqd,itero
      real ra,rb,tc,td,pe,pf,tolmax,relmax
      common/ftmud3/ra,rb,tc,td,pe,pf,tolmax,relmax
      real sinat,cosat,sinap,cosap,dlr,dlt,dlp
      integer i,j,k,ierror
      real urr,utt,upp,ur,ut,up,ue,r,r6,t,p,pi
      real st,ct,sp,cp,ep,et,ep,sint,cost,errm
c
c     vectors for saving sin,cos on lat-long points
c
      common/sincos/sinat(33),cosat(33),sinap(65),cosap(65),dlr,dlt,dlp
      equivalence(intl,iprm)
      equivalence(ra,fprm)
c
c     declare coefficient input functions external
c
      real lam
      external sigr,sigt,sigp,bndc,lam
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nra = 1
      nrb = 1
      ntc = 1
      ntd = 1
      npe = 0
      npf = 0
c
c     set grid sizes from arguments statements
c
      irp = iirp
      jtq = jjtq
      kpr = kkpr
      ier = iier
      jet = jjet
      kep = kkep
      nr = nnr
      nt = nnt
      np = nnp
c
c     set one cycle limit
c
      maxcy = 1
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set line relaxation in the r direction
c
      method = 1
      method2 = 0
c
c     flag no initial guess which forces full multigrid cycling
c
      iguess = 0
c
c     set ends of solution "cube" in (r,t,p) space  (actually the sphere)
c
      pi = 4.*atan(1.)
      ra = 0.5
      rb = 1.0
      tc = 0.25*pi
      td = 0.75*pi
      pe = 0.0
      pf = pi+pi
c
c     set mesh increments
c
      dlr = (rb-ra)/float(nr-1)
      dlt = (td-tc)/float(nt-1)
      dlp = (pf-pe)/float(np-1)
c
c     preset sin,cos on lat-long grid to save computation
c
      do k=1,np
	p = pe +(k-1)*dlp
	sinap(k) = sin(p)
	cosap(k) = cos(p)
      end do
      do j=1,nt
	t = tc+(j-1)*dlt
	sinat(j) = sin(t)
	cosat(j) = cos(t)
      end do
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in rhs and initialize solution to zero
c
      do j=1,nt
	t = tc+(j-1)*dlt
	sint = sinat(j)
	cost = cosat(j)
	do k=1,np
	  p = pe+(k-1)*dlp
	  do i=1,nr
	    r = ra+float(i-1)*dlr
	    call exact(r,t,p,urr,utt,upp,ur,ut,up,ue)
	    rhs(i,j,k) = r*sint*(r*urr+2.*ur)+sint*utt+cost*ut+upp/sint
     +                 - lam(r,t,p)*ue
	    uso(i,j,k) = 0.0
	  end do
	end do
      end do
c
c     set specified values in uso at r and t boundaries
c
c     r = ra
      r6 = ra**6
      do k=1,np
	sp = sinap(k)
	cp = cosap(k)
	ep = (sp*cp)**2
	do j=1,nt
	  st = sinat(j)
	  ct = cosat(j)
	  et = st*st*(st*ct)**2
	  uso(1,j,k) = r6*et*ep
	end do
      end do
c
c     r = rb
      r6 = rb**6
      do k=1,np
	sp = sinap(k)
	cp = cosap(k)
	ep = (sp*cp)**2
	do j=1,nt
	  st = sinat(j)
	  ct = cosat(j)
	  et = st*st*(st*ct)**2
	  uso(nr,j,k) = r6*et*ep
	end do
      end do

c     t = tc
      st = sinat(1)
      ct = cosat(1)
      et = st*st*(st*ct)**2
      do k=1,np
	sp = sinap(k)
	cp = cosap(k)
	ep = (cp*sp)**2
	do i=1,nr
	  r6 = (ra+float(i-1)*dlr)**6
	  uso(i,1,k) = r6*et*ep
	end do
      end do

c     t = td
      st = sinat(nt)
      ct = cosat(nt)
      et = st*st*(st*ct)**2
      do k=1,np
	sp = sinap(k)
	cp = cosap(k)
	ep = (cp*sp)**2
	do i=1,nr
	  r6 = (ra+float(i-1)*dlr)**6
	  uso(i,nt,k) = r6*et*ep
	end do
      end do
c
c     set default multigrid options
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     write input arguments
c
      write(*,50)
   50 format(//' mud3sa test')
      write(*,100)intl,nra,nrb,ntc,ntd,npe,npf,irp,jtq,kpr,ier,jet,kep,
     +            nr,nt,np,iguess,maxcy,method,nwork,ra,rb,tc,td,pe,pf,
     +            tolmax,mgopt(1),mgopt(2),mgopt(3),mgopt(4)
  100 format(/' input arguments',
     +/' intl = ',i2,' nra = ',i2,' nrb = ',i2,' ntc = ',i2,' ntd = 'i2,
     +/' npe = ',i2, ' npf = ',i2,
     +/' irp = ',i2,' jtq = 'i2,' kpr = ',i2,
     +/' ier = ',i2, ' jet = 'i2, ' kep = 'i2,
     +/' nr = ',i3,' nt = ',i3,' np = ',i3, ' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space length input = ',i7,
     +/' ra = 'f5.2,' rb = 'f5.2,
     +/' tc = 'f5.2,' td = 'f5.2,
     +/' pe = 'f5.2,' pf = 'f5.2,
     +/' tolmax = ' ,e10.3
     +//' multigrid options '
     +/' kcycle = ',i2
     +/' iprer = ',i2
     +/' ipost = ',i2
     +/' intpol = ',i2 )
      write(*,104) intl
  104 format(/' discretization call to mud3sa', ' intl = ', i2)
      call mud3sa(iprm,fprm,work,sigr,sigt,sigp,lam,bndc,rhs,uso,
     +            mgopt,ierror)
      write (*,105) ierror,iprm(22)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to mud3sa ',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call mud3sa(iprm,fprm,work,sigr,sigt,sigp,lam,bndc,rhs,uso,
     +            mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute maximum error
c
      errm = 0.0
      do k=1,np
	sp = sinap(k)
	cp = cosap(k)
	ep = (cp*sp)**2
	do j=1,nt
	  st = sinat(j)
	  ct = cosat(j)
	  et = st*st*(st*ct)**2
	  do i=1,nr
	    r6 = (ra+float(i-1)*dlr)**6
c     exact continuous solution
	    ue = r6*et*ep
	    errm = amax1(errm,abs(uso(i,j,k)-ue))
	  end do
	end do
      end do
      write(*,108) errm
  108 format(' maximum error  =  ',e10.3)
      end

      function sigr(r,t,p)
c
c     coefficient for r derivative (mud3sa will call sigr off grid)
c
      implicit none
      real sigr,r,t,p
      sigr = r*r*sin(t)
      return
      end

      function sigt(r,t,p)
c
c     coefficient for theta derivative (mud3sa will call sigt off grid)
c
      implicit none
      real sigt,r,t,p
      sigt = sin(t)
      return
      end

      function sigp(r,t,p)
c
c     coefficient for phi derivative (mud3sa will call sigp off grid)
c
      implicit none
      real sigp,r,t,p
      sigp = 1.0/sin(t)
      return
      end

      function lam(r,t,p)
c
c     input zero order coefficient in self adjoint pde at (r,t,p) to mud3sa
c     (only grid values needed)
c
      implicit none
      real lam,r,t,p
      integer j
      integer intl,nra,nrb,ntc,ntd,npe,npf,irp,jtq,kpr,ier,jet,
     +              kep,nr,nt,np,iguess,maxcy,method,method2,nwork,
     +              lwrkqd,itero
      common/itmud3/intl,nra,nrb,ntc,ntd,npe,npf,irp,jtq,kpr,ier,jet,
     +              kep,nr,nt,np,iguess,maxcy,method,method2,nwork,
     +              lwrkqd,itero
      real ra,rb,tc,td,pe,pf,tolmax,relmax
      real sinat,cosat,sinap,cosap,dlr,dlt,dlp
      common/ftmud3/ra,rb,tc,td,pe,pf,tolmax,relmax
      common/sincos/sinat(33),cosat(33),sinap(65),cosap(65),dlr,dlt,dlp
      real lam
      j = int((t-tc)/dlt+0.5)+1
      lam = r*r*sinat(j)
      return
      end
c
c
      subroutine bndc(kbdy,rort,torp,alfa,gbdy)
c
c     a dummy routine since there is no mixed derivative b.c. for this problem
c
      return
      end

      subroutine exact(r,t,p,urr,utt,upp,ur,ut,up,ue)
c
c     set exact solution taken from u(x,y,z) = (x*y*z)**2 transformed
c     with spherical coordinates
c
      common/itmud3/intl,nra,nrb,ntc,ntd,npe,npf,irp,jtq,kpr,ier,jet,
     +              kep,nr,nt,np,iguess,maxcy,method,method2,nwork,
     +              lwrkqd,itero
      common/ftmud3/ra,rb,tc,td,pe,pf,tolmax,relmax
      common/sincos/sinat(33),cosat(33),sinap(65),cosap(65),dlr,dlt,dlp
c
c     set subscripts for current lat-lon grid point
c
      j = int((t-tc)/dlt+0.5)+1
      k = int((p-pe)/dlp+0.5)+1
c
c     set sin, cos from pre-computed vectors
c
      st = sinat(j)
      ct = cosat(j)
      sp = sinap(k)
      cp = cosap(k)
c
c     set intermediate quantities
c
      r6 = r**6
      ep = (cp*sp)**2
      dep = 2.*(cp*sp)*(cp*cp-sp*sp)
      ddep = 2.*((cp**2-sp**2)**2-4.*(sp*cp)**2)
      et = st*st*(st*ct)**2
      det = 2.*(2.*(st*ct)**3 -ct*st**5)
      ddet = 12.*(ct*st)**2*(ct**2-st**2)+2.*st**4*(st**2-4.*ct**2)
c
c     set exact values of continuous solution and its partial derivatives
c
      ue = r6*et*ep
      ur = 6.*r**5*et*ep
      urr = 30.*r**4*et*ep
      ut = r6*det*ep
      utt = r6*ddet*ep
      up = r6*et*dep
      upp = r6*et*ddep
      return
      end

</PRE>
<HR>
 
<a name="tmud3sp.txt"><b>TMUD3SP</b></a>
<PRE>
c
c     file tmud3sp.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver mud3sp
c
c ... required MUDPACK files
c
c     mud3sp.f, mudcom.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for mud3sp
c
c **********************************************************
c **********************************************************
c
c     a sample program/test driver for mud3sp is below. it can be
c     executed as an initial test.  the output is listed for the
c     test case described.
c
c     test the driver below by solving the separable elliptic pde
c
c        d(x**2*dp/dx)/dx + d(y**2*dp/dy)/dy + d(z**2*dp/dz)/dz
c
c        - (x+y+z)*pe(x,y,z) = r(x,y,z)
c
c
c     on the cube [0.5,1.0]**3 with specified boundary conditions at x,y,z=1.0
c     and derivative boundary conditions of the form
c
c        dp/dx - pe(0.5,y,z) = f(0.5,y,z) at x = 0.5
c
c        dp/dy - pe(x,0.5,z) = g(x,0.5,z) at y = 0.5
c
c        dp/dz - pe(x,y,0.5) = h(x,y,0.5) at z = 0.5
c
c     generate the approximation on a  65 x 49 x 41 grid using the exact
c     solution
c
c          pe(x,y,z) = (x*y*z)**4
c
c     for testing.  notice the solver mud3 would require far more work space
c     than mud3sp if used to solve this pde.
c
c ******************************************************
c     output (32 bit floating point arithmetic)
c *******************************************************
c
c     mud3sp test
c
c     input arguments
c     intl =  0 nxa =  2 nxb =  1 nyc =  2 nyd =  1
c     nze =  2 nzf =  1
c     ixp =  2 jyq =  3 kzr =  5
c     iex =  6 jey =  5 kez =  4
c     nx =  65 ny =  49 nz =  41 iguess =  0 maxcy =  3
c     method =  0 work space length input =  514258
c     xa =  0.50 xb =  1.00
c     yc =  0.50 yd =  1.00
c     ze =  0.50 zf =  1.00
c     tolmax =  0.000E+00
c
c     multigrid options
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  1
c
c     discretization call to mud3sp intl =  0
c     ierror =  0 minimum work space =  472557
c
c     approximation call to mud3sp
c     intl =  1 method =  0 iguess =  0 maxcy =  3
c     ierror =  0
c     maximum error  =   0.719E-05
c
c ************************************************************
c     end of output
c ************************************************************
c
c
      program tmud3sp
c
c     set grid sizes with parameter statements
c
      implicit none
c
c     set grid sizes with parameter statements
c
      integer iixp,jjyq,kkzr,iiex,jjey,kkez,llwork,nnx,nny,nnz
      parameter(iixp=2,jjyq=3,kkzr=5)
      parameter(iiex=6,jjey=5,kkez=4)
      parameter (nnx = iixp*2**(iiex-1)+1)
      parameter (nny = jjyq*2**(jjey-1)+1)
      parameter (nnz = kkzr*2**(kkez-1)+1)
c
c     set work space length approximation (see mud3sp.d)
c
      parameter(llwork = 7*(nnx+2)*(nny+2)*(nnz+2)/2 )
c
c
c     dimension solution,right hand side, and work arrays
c
      real phi(nnx,nny,nnz),rhs(nnx,nny,nnz),work(llwork)
      integer iprm(22),mgopt(4)
      real fprm(8)
c
c     put integer and floating point arguments names in contiguous
c     storeage for labelling
c
      integer intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,nwork,lwrkqd,itero
      common/itmsp3/intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmsp3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real dlx,dly,dlz,x,y,z,cxx,cyy,czz,cx,cy,cz,cex,cey,cez,ce,errm
      real pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k,ierror
      equivalence(intl,iprm)
      equivalence(xa,fprm)
c
c     declare coefficient and boundary condition input subroutines external
c
      external cfx,cfy,cfz,bndc
c
c
c     set input integer parameters
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 2
      nxb = 1
      nyc = 2
      nyd = 1
      nze = 2
      nzf = 1

c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      kzr = kkzr
      iex = iiex
      jey = jjey
      kez = kkez
      nx = nnx
      ny = nny
      nz = nnz
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set method of relaxation--point gauss/seidel only for mud3sp
c
      method = 0
c
c     set default multigrid options
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set full multigrid cycling by flagging no initial guess
c
      iguess = 0
c
c     set a limit of three w(2,1) cycles from the finest level
c
      maxcy = 3
c
c     set end points of solution cube in (x,y,z) space
c
      xa = 0.5
      xb = 1.0
      yc = 0.5
      yd = 1.0
      ze = 0.5
      zf = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
      dlz = (zf-ze)/float(nz-1)
c
c     set for no error control (this allows phi to be equivlaenced with work)
c
      tolmax = 0.0
c
c     set right hand side in rhs using exact solution
c     and initialize phi to zero
c
      do k=1,nz
	z = ze+(k-1)*dlz
	call cfz(z,czz,cz,cez)
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cfy(y,cyy,cy,cey)
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call cfx(x,cxx,cx,cex)
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    ce = cex+cey+cez
	    rhs(i,j,k) = cxx*pxx+cyy*pyy+czz*pzz+cx*px+cy*py+cz*pz+ce*pe
	    phi(i,j,k) = 0.0
	  end do
	end do
      end do
c
c     set specified values at upper boundaries
c
      x = xb
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(nx,j,k) = pe
	end do
      end do
      y = yd
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,ny,k) = pe
	end do
      end do
      z = zf
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,j,nz) = pe
	end do
      end do
      write(6,50)
   50 format(//' mud3sp test ')
c
c     print input arguments
c
      write(6,100)intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,kez,
     +            nx,ny,nz,iguess,maxcy,method,nwork,xa,xb,yc,yd,ze,zf,
     +            tolmax,mgopt(1),mgopt(2),mgopt(3),mgopt(4)
  100 format(/' input arguments ',
     +/' intl = ',i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = 'i2,
     +/' nze = ',i2, ' nzf = ',i2,
     +/' ixp = ',i2,' jyq = 'i2,' kzr = 'i2,
     +/' iex = ',i2, ' jey = 'i2, ' kez = 'i2,
     +/' nx = 'i3,' ny = 'i3,' nz = 'i3, ' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space length input = ',i7,
     +/' xa = 'f5.2,' xb = 'f5.2,
     +/' yc = 'f5.2,' yd = 'f5.2,
     +/' ze = 'f5.2,' zf = 'f5.2,
     +/' tolmax = ' ,e10.3
     +//' multigrid options '
     +/' kcycle = ',i2
     +/' iprer = ',i2
     +/' ipost = ',i2
     +/' intpol = ',i2 )
c
c     discretize pde
c
      write(*,104) intl
  104 format(/' discretization call to mud3sp', ' intl = ', i2)
      call mud3sp(iprm,fprm,work,cfx,cfy,cfz,bndc,rhs,phi,mgopt,ierror)
      write (*,105) ierror,iprm(21)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     approximate pde
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to mud3sp ',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call mud3sp(iprm,fprm,work,cfx,cfy,cfz,bndc,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum error
c
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
  108 format(' maximum error  =  ',e10.3)
      end

      subroutine error(nx,ny,nz,phi,errm)
c
c     compute the error in the estimate in phi
c
      implicit none
      integer nx,ny,nz
      real phi(nx,ny,nz),errm
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmsp3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real dlx,dly,dlz,x,y,z,pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k
      dlx = (xb-xa)/(nx-1)
      dly = (yd-yc)/(ny-1)
      dlz = (zf-ze)/(nz-1)
      errm = 0.0
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    errm = amax1(errm,abs(phi(i,j,k)-pe))
	  end do
	end do
      end do
      return
      end
c
c     coefficient subroutines
c
      subroutine cfx(x,cxx,cx,cex)
      implicit none
      real x,cxx,cx,cex
      cxx = x*x
      cx = x+x
      cex = -x
      return
      end

      subroutine cfy(y,cyy,cy,cey)
      implicit none
      real y,cyy,cy,cey
      cyy = y*y
      cy = y+y
      cey = -y
      return
      end

      subroutine cfz(z,czz,cz,cez)
      implicit none
      real z,czz,cz,cez
      czz = z*z
      cz = z+z
      cez = -z
      return
      end

      subroutine bndc(kbdy,xory,yorz,cons,gbdy)
c
c     input derivative boundary conditions to mud3sp
c     at lower x,y,z boundaries
c
      implicit none
      integer kbdy
      real xory,yorz,cons,gbdy,x,y,z,pxx,pyy,pzz,px,py,pz,pe
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmsp3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      if (kbdy.eq.1) then
c
c     x=xa surface
c
	x = xa
	y = xory
	z = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	cons = -1.0
	gbdy = px+cons*pe
	return
      end if
      if (kbdy.eq.3) then
c
c     y=yc surface
c
	y = yc
	x = xory
	z = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	cons = -1.0
	gbdy = py+cons*pe
	return
      end if
      if (kbdy.eq.5) then
c
c     z=ze surface
c
	z = ze
	x = xory
	y = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	cons = -1.0
	gbdy = pz + cons*pe
	return
      end if
      end

      subroutine exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
c
c     this subroutine is used to set an exact solution for testing mud3sp
c     (i.e., setting the rhs, boundary conditions and computing the exact
c     error)
c
      implicit none
      real x,y,z,pxx,pyy,pzz,px,py,pz,pe
      pe = (x*y*z)**4
      px = 4.*(x*y*z)**3*y*z
      py = 4.*(x*y*z)**3*x*z
      pz = 4.*(x*y*z)**3*x*y
      pxx = 12.*(x*y*z)**2*(y*z)**2
      pyy = 12.*(x*y*z)**2*(x*z)**2
      pzz = 12.*(x*y*z)**2*(x*y)**2
      return
      end
</PRE>
<HR>
 
<a name="tmuh2.txt"><b>TMUH2</b></a>
<PRE>
c
c     file tmuh2.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver muh2
c
c ... required MUDPACK files
c
c     muh2.f, mudcom.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for muh2
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for muh2 is below. it can be
c     executed as an initial test.  Output is listed for the test
c     case described.  This example illustrates the added grid
c     size flexibility provided by muh2.
c
c     test the hybrid multigrid/direct method solver muh2 by approximating
c     the solution to the nonseparable elliptic pde in divergence form on
c     the 2.5 degree grid on the full surface of a sphere of radius one.
c
c          div(sigma(t,p)*grad(u(t,p))) - lambda(t,p)*u(t,p) = f(t,p)
c
c     t and p are colatitude and longitude in radians.  expanding
c     the pde and multiplying thru by sin(t) puts it in the following
c     form suitable for muh2:
c
c          ctt * utt + cpp*upp + ct*ut + cp *up + ce * u = r(t,p)
c
c     the coefficients are given by
c
c          ctt(t,p) = sin(t)*sigma(t,p)
c
c          cpp(t,p) = (1/sin(t))*sigma(t,p)
c
c          ct(t,p)  = sin(t)*d(sigma)/dt + cos(t)*sigma(t,p)
c
c          cp(t,p)  = (1/sin(t))*d(sigma)/dp
c
c          ce(t,p)  = - sin(t)*lambda(t,p)
c
c          r(t,p)   = sin(t)* f(t,p)
c
c     for testing use the coefficients and exact solution:
c
c          sigma(t,p) = 1.5 + (sin(t)*cos(p))**2
c
c          lambda(t,p) = - sigma(t,p)
c
c          u(t,p) =  [sin(t)*(sin(t)*cos(t)*sin(p)*cos(p))]**2
c
c     (the exact solution is the restriction of the solution u(x,y,z) =
c     (x*y*z)**2 in cartesian coordinates to the surface of the sphere
c     in spherical coordinates).  assume the solution u(t,p) is specified
c     at the poles and is periodic in longitude.  choosing the grid size
c     parameters:
c
c          itp = iparm(6) = 9, jpq = iparm(7) = 9
c
c          iet = iparm(8) = 4,  jep = iparm(9) = 5
c
c     fits the required five degree 73 by 145 grid exactly.  the 10 x 10
c     coarsest grid is too large for effective error reduction with multgrid
c     iteration using relaxation only (see tmud2sa.f).  the subgrid sizes
c     in the coarsening muh2 uses are:
c
c          73 X 145 > 37 X 73 > 19 X 37 > 10 X 19 > 10 X 10
c
c     The solvers mud2 or mud2sa would not be efficient for this coarsening.
c     Guassian elimination is used whenever the coarsest 10 X 10 subgrid
c     is encountered within multigrid iteration and line relaxation in
c     the phi direction is used at the higher resolution grids.  the
c     default multigrid options are used. one full multigrid cycle with
c     no initial guess is executed.  discretization level error is reached.
c
c
c ************************************************************
c     output (32 bit floating point arithmetic)
c ***********************************************************
c
c     muh2 test
c
c     integer input parameters
c     intl =  0 nta =  1 ntb =  1 npc =  0 npd =  0
c     itp =  9 jpq =  9 iet =  4 jep =  5
c     nt =  73 np = 145 iguess =  0 maxcy =  1
c     method =  2 work space estimate =  214396
c
c     multigrid option parameters
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     ta =  0.000 tb =  3.142 pc =  0.000 pd =  6.283
c     tolerance (error control) =   0.000E+00
c
c     discretization call to muh2  intl =  0
c     ierror =  0 minimum work space =  186661
c
c     approximation call to muh2
c     intl =  1 method =  2 iguess =  0 maxcy =  1
c     tolmax =  0.00
c     ierror =  0
c     maximum error  =  0.795E-04
c
c ************************************************************
c
      program tmuh2
      implicit none
      integer iitp,jjpq,iiet,jjep,nnt,nnp,llwrk,lldir,llwork
      integer iitp1,jjpq1
c
c     set grid size with parameter statements
c
      parameter (iitp = 9, jjpq =  9, iiet = 4, jjep = 5)
      parameter (iitp1 = iitp+1, jjpq1 = jjpq+1)
      parameter ( nnt = iitp*2**(iiet-1) + 1)
      parameter ( nnp = jjpq*2**(jjep-1) + 1)
c
c     set work space estimate (see muh2.d)
c
      parameter (llwrk=4*(15*nnt*nnp+8*(nnt+nnp+2))/3 )
      parameter(lldir=(2*(iitp+1)*(2*jjpq-1)+jjpq+1))
      parameter (llwork = llwrk+lldir)
c
c     dimension solution,right hand side, and work arrays
c
      real u(nnt,nnp),r(nnt,nnp),w(llwork)
      integer iw(iitp1,jjpq1)
c
c     dimension input argument vectors and set up continguous storage
c     for labelling entries
c
      integer iparm(17),mgopt(4)
      real fparm(6)
      integer intl,nta,ntb,npc,npd,itp,jpq,iet,jep,nt,np,
     +                iguess,maxcy,method,nwork,lwork,iter
      common / iprm / intl,nta,ntb,npc,npd,itp,jpq,iet,jep,nt,np,
     +                iguess,maxcy,method,nwork,lwork,iter
      real ta,tb,pc,pd,tolmax,sinat,cosat,sinap,cosap,dlt,dlp
      common / fprm / ta,tb,pc,pd,tolmax,sinat(73),cosat(73),
     +                sinap(145),cosap(145),dlt,dlp
      integer i,j,ierror
      real pi,sint,cost,sinp,cosp
      real ctt,cpp,ct,cp,ce,tmp,dt,dp,dtt,dpp,ue,ut,up,utt,upp
      real errm,p,t
c
c     equivlance iparm,fparm with labelled commons iprm,fprm
c
      equivalence (intl,iparm)
      equivalence (ta,fparm)
c
c     declare coefficient and boundary condition input subroutines external
c
      external cof,bndc
c
c     set input integer parameters
c
c     initialization
c
      intl = 0
c
c     set boundary condition flags: poles specified, longitude periodic
c
      nta = 1
      ntb = 1
      npc = 0
      npd = 0
c
c     set grid sizes from parameter statements
c
      itp = iitp
      jpq = jjpq
      iet = iiet
      jep = jjep
      nt = nnt
      np = nnp
c
c     full multigrid cycling (no initial guess at finest grid)
c
      iguess = 0
c
c     set one multigrid cycle
c
      maxcy = 1
c
c     set line relaxation in the longitude direction
c
      method = 2
c
c     set work space estimate
c
      nwork = llwork
c
c     set multigrid parameters (w(2,1) cycling with fully weighted
c     residual restriction and cubic prolongation).  this can also
c     be set by inputting mgopt(1) = 0 to muh2
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set floating point input parameters
c
      pi = 4.0*atan(1.0)
c
c     interval end points (in radians)
c
      ta = 0.0
      tb = pi
      pc = 0.
      pd = pi+pi
c
c     no error control
c
      tolmax = 0.0
c
c     set mesh increments
c
      dlt = (tb-ta)/float(nt-1)
      dlp = (pd-pc)/float(np-1)
c
c     preset sin,cos vectors to save computation on grid points
c
      do i=1,nt
	t = ta+(i-1)*dlt
	sinat(i) = sin(t)
	cosat(i) = cos(t)
      end do
      do j=1,np
	p = pc+(j-1)*dlp
	sinap(j) = sin(p)
	cosap(j) = cos(p)
      end do
c
c     initialize right hand side and solution array except at poles
c
      do i=2,nt-1
	t = ta+(i-1)*dlt
	sint = sinat(i)
	cost = cosat(i)
	do j=1,np
	  p = pc+(j-1)*dlp
	  call cof(t,p,ctt,cpp,ct,cp,ce)
c
c         set intermediate variables for exact solution
c
	  sinp = sinap(j)
	  cosp = cosap(j)
	  tmp = (sint*cosp*sint*sinp*cost)
	  dt = (2.*sint*cost*cost-sint**3)*(cosp*sinp)
	  dp = (cosp**2-sinp**2)*(sint**2*cost)
	  dtt = (2.*cost**3-4.*cost*sint**2-3.*sint**2*cost)*(cosp*sinp)
	  dpp = (-4.*cosp*sinp)*(sint**2*cost)
c
c         set continuous solution and partial derivatives
c
	  ue = tmp*tmp
	  ut = 2.*tmp*dt
	  up = 2.*tmp*dp
	  utt = 2.*(dt*dt+tmp*dtt)
	  upp = 2.*(dp*dp+tmp*dpp)
c
c         set right hand side of continuous pde on grid
c
	  r(i,j) = ctt*utt+cpp*upp+ct*ut+cp*up+ce*ue
c
c         initialize solution array to zero
c
	  u(i,j) = 0.0
	end do
      end do
c
c     set u, r(unused) at poles
c
      do j=1,np
	u(1,j) = 0.0
	r(1,j) = 0.0
	u(nt,j) = 0.0
	r(nt,j) = 0.0
      end do
c
c     print input parameters
c
      write(*,100)
  100 format(//' muh2 test' )

      write (*,101) (iparm(i),i=1,15)
  101 format(/' integer input parameters ',
     +/' intl = ',i2,' nta = ',i2,' ntb = ',i2,' npc = ',i2,' npd = 'i2,
     +/' itp = ',i2,' jpq = 'i2,' iet = ',i2,' jep = ',i2
     +/' nt = 'i3,' np = 'i3,' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space estimate = ',i7)

      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option parameters ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)

      write(*,103) (fparm(i),i=1,5)
  103 format(/' floating point input parameters ',
     +/' ta = 'f6.3,' tb = 'f6.3,' pc = 'f6.3,' pd = 'f6.3,
     +/' tolerance (error control) =  ' ,e10.3)
c
c     discretization call to muh2
c
      write(*,104) intl
  104 format(/' discretization call to muh2 ', ' intl = ',i2)
      call muh2(iparm,fparm,w,iw,cof,bndc,r,u,mgopt,ierror)
      write (*,105) ierror,iparm(16)
  105 format(' ierror = 'i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     aprroximation call to muh2
c
      intl = 1
      write(*,106) intl, method, iguess, maxcy, tolmax
  106 format(/' approximation call to muh2 ',
     +/' intl = ',i2, ' method = ',i2 , ' iguess = ',i2, ' maxcy = ',i2
     +/' tolmax = ',f5.2)
      call muh2(iparm,fparm,w,iw,cof,bndc,r,u,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = 'i2 )
      if (ierror.gt.0) call exit(0)
      if (ierror .le. 0) then
c
c     compute and print exact maximum error
c
      errm = 0.0
      do j=1,np
	sinp = sinap(j)
	cosp = cosap(j)
	do i=1,nt
	  sint = sinat(i)
	  cost = cosat(i)
	  ue = (sint*cosp*sint*sinp*cost)**2
	  errm = amax1(errm,abs((u(i,j)-ue)))
	end do
      end do
      write(*,108) errm
  108 format(' maximum error  = ',e10.3 )
      end if
      end

      subroutine cof(t,p,ctt,cpp,ct,cp,ce)
c
c     coefficient subroutine
c
      implicit none
      real t,p,ctt,cpp,ct,cp,ce
      integer intl,nta,ntb,npc,npd,itp,jpq,iet,jep,nt,np,
     +                iguess,maxcy,method,nwork,lwork,iter
      real ta,tb,pc,pd,tolmax,sinat,cosat,sinap,cosap,dlt,dlp
      common / iprm / intl,nta,ntb,npc,npd,itp,jpq,iet,jep,nt,np,
     +                iguess,maxcy,method,nwork,lwork,iter
      common / fprm / ta,tb,pc,pd,tolmax,sinat(73),cosat(73),
     +                sinap(145),cosap(145),dlt,dlp
      integer i,j
      real sinp,cosp,sint,cost,sigma,dsigdt,dsigdp
c
c     set subscripts for current grid point (t,p)
c
      i = int((t-ta)/dlt+0.5)+1
      j = int((p-pc)/dlp+0.5)+1
c
c     avoid poles where solution is specified and coefficients are not used
c
      if (i.gt. 1 .and. i.lt. nt) then
c
c     set sin,cos at (t,p) from precomputed vectors
c
      sinp = sinap(j)
      cosp = cosap(j)
      sint = sinat(i)
      cost = cosat(i)
c
c     set sigma and its t,p derivatives
c
      sigma = 1.5 + (sint*cosp)**2
      dsigdt = 2.0*cosp*cosp*sint*cost
      dsigdp = -2.0*sint*sint*cosp*sinp
c
c     set coefficients
c
      ctt = sint*sigma
      cpp = sigma/sint
      ct = sint*dsigdt + cost*sigma
      cp = dsigdp/sint
      ce = -sint*sigma
      return
      else
c
c     set unused coefs at poles arbitrarily
c
      ctt = 1.0
      cpp = 1.0
      ct = 0.0
      cp = 0.0
      ce = 0.0
      return
      end if
      end

      subroutine bndc(kbdy,torp,alfa,gbdy)
c
c     this subroutine must be provided as a dummy argument even though
c     there are no mixed derivative b.c.
c
      return
      end

      subroutine exact(t,p,utt,upp,ut,up,ue)
c
c     the exact solution used is the restriction of u(x,y,z) = (x*y*z)**2
c     in cartesian coordinates to the surface of the sphere of radius one
c     using the standard spherical coordinate transforms
c
      common / fprm / ta,tb,pc,pd,tolmax,sinat(73),cosat(73),
     +                sinap(145),cosap(145),dlt,dlp
c
c     set subscripts for current grid point (t,p)
c
      i = int((t-ta)/dlt+0.5)+1
      j = int((p-pc)/dlp+0.5)+1
c
c     set sin,cos from precomputed vectors
c
      sinp = sinap(j)
      cosp = cosap(j)
      sint = sinat(i)
      cost = cosat(i)
c
c     set intermediate variables
c
      tmp = (sint*cosp*sint*sinp*cost)
      dt = (2.*sint*cost*cost-sint**3)*(cosp*sinp)
      dp = (cosp**2-sinp**2)*(sint**2*cost)
      dtt = (2.*cost**3-4.*cost*sint**2-3.*sint**2*cost)*(cosp*sinp)
      dpp = (-4.*cosp*sinp)*(sint**2*cost)
c
c     set solution and partial derivatives
c
      ue = tmp*tmp
      ut = 2.*tmp*dt
      up = 2.*tmp*dp
      utt = 2.*(dt*dt+tmp*dtt)
      upp = 2.*(dp*dp+tmp*dpp)
      return
      end

</PRE>
<HR>
 
<a name="tmuh24.txt"><b>TMUH24</b></a>
<PRE>
c
c     file tmuh24.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver muh24
c
c ... required MUDPACK files
c
c     muh24.f, muh2.f, mudcom.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for muh24
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for muh24 is below. it can be
c     executed as an initial test.  Output is listed for the test
c     case described.  This example illustrates the added grid
c     size flexibility provided by muh2 and muh24.
c
c     test the hybrid multigrid/direct method solver muh24 by approximating
c     the solution to the nonseparable elliptic pde in divergence form on
c     the 2.5 degree grid on the full surface of a sphere of radius one.
c
c          div(sigma(t,p)*grad(u(t,p))) - lambda(t,p)*u(t,p) = f(t,p)
c
c     t and p are colatitude and longitude in radians.  expanding
c     the pde and multiplying thru by sin(t) puts it in the following
c     form suitable for muh2:
c
c          ctt * utt + cpp*upp + ct*ut + cp *up + ce * u = r(t,p)
c
c     the coefficients are given by
c
c          ctt(t,p) = sin(t)*sigma(t,p)
c
c          cpp(t,p) = (1/sin(t))*sigma(t,p)
c
c          ct(t,p)  = sin(t)*d(sigma)/dt + cos(t)*sigma(t,p)
c
c          cp(t,p)  = (1/sin(t))*d(sigma)/dp
c
c          ce(t,p)  = - sin(t)*lambda(t,p)
c
c          r(t,p)   = sin(t)* f(t,p)
c
c     for testing use the coefficients and exact solution:
c
c          sigma(t,p) = 1.5 + (sin(t)*cos(p))**2
c
c          lambda(t,p) = - sigma(t,p)
c
c          u(t,p) =  [sin(t)*(sin(t)*cos(t)*sin(p)*cos(p))]**2
c
c     (the exact solution is the restriction of the solution u(x,y,z) =
c     (x*y*z)**2 in cartesian coordinates to the surface of the sphere
c     in spherical coordinates).  assume the solution u(t,p) is specified
c     at the poles and is periodic in longitude.  choosing the grid size
c     parameters:
c
c          itp = iparm(6) = 9, jpq = iparm(7) = 9
c
c          iet = iparm(8) = 4,  jep = iparm(9) = 5
c
c     fits the required five degree 73 by 145 grid exactly.  the 10 x 10
c     coarsest grid is too large for effective error reduction with multgrid
c     iteration using relaxation only.  the subgrid sizes in the coarsening
c     muh2 and muh24 uses are:
c
c          73 X 145 > 37 X 73 > 19 X 37 > 10 X 19 > 10 X 10
c
c     Guassian elimination is used whenever the coarsest 10 X 10 subgrid
c     is encountered within multigrid iteration and line relaxation in
c     the phi direction is used at the higher resolution grids.  the
c     default multigrid options are used. one full multigrid cycle with
c     no initial guess is executed with muh2.  then, to ensure a second-
c     order approximation is reached, two more cycles are executed calling
c     muh2 with iguess = 1.  Due to fortuitous error cancellations, the
c     additional cycles actually increase the error measure with the
c     continuous solution but do give a better approximation to the
c     solution of the second-order finite difference equations.  Finally
c     muh24 is called to produce a fourth-order estimate.
c
c ************************************************************
c     output (64 bit floating point arithmetic)
c ***********************************************************
c
c     muh2 test
c
c     integer input parameters
c     intl =  0 nta =  1 ntb =  1 npc =  0 npd =  0
c     itp =  9 jpq =  9 iet =  4 jep =  5
c     nt =  73 np = 145 iguess =  0 maxcy =  1
c     method =  2 work space estimate =  214396
c
c     multigrid option parameters
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     ta =  0.000 tb =  3.142 pc =  0.000 pd =  6.283
c     tolerance (error control) =   0.000E+00
c
c     discretization call to muh2  intl =  0
c     ierror =  0 minimum work space =  186661
c
c     approximation call to muh2
c     intl =  1 method =  2 iguess =  0 maxcy =  1
c     tolmax =  0.00
c     ierror =  0
c     maximum error  =  0.795E-04
c
c     approximation call to muh2
c     intl =  1 method =  2 iguess =  1 maxcy =  2
c     tolmax =  0.00
c     ierror =  0
c     maximum error  =  0.839E-04
c
c     muh24 test  ierror =  0
c     maximum error  =  0.209E-06
c
c ***********************************************************
c
      program tmuh24
      implicit none
      integer iitp,jjpq,iiet,jjep,nnt,nnp,llwrk,lldir,llwork
      integer iitp1,jjpq1
c
c     set grid size with parameter statements
c
      parameter (iitp = 9, jjpq =  9, iiet = 4, jjep = 5)
      parameter (iitp1 = iitp+1, jjpq1 = jjpq+1)
      parameter ( nnt = iitp*2**(iiet-1) + 1)
      parameter ( nnp = jjpq*2**(jjep-1) + 1)
c
c     set work space estimate (see muh2.d)
c
      parameter (llwrk=4*(15*nnt*nnp+8*(nnt+nnp+2))/3 )
      parameter(lldir=(2*(iitp+1)*(2*jjpq-1)+jjpq+1))
      parameter (llwork = llwrk+lldir)
c
c     dimension solution,right hand side, and work arrays
c
      real u(nnt,nnp),r(nnt,nnp),w(llwork)
      integer iw(iitp1,jjpq1)
c
c     dimension input argument vectors and set up continguous storage
c     for labelling entries
c
      integer iparm(17),mgopt(4)
      real fparm(6)
      integer intl,nta,ntb,npc,npd,itp,jpq,iet,jep,nt,np,
     +                iguess,maxcy,method,nwork,lwork,iter
      common / iprm / intl,nta,ntb,npc,npd,itp,jpq,iet,jep,nt,np,
     +                iguess,maxcy,method,nwork,lwork,iter
      real ta,tb,pc,pd,tolmax,sinat,cosat,sinap,cosap,dlt,dlp
      common / fprm / ta,tb,pc,pd,tolmax,sinat(73),cosat(73),
     +                sinap(145),cosap(145),dlt,dlp
      integer i,j,ierror
      real pi,sint,cost,sinp,cosp
      real ctt,cpp,ct,cp,ce,tmp,dt,dp,dtt,dpp,ue,ut,up,utt,upp
      real errm,p,t
c
c     equivlance iparm,fparm with labelled commons iprm,fprm
c
      equivalence (intl,iparm)
      equivalence (ta,fparm)
c
c     declare coefficient and boundary condition input subroutines external
c
      external cof,bndc
c
c     set input integer parameters
c
c     initialization
c
      intl = 0
c
c     set boundary condition flags: poles specified, longitude periodic
c
      nta = 1
      ntb = 1
      npc = 0
      npd = 0
c
c     set grid sizes from parameter statements
c
      itp = iitp
      jpq = jjpq
      iet = iiet
      jep = jjep
      nt = nnt
      np = nnp
c
c     full multigrid cycling (no initial guess at finest grid)
c
      iguess = 0
c
c     set one multigrid cycle
c
      maxcy = 1
c
c     set line relaxation in the longitude direction
c
      method = 2
c
c     set work space estimate
c
      nwork = llwork
c
c     set multigrid parameters (w(2,1) cycling with fully weighted
c     residual restriction and cubic prolongation).  this can also
c     be set by inputting mgopt(1) = 0 to muh2
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set floating point input parameters
c
      pi = 4.0*atan(1.0)
c
c     interval end points (in radians)
c
      ta = 0.0
      tb = pi
      pc = 0.
      pd = pi+pi
c
c     no error control
c
      tolmax = 0.0
c
c     set mesh increments
c
      dlt = (tb-ta)/float(nt-1)
      dlp = (pd-pc)/float(np-1)
c
c     preset sin,cos vectors to save computation on grid points
c
      do i=1,nt
	t = ta+(i-1)*dlt
	sinat(i) = sin(t)
	cosat(i) = cos(t)
      end do
      do j=1,np
	p = pc+(j-1)*dlp
	sinap(j) = sin(p)
	cosap(j) = cos(p)
      end do
c
c     initialize right hand side and solution array except at poles
c
      do i=2,nt-1
	t = ta+(i-1)*dlt
	sint = sinat(i)
	cost = cosat(i)
	do j=1,np
	  p = pc+(j-1)*dlp
	  call cof(t,p,ctt,cpp,ct,cp,ce)
c
c         set intermediate variables for exact solution
c
	  sinp = sinap(j)
	  cosp = cosap(j)
	  tmp = (sint*cosp*sint*sinp*cost)
	  dt = (2.*sint*cost*cost-sint**3)*(cosp*sinp)
	  dp = (cosp**2-sinp**2)*(sint**2*cost)
	  dtt = (2.*cost**3-4.*cost*sint**2-3.*sint**2*cost)*(cosp*sinp)
	  dpp = (-4.*cosp*sinp)*(sint**2*cost)
c
c         set continuous solution and partial derivatives
c
	  ue = tmp*tmp
	  ut = 2.*tmp*dt
	  up = 2.*tmp*dp
	  utt = 2.*(dt*dt+tmp*dtt)
	  upp = 2.*(dp*dp+tmp*dpp)
c
c         set right hand side of continuous pde on grid
c
	  r(i,j) = ctt*utt+cpp*upp+ct*ut+cp*up+ce*ue
c
c         initialize solution array to zero
c
	  u(i,j) = 0.0
	end do
      end do
c
c     set u, r(unused) at poles
c
      do j=1,np
	u(1,j) = 0.0
	r(1,j) = 0.0
	u(nt,j) = 0.0
	r(nt,j) = 0.0
      end do
c
c     print input parameters
c
      write(*,100)
  100 format(//' muh2 test' )

      write (*,101) (iparm(i),i=1,15)
  101 format(/' integer input parameters ',
     +/' intl = ',i2,' nta = ',i2,' ntb = ',i2,' npc = ',i2,' npd = 'i2,
     +/' itp = ',i2,' jpq = 'i2,' iet = ',i2,' jep = ',i2
     +/' nt = 'i3,' np = 'i3,' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space estimate = ',i7)

      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option parameters ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)

      write(*,103) (fparm(i),i=1,5)
  103 format(/' floating point input parameters ',
     +/' ta = 'f6.3,' tb = 'f6.3,' pc = 'f6.3,' pd = 'f6.3,
     +/' tolerance (error control) =  ' ,e10.3)
c
c     discretization call to muh2
c
      write(*,104) intl
  104 format(/' discretization call to muh2 ', ' intl = ',i2)
      call muh2(iparm,fparm,w,iw,cof,bndc,r,u,mgopt,ierror)
      write (*,105) ierror,iparm(16)
  105 format(' ierror = 'i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     aprroximation call to muh2
c
      intl = 1
      write(*,106) intl, method, iguess, maxcy, tolmax
  106 format(/' approximation call to muh2 ',
     +/' intl = ',i2, ' method = ',i2 , ' iguess = ',i2, ' maxcy = ',i2
     +/' tolmax = ',f5.2)
      call muh2(iparm,fparm,w,iw,cof,bndc,r,u,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = 'i2 )
      if (ierror.gt.0) call exit(0)
      if (ierror .le. 0) then
c
c     compute and print exact maximum error
c
      errm = 0.0
      do j=1,np
	sinp = sinap(j)
	cosp = cosap(j)
	do i=1,nt
	  sint = sinat(i)
	  cost = cosat(i)
	  ue = (sint*cosp*sint*sinp*cost)**2
	  errm = amax1(errm,abs((u(i,j)-ue)))
	end do
      end do
      write(*,108) errm
  108 format(' maximum error  = ',e10.3 )
      end if
c
c     execute two more cycles with iguess=1 to ensure second order
c
      maxcy = 2
      iguess = 1
      write(*,106) intl, method, iguess, maxcy, tolmax
      call muh2(iparm,fparm,w,iw,cof,bndc,r,u,mgopt,ierror)
      write (*,107) ierror
      if (ierror.gt.0) call exit(0)
      if (ierror .le. 0) then
c
c     compute and print exact maximum error
c
	errm = 0.0
	do j=1,np
	  sinp = sinap(j)
	  cosp = cosap(j)
	  do i=1,nt
	    sint = sinat(i)
	    cost = cosat(i)
	    ue = (sint*cosp*sint*sinp*cost)**2
	    errm = amax1(errm,abs((u(i,j)-ue)))
	  end do
	end do
	write(*,108) errm
      end if
c
c      attempt to improve approximation to fourth order
c
      call muh24(w,iw,u,ierror)
      write (*,109) ierror
  109 format(/' muh24 test ', ' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
      if (ierror .le. 0) then
c
c     compute and print exact maximum error
c
	errm = 0.0
	do j=1,np
	  sinp = sinap(j)
	  cosp = cosap(j)
	  do i=1,nt
	    sint = sinat(i)
	    cost = cosat(i)
	    ue = (sint*cosp*sint*sinp*cost)**2
	    errm = amax1(errm,abs((u(i,j)-ue)))
	  end do
	end do
	write(*,108) errm
      end if
      end

      subroutine cof(t,p,ctt,cpp,ct,cp,ce)
c
c     coefficient subroutine
c
      implicit none
      real t,p,ctt,cpp,ct,cp,ce
      integer intl,nta,ntb,npc,npd,itp,jpq,iet,jep,nt,np,
     +                iguess,maxcy,method,nwork,lwork,iter
      real ta,tb,pc,pd,tolmax,sinat,cosat,sinap,cosap,dlt,dlp
      common / iprm / intl,nta,ntb,npc,npd,itp,jpq,iet,jep,nt,np,
     +                iguess,maxcy,method,nwork,lwork,iter
      common / fprm / ta,tb,pc,pd,tolmax,sinat(73),cosat(73),
     +                sinap(145),cosap(145),dlt,dlp
      integer i,j
      real sinp,cosp,sint,cost,sigma,dsigdt,dsigdp
c
c     set subscripts for current grid point (t,p)
c
      i = int((t-ta)/dlt+0.5)+1
      j = int((p-pc)/dlp+0.5)+1
c
c     avoid poles where solution is specified and coefficients are not used
c
      if (i.gt. 1 .and. i.lt. nt) then
c
c     set sin,cos at (t,p) from precomputed vectors
c
      sinp = sinap(j)
      cosp = cosap(j)
      sint = sinat(i)
      cost = cosat(i)
c
c     set sigma and its t,p derivatives
c
      sigma = 1.5 + (sint*cosp)**2
      dsigdt = 2.0*cosp*cosp*sint*cost
      dsigdp = -2.0*sint*sint*cosp*sinp
c
c     set coefficients
c
      ctt = sint*sigma
      cpp = sigma/sint
      ct = sint*dsigdt + cost*sigma
      cp = dsigdp/sint
      ce = -sint*sigma
      return
      else
c
c     set unused coefs at poles arbitrarily
c
      ctt = 1.0
      cpp = 1.0
      ct = 0.0
      cp = 0.0
      ce = 0.0
      return
      end if
      end

      subroutine bndc(kbdy,torp,alfa,gbdy)
c
c     this subroutine must be provided as a dummy argument even though
c     there are no mixed derivative b.c.
c
      return
      end

      subroutine exact(t,p,utt,upp,ut,up,ue)
c
c     the exact solution used is the restriction of u(x,y,z) = (x*y*z)**2
c     in cartesian coordinates to the surface of the sphere of radius one
c     using the standard spherical coordinate transforms
c
      common / fprm / ta,tb,pc,pd,tolmax,sinat(73),cosat(73),
     +                sinap(145),cosap(145),dlt,dlp
c
c     set subscripts for current grid point (t,p)
c
      i = int((t-ta)/dlt+0.5)+1
      j = int((p-pc)/dlp+0.5)+1
c
c     set sin,cos from precomputed vectors
c
      sinp = sinap(j)
      cosp = cosap(j)
      sint = sinat(i)
      cost = cosat(i)
c
c     set intermediate variables
c
      tmp = (sint*cosp*sint*sinp*cost)
      dt = (2.*sint*cost*cost-sint**3)*(cosp*sinp)
      dp = (cosp**2-sinp**2)*(sint**2*cost)
      dtt = (2.*cost**3-4.*cost*sint**2-3.*sint**2*cost)*(cosp*sinp)
      dpp = (-4.*cosp*sinp)*(sint**2*cost)
c
c     set solution and partial derivatives
c
      ue = tmp*tmp
      ut = 2.*tmp*dt
      up = 2.*tmp*dp
      utt = 2.*(dt*dt+tmp*dtt)
      upp = 2.*(dp*dp+tmp*dpp)
      return
      end

</PRE>
<HR>
 
<a name="tmuh24cr.txt"><b>TMUH24CR</b></a>
<PRE>
c
c     file tmuh24cr.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the mudpack solver muh24cr
c
c ... required MUDPACK files
c
c     muh24cr.f, muh2cr.f, mudcom.f
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for muh24cr
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for muh24cr is listed below.  it
c     can be executed as an initial test.  the output is listed
c     for the test case described.
c
c     test muh24cr below by solving the nonseparable elliptic pde
c     with cross derivative term
c
c          (1.+y**2)*pxx + (1.+x**2)*pyy + 2.*x*y*pxy +
c
c          y*px + x*py - (x*y)*pe = r(x,y)
c
c     on a grid as close to 60 by 70 as muh24cr size constraints
c     allow.  the solution region is the unit square.  assume a
c     mixed derivative boundary condition at y=1 of the form
c
c          -x * dp/dx + (1+x) * dp/dy - x * pe = gbdyd(x).
c
c     and specified (Dirchlet) boundary conditions elsewhere.  the
c     exact solution
c
c          p(x,y) = (x*y)**5
c
c     is used to set the right hand side, boundary conditions, and
c     compute the error.
c
c     red/black gauss-seidel point relaxation is used along with the
c     the default multigrid options.  Three multigrid cycles are
c     executed with muh2cr to assure second-order discretization
c     level error for this problem.  muh24cr is then called for
c     a fourth-order estimate.  Choosing grid parameters
c
c       ixp = 15, jyq=9, iex=3,jey=4
c
c     yields a 61 by 73 grid.  The grid coarsening is
c
c       61 X 73 > 31 X 37 > 16 X 19 > 16 X 10
c
c     The coarsest 16 X 10 grid has too much resolution for effective
c     error reduction with relaxation only.  muh24cr uses a direct
c     method whenever the 16 X 10 grid is encountered which maintains
c     multigrid convergence efficiency
c
c ******************************************************
c     output (64 bit floating point arithmetic)
c *******************************************************
c
c     muh2cr test
c
c     integer input arguments
c     intl =  0 nxa =  1 nxb =  1 nyc =  1 nyd =  2
c     ixp = 15 jyq =  9 iex =  3 jey =  5
c     nx =  61 ny = 145 iguess =  0 maxcy =  1
c     method =  0 work space estimate =  149055
c
c     multigrid option arguments
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     xa =  0.000 xb =  1.000 yc =  0.000 yd =  1.000
c     tolerance (error control) =    0.000E+00
c
c     discretization call to muh2cr intl =  0
c     ierror =  0 minimum work space =  149055
c
c     approximation call to muh2cr
c     intl =  1 method =  0 iguess =  0
c     ierror =  0
c     maximum error  =   0.414E-03
c
c     muh24cr test  ierror =  0
c     maximum error  =   0.202E-05
c
c
c **********************************************************
c      end of output
c **********************************************************
c
      program tmuh24cr
      implicit none
c
c     set grid size params
c
      integer iixp,jjyq,iiex,jjey,nnx,nny,llwork
      integer iixp1,jjyq1
      parameter (iixp = 15 , jjyq = 9, iiex = 3, jjey = 5 )
      parameter(iixp1 = iixp+1, jjyq1 = jjyq+1)
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     set exact minimum work space requried (see tmuh2cr.f)
c
      parameter (llwork = 149055)
      real phi(nnx,nny),rhs(nnx,nny),work(llwork)
      integer iwork(iixp1,jjyq1)
c
c     put integer and floating point argument names in contiguous
c     storeage for labelling in vectors iprm,fprm
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itmuh2cr/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftmuh2cr/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      real dlx,dly,x,y,cxx,cxy,cyy,cx,cy,ce,pxx,pxy,pyy,px,py,pe,errmax
c
c     declare coefficient and boundary condition input subroutines external
c
      external cofcr,bndcr
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set multigrid arguments (w(2,1) cycling with fully weighted
c     residual restriction and cubic prolongation)
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set three cycles
c
      maxcy = 3
c
c     set no initial guess forcing full multigrid cycling
c
      iguess = 0
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set point relaxation
c
      method = 0
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control flag
c
      tolmax = 0.0
c
c     set right hand side in rhs
c     initialize phi to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cofcr(x,y,cxx,cxy,cyy,cx,cy,ce)
	  call exacr(x,y,pxx,pxy,pyy,px,py,pe)
	  rhs(i,j) = cxx*pxx+cxy*pxy+cyy*pyy+cx*px+cy*py+ce*pe
	  phi(i,j) = 0.0
	end do
      end do
c
c     set specified boundaries in phi at x=xa,xb and y=yc
c
      do j=1,ny
	y = yc+float(j-1)*dly
	call exacr(xa,y,pxx,pxy,pyy,px,py,pe)
	phi(1,j) = pe
	call exacr(xb,y,pxx,pxy,pyy,px,py,pe)
	phi(nx,j) = pe
      end do
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exacr(x,yc,pxx,pxy,pyy,px,py,pe)
	phi(i,1) = pe
      end do
      write(*,100)
  100 format(//' muh2cr test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to muh2cr', ' intl = ', i2)
      call muh2cr(iprm,fprm,work,iwork,cofcr,bndcr,rhs,phi,mgopt,ierror)
      write (*,105) ierror,iprm(16)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to muh2cr',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call muh2cr(iprm,fprm,work,iwork,cofcr,bndcr,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum norm of error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exacr(x,y,pxx,pxy,pyy,px,py,pe)
	  errmax = amax1(errmax,abs((phi(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
  108 format(' maximum error  =  ',e10.3)
c
c     attempt fourth-order
c
      call muh24cr(work,iwork,cofcr,bndcr,phi,ierror)
      write (*,109) ierror
  109 format(/' muh24cr test ', ' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum norm of error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exacr(x,y,pxx,pxy,pyy,px,py,pe)
	  errmax = amax1(errmax,abs((phi(i,j)-pe)))
	end do
      end do
      write(*,108) errmax
      end

      subroutine cofcr(x,y,cxx,cxy,cyy,cx,cy,ce)
c
c     input pde coefficients at any grid point (x,y) in the solution region
c     (xa.le.x.le.xb,yc.le.y.le.yd) to muh2cr
c
      implicit none
      real x,y,cxx,cxy,cyy,cx,cy,ce
      cxx = 1.+y**2
      cxy = 2.*x*y
      cyy = 1.+x**2
      cx = y
      cy = x
      ce = -(x*y)
      return
      end

      subroutine bndcr(kbdy,xory,alfa,beta,gama,gbdy)
c
c     input mixed "oblique" derivative b.c. to muh2cr
c     at upper y boundary
c
      implicit none
      integer kbdy
      real xory,alfa,beta,gama,gbdy
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itmuh2cr/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftmuh2cr/xa,xb,yc,yd,tolmax,relmax
      real x,y,pxx,pxy,pyy,px,py,pe
      if (kbdy.eq.4) then
c
c     y=yd boundary (nyd must equal 2 if this code is to be executed).
c     b.c. has the form alfyd(x)*px+betyd(x)*py+gamyd(x)*pe = gbdyd(x)
c     where x = yorx.   alfa,beta,gama,gbdy corresponding to alfyd(x),
c     betyd(x),gamyd(x),gbdyd(y) must be output.
c
      y = yd
      x = xory
      alfa = -x
      beta = 1.+x
      gama = -x
      call exacr(x,y,pxx,pxy,pyy,px,py,pe)
      gbdy = alfa*px + beta*py + gama*pe
      return
      end if
      end

      subroutine exacr(x,y,pxx,pxy,pyy,px,py,pe)
c
c     this subroutine is used for setting an exact solution
c     to test subroutine muh2cr.
c
      implicit none
      real x,y,pxx,pxy,pyy,px,py,pe
      pe = (x*y)**5
      px = 5.*(x*y)**4*y
      py = 5.*(x*y)**4*x
      pxx = 20.*(x*y)**3*y*y
      pxy = 25.*(x*y)**4
      pyy = 20.*(x*y)**3*x*x
      return
      end
</PRE>
<HR>
 
<a name="tmuh2cr.txt"><b>TMUH2CR</b></a>
<PRE>
c
c     file tmuh2cr.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the mudpack solver muh2cr
c
c ... required MUDPACK files
c
c     muh2cr.f, mudcom.f
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for muh2cr
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for muh2cr is listed below.  it
c     can be executed as an initial test.  the output is listed
c     for the test case described.
c
c     test muh2cr below by solving the nonseparable elliptic pde
c     with cross derivative term
c
c          (1.+y**2)*pxx + (1.+x**2)*pyy + 2.*x*y*pxy +
c
c          y*px + x*py - (x*y)*pe = r(x,y)
c
c     on a grid as close to 60 by 70 as muh2cr size constraints
c     allow.  the solution region is the unit square.  assume a
c     mixed derivative boundary condition at y=1 of the form
c
c          -x * dp/dx + (1+x) * dp/dy - x * pe = gbdyd(x).
c
c     and specified (Dirchlet) boundary conditions elsewhere.  the
c     exact solution
c
c          p(x,y) = (x*y)**5
c
c     is used to set the right hand side, boundary conditions, and
c     compute the error.
c
c     red/black gauss-seidel point relaxation is used along with the
c     the default multigrid options.  one full multigrid cycle reaches
c     discretization level error for this problem.  Choosing grid
c     size parameters
c
c       ixp = 15, jyq=9, iex=3,jey=4
c
c     yields a 61 by 73 grid.  The grid coarsening is
c
c       61 X 73 > 31 X 37 > 16 X 19 > 16 X 10
c
c     The coarsest 16 X 10 grid has too much resolution for effective
c     error reduction with relaxation only.  muh2cr uses a direct
c     method whenever the 16 X 10 grid is encountered which maintains
c     multigrid convergence efficiency
c
c ******************************************************
c     output (32 bit floating point arithmetic)
c *******************************************************
c
c     muh2cr test
c
c     integer input arguments
c     intl =  0 nxa =  1 nxb =  1 nyc =  1 nyd =  2
c     ixp = 15 jyq =  9 iex =  3 jey =  5
c     nx =  61 ny = 145 iguess =  0 maxcy =  1
c     method =  0 work space estimate =  151335
c
c     multigrid option arguments
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     floating point input parameters
c     xa =  0.000 xb =  1.000 yc =  0.000 yd =  1.000
c     tolerance (error control) =    0.000E+00
c
c     discretization call to muh2cr intl =  0
c     ierror =  0 minimum work space =  149055
c
c     approximation call to muh2cr
c     intl =  1 method =  0 iguess =  0
c     ierror =  0
c     maximum error  =   0.412E-03
c
c **********************************************************
c      end of output
c **********************************************************
c
      program tmuh2cr
      implicit none
c
c     set grid size params
c
      integer iixp,jjyq,iiex,jjey,nnx,nny,llwork
      integer iixp1,jjyq1
      parameter (iixp = 15 , jjyq = 9, iiex = 3, jjey = 5 )
      parameter(iixp1 = iixp+1, jjyq1 = jjyq+1)
      parameter (nnx=iixp*2**(iiex-1)+1, nny=jjyq*2**(jjey-1)+1)
c
c     estimate work space for point relaxation (see muh2cr.d)
c
      parameter (llwork=(7*(nnx+2)*(nny+2)+44*nnx*nny)/3 )
      real phi(nnx,nny),rhs(nnx,nny),work(llwork)
      integer iwork(iixp1,jjyq1)
c
c     put integer and floating point argument names in contiguous
c     storeage for labelling in vectors iprm,fprm
c
      integer iprm(16),mgopt(4)
      real fprm(6)
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itmuh2cr/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftmuh2cr/xa,xb,yc,yd,tolmax,relmax
      equivalence(intl,iprm)
      equivalence(xa,fprm)
      integer i,j,ierror
      real dlx,dly,x,y,cxx,cxy,cyy,cx,cy,ce,pxx,pxy,pyy,px,py,pe,errmax
c
c     declare coefficient and boundary condition input subroutines external
c
      external cofcr,bndcr
c
c
c     set input integer arguments
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 1
      nyc = 1
      nyd = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      iex = iiex
      jey = jjey
      nx = nnx
      ny = nny
c
c     set multigrid arguments (w(2,1) cycling with fully weighted
c     residual restriction and cubic prolongation)
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set for one cycle
c
      maxcy = 1
c
c     set no initial guess forcing full multigrid cycling
c
      iguess = 0
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set point relaxation
c
      method = 0
c
c     set end points of solution rectangle in (x,y) space
c
      xa = 0.0
      xb = 1.0
      yc = 0.0
      yd = 1.0
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
c
c     set for no error control flag
c
      tolmax = 0.0
c
c     set right hand side in rhs
c     initialize phi to zero
c
      do i=1,nx
	x = xa+float(i-1)*dlx
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call cofcr(x,y,cxx,cxy,cyy,cx,cy,ce)
	  call exacr(x,y,pxx,pxy,pyy,px,py,pe)
	  rhs(i,j) = cxx*pxx+cxy*pxy+cyy*pyy+cx*px+cy*py+ce*pe
	  phi(i,j) = 0.0
	end do
      end do
c
c     set specified boundaries in phi at x=xa,xb and y=yc
c
      do j=1,ny
	y = yc+float(j-1)*dly
	call exacr(xa,y,pxx,pxy,pyy,px,py,pe)
	phi(1,j) = pe
	call exacr(xb,y,pxx,pxy,pyy,px,py,pe)
	phi(nx,j) = pe
      end do
      do i=1,nx
	x = xa+float(i-1)*dlx
	call exacr(x,yc,pxx,pxy,pyy,px,py,pe)
	phi(i,1) = pe
      end do
      write(*,100)
  100 format(//' muh2cr test ')
      write (*,101) (iprm(i),i=1,15)
  101 format(/' integer input arguments ',
     +/' intl = 'i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = ',i2,
     +/' ixp = ',i2,' jyq = ',i2,' iex = ',i2,' jey = ',i2
     +/' nx = ',i3,' ny = ',i3,' iguess = ',i2,' maxcy = 'i2,
     +/' method = ',i2, ' work space estimate = ',i7)
      write (*,102) (mgopt(i),i=1,4)
  102 format(/' multigrid option arguments ',
     +/' kcycle = ',i2,
     +/' iprer = ',i2,
     +/' ipost = ',i2
     +/' intpol = ',i2)
      write(*,103) xa,xb,yc,yd,tolmax
  103 format(/' floating point input parameters ',
     +/' xa = ',f6.3,' xb = ',f6.3,' yc = ',f6.3,' yd = ',f6.3,
     +/' tolerance (error control) =   ',e10.3)
c
c     intiialization call
c
      write(*,104) intl
  104 format(/' discretization call to muh2cr', ' intl = ', i2)
      call muh2cr(iprm,fprm,work,iwork,cofcr,bndcr,rhs,phi,mgopt,ierror)
      write (*,200) ierror,iprm(16)
  200 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     attempt solution
c
      intl = 1
      write(*,106) intl,method,iguess
  106 format(/' approximation call to muh2cr',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2)
      call muh2cr(iprm,fprm,work,iwork,cofcr,bndcr,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
      if (ierror .le. 0) then
c
c     compute and print maximum norm of error
c
      errmax = 0.0
      do j=1,ny
	y = yc+(j-1)*dly
	do i=1,nx
	  x = xa+(i-1)*dlx
	  call exacr(x,y,pxx,pxy,pyy,px,py,pe)
	  errmax = amax1(errmax,abs((phi(i,j)-pe)))
	end do
      end do
      write(*,201) errmax
  201 format(' maximum error  =  ',e10.3)
      end if
      end

      subroutine cofcr(x,y,cxx,cxy,cyy,cx,cy,ce)
c
c     input pde coefficients at any grid point (x,y) in the solution region
c     (xa.le.x.le.xb,yc.le.y.le.yd) to muh2cr
c
      implicit none
      real x,y,cxx,cxy,cyy,cx,cy,ce
      cxx = 1.+y**2
      cxy = 2.*x*y
      cyy = 1.+x**2
      cx = y
      cy = x
      ce = -(x*y)
      return
      end

      subroutine bndcr(kbdy,xory,alfa,beta,gama,gbdy)
c
c     input mixed "oblique" derivative b.c. to muh2cr
c     at upper y boundary
c
      implicit none
      integer kbdy
      real xory,alfa,beta,gama,gbdy
      integer intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      common/itmuh2cr/intl,nxa,nxb,nyc,nyd,ixp,jyq,iex,jey,nx,ny,
     +              iguess,maxcy,method,nwork,lwrkqd,itero
      real xa,xb,yc,yd,tolmax,relmax
      common/ftmuh2cr/xa,xb,yc,yd,tolmax,relmax
      real x,y,pxx,pxy,pyy,px,py,pe
      if (kbdy.eq.4) then
c
c     y=yd boundary (nyd must equal 2 if this code is to be executed).
c     b.c. has the form alfyd(x)*px+betyd(x)*py+gamyd(x)*pe = gbdyd(x)
c     where x = yorx.   alfa,beta,gama,gbdy corresponding to alfyd(x),
c     betyd(x),gamyd(x),gbdyd(y) must be output.
c
      y = yd
      x = xory
      alfa = -x
      beta = 1.+x
      gama = -x
      call exacr(x,y,pxx,pxy,pyy,px,py,pe)
      gbdy = alfa*px + beta*py + gama*pe
      return
      end if
      end

      subroutine exacr(x,y,pxx,pxy,pyy,px,py,pe)
c
c     this subroutine is used for setting an exact solution
c     to test subroutine muh2cr.
c
      implicit none
      real x,y,pxx,pxy,pyy,px,py,pe
      pe = (x*y)**5
      px = 5.*(x*y)**4*y
      py = 5.*(x*y)**4*x
      pxx = 20.*(x*y)**3*y*y
      pxy = 25.*(x*y)**4
      pyy = 20.*(x*y)**3*x*x
      return
      end
</PRE>
<HR>
 
<a name="tmuh3.txt"><b>TMUH3</b></a>
<PRE>
c
c     file tmuh3.f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver muh3
c
c ... required MUDPACK files
c
c     muh3.f, mudcom.f, mud3ln.f, mud3pn.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for muh3
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for muh3 is below. it can be
c     executed as an initial test.  the output is listed for the
c     test case described.
c
c     test the driver below by solving the nonseparable 3-d elliptic pde
c
c          pxx+pyy+pzz-y*z*px-x*z*py-x*y*pz-x*y*z*pe = r(x,y,z)
c
c     on a 41 by 21 by 57 grid superimposed on the (x,y,z) region
c
c          [0.5,1.0] X [1.0,2.0] X [0.25,0.75]
c
c     the solution is specified at x=0.5,1.0 and y=1.0,2.0 and there are
c     mixed derivative conditions of the form
c
c          dp/dz - (x*y)*p = g(x,z) at z=0.25
c
c          dp/dz + (x*y)*p = h(x,y) at z=0.75
c
c     one full multigrid cycle using the default multigrid options
c     and line relaxation in the z direction is executed.  The
c     exact solution
c
c          pe(x,y,z) = exp(x*y*z)
c
c     is used to set the right hand side of the pde, boundary conditions
c     and compute error.  Choosing grid arguments
c
c       ixp = 5, jyq = 5, kzr = 7, iex = 4, jey = 3, kez = 42
c
c     gives the grid coarsening
c
c       41 X 21 X 57 > 21 X 11 X 29 > 11 X 6 X 15 > 6 X 6 X 8
c
c     The coarsest 6 by 6 by 8 grid has too many points for effective
c     error reduction with relaxation alone.  muh3 utilizes a direct
c     method whenever this grid is encountered within multigrid cycling
c     thus maintaining rapid multigrid convergence,

c
c ******************************************************
c     output (32 bit floating point arithmetic)
c *******************************************************
c
c     muh3 test
c
c     input arguments
c     intl =  0 nxa =  1 nxb =  1 nyc =  1 nyd =  1
c     nze =  2 nzf =  2
c     ixp =  5 jyq =  5 kzr =  7
c     iex =  4 jey =  3 kez =  4
c     nx =  41 ny =  21 nz =  57 iguess =  0 maxcy =  1
c     method =  3 work space length input =  779587
c     xa =  0.50 xb =  1.00
c     yc =  1.00 yd =  2.00
c     ze =  0.25 zf =  0.75
c     tolmax =  0.000E+00
c
c     multigrid options
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     discretization call to muh3 intl =  0
c     ierror =  0 minimum work space =  776711
c
c     approximation call to muh3
c     intl =  1 method =  3 iguess =  0 maxcy =  1
c     ierror =  0
c     maximum error  =   0.193E-04
c
c ************************************************************
c     end of output
c ************************************************************
c
      program tmuh3
      implicit none
c
c     set grid sizes with parameter statements
c
      integer iixp,jjyq,kkzr,iiex,jjey,kkez,llwork,nnx,nny,nnz
      integer mmx,mmy,mmz,lls,lld
      parameter(iixp=5,jjyq=5,kkzr=7)
      parameter (mmx=iixp+1,mmy=jjyq+1,mmz=kkzr+1)
      parameter(iiex=4,jjey=3,kkez=4)
      parameter (nnx = iixp*2**(iiex-1)+1)
      parameter (nny = jjyq*2**(jjey-1)+1)
      parameter (nnz = kkzr*2**(kkez-1)+1)
c
c     set work space length estimate for method=3 (see muh3.d).
c     this will probably overestimate required space
c
      parameter (lls = 13*(nnx+2)*(nny+2)*(nnz+2) )
      parameter (lld = mmx*mmy*mmz*(2*mmx*mmy+1))
      parameter (llwork = lls+lld)
c
c     dimension solution,right hand side, and work arrays
c
      real phi(nnx,nny,nnz),rhs(nnx,nny,nnz),work(llwork)
      integer iw(mmx,mmy,mmz)
      integer iprm(23),mgopt(4)
      real fprm(8)
c
c     put integer and floating point arguments names in contiguous
c     storeage labelling
c
      integer intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,
     +              lwrkqd,itero
      common/itmud3/intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,
     +              lwrkqd,itero

      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmud3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real dlx,dly,dlz,x,y,z,cxx,cyy,czz,cx,cy,cz,ce,errm
      real pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k,ierror
      equivalence(intl,iprm)
      equivalence(xa,fprm)
c
c     declare coefficient and boundary condition input subroutines external
c
      external cof,bndc
c
c     set for initial call
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 1
      nyc = 1
      nyd = 1
      nze = 2
      nzf = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      kzr = kkzr
      iex = iiex
      jey = jjey
      kez = kkez
      nx = nnx
      ny = nny
      nz = nnz
c
c     set for one multigrid cycles
c
      maxcy = 1
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set method of relaxation--line in the z direction
c
      method = 3
c
c     meth2 only used in planar relaxation--but set
c
      meth2 = 0
c
c     set full multigrid cycling by flagging no initial guess at the finest
c     grid level
c
      iguess = 0
c
c     set end points of solution region in (x,y,z) space
c
      xa = 0.5
      xb = 1.0
      yc = 1.0
      yd = 2.0
      ze = 0.25
      zf = 0.75
c
c     set default multigrid options
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
      dlz = (zf-ze)/float(nz-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in rhs and phi to zero
c
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    rhs(i,j,k) = cxx*pxx+cyy*pyy+czz*pzz+cx*px+cy*py+cz*pz+ce*pe
	    phi(i,j,k) = 0.0
	  end do
	end do
      end do
c
c     set specified values at x and y boundaries in phi
c
      x = xa
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(1,j,k) = pe
	end do
      end do
      x = xb
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(nx,j,k) = pe
	end do
      end do
      y = yc
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,1,k) = pe
	end do
      end do
      y = yd
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,ny,k) = pe
	end do
      end do
      write(6,50)
   50 format(//' muh3 test ')
c
c     print input arguments
c
      write(6,100)intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,kez,
     +            nx,ny,nz,iguess,maxcy,method,nwork,xa,xb,yc,yd,ze,zf,
     +            tolmax,mgopt(1),mgopt(2),mgopt(3),mgopt(4)
  100 format(/' input arguments ',
     +/' intl = ',i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = 'i2,
     +/' nze = ',i2, ' nzf = ',i2,
     +/' ixp = ',i2,' jyq = 'i2,' kzr = 'i2,
     +/' iex = ',i2, ' jey = 'i2, ' kez = 'i2,
     +/' nx = 'i3,' ny = 'i3,' nz = 'i3, ' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space length input = ',i7,
     +/' xa = 'f5.2,' xb = 'f5.2,
     +/' yc = 'f5.2,' yd = 'f5.2,
     +/' ze = 'f5.2,' zf = 'f5.2,
     +/' tolmax = ' ,e10.3
     +//' multigrid options '
     +/' kcycle = ',i2
     +/' iprer = ',i2
     +/' ipost = ',i2
     +/' intpol = ',i2 )
c
c     discretize pde
c
      write(*,104) intl
  104 format(/' discretization call to muh3', ' intl = ', i2)
      call muh3(iprm,fprm,work,iw,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,105) ierror,iprm(22)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     approximate pde
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to muh3 ',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call muh3(iprm,fprm,work,iw,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum error
c
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
  108 format(' maximum error  =  ',e10.3)
      end

      subroutine error(nx,ny,nz,phi,errm)
c
c     compute the error in the estimate in phi
c
      implicit none
      integer nx,ny,nz
      real phi(nx,ny,nz),errm
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmud3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real dlx,dly,dlz,x,y,z,pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k
      dlx = (xb-xa)/(nx-1)
      dly = (yd-yc)/(ny-1)
      dlz = (zf-ze)/(nz-1)
      errm = 0.0
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    errm = amax1(errm,abs(phi(i,j,k)-pe))
	  end do
	end do
      end do
      return
      end

      subroutine cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
c
c     input pde coefficients at grid point (x,y,z) in the solution region
c     to subroutine muh3
c
      implicit none
      real x,y,z,cxx,cyy,czz,cx,cy,cz,ce
      cxx = 1.0
      cyy = 1.0
      czz = 1.0
      cx = -y*z
      cy = -x*z
      cz = -x*y
      ce = -(x*y*z)
      return
      end

      subroutine bndc(kbdy,xory,yorz,alfa,gbdy)
c
c     input mixed derivative conditions at z boundaries to muh3
c
      implicit none
      integer kbdy
      real xory,yorz,alfa,gbdy
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmud3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real x,y,z,pxx,pyy,pzz,px,py,pz,pe
      if (kbdy.eq.5) then
c
c     z = ze (lower z boundary)
c
	z = ze
	x = xory
	y = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	alfa = -(x*y)
	gbdy = pz + alfa*pe
	return
      end if
      if (kbdy.eq.6) then
c
c     z=zf (upper z boundary)
c
	z = zf
	x = xory
	y = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	alfa = (x*y)
	gbdy = pz + alfa*pe
	return
      end if
      end

      subroutine exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
c
c     this subroutine is used to set an exact solution for testing muh3
c
      implicit none
      real x,y,z,pe,px,py,pz,pxx,pyy,pzz
      pe = exp(x*y*z)
      px = y*z*pe
      py = x*z*pe
      pz = x*y*pe
      pxx = (y*z)*px
      pyy = (x*z)*py
      pzz = (x*y)*pz
      return
      end

</PRE>
<HR>
 
<a name="tmuh34.txt"><b>TMUH34</b></a>
<PRE>
c
c     file tmuh34f
c
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     *                                                               *
c     *                  copyright (c) 2008 by UCAR                   *
c     *                                                               *
c     *       University Corporation for Atmospheric Research         *
c     *                                                               *
c     *                      all rights reserved                      *
c     *                                                               *
c     *                     MUDPACK  version 5.0.1                    *
c     *                                                               *
c     *                 A Fortran Package of Multigrid                *
c     *                                                               *
c     *                Subroutines and Example Programs               *
c     *                                                               *
c     *      for Solving Elliptic Partial Differential Equations      *
c     *                                                               *
c     *                             by                                *
c     *                                                               *
c     *                         John Adams                            *
c     *                                                               *
c     *                             of                                *
c     *                                                               *
c     *         the National Center for Atmospheric Research          *
c     *                                                               *
c     *                Boulder, Colorado  (80307)  U.S.A.             *
c     *                                                               *
c     *                   which is sponsored by                       *
c     *                                                               *
c     *              the National Science Foundation                  *
c     *                                                               *
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c ... purpose
c
c     test program for the MUDPACK solver muh34
c
c ... required MUDPACK files
c
c     muh34.f, udcom.f, mud3ln.f, mud3pn.f
c
c
c *********************************************************
c *********************************************************
c
c     sample program/test driver for muh34
c
c **********************************************************
c **********************************************************
c
c
c     a sample program/test driver for muh3 is below. it can be
c     executed as an initial test.  the output is listed for the
c     test case described.
c
c     test the driver below by solving the nonseparable 3-d elliptic pde
c
c          pxx+pyy+pzz-y*z*px-x*z*py-x*y*pz-x*y*z*pe = r(x,y,z)
c
c     on a 41 by 21 by 57 grid superimposed on the (x,y,z) region
c
c          [0.5,1.0] X [1.0,2.0] X [0.25,0.75]
c
c     the solution is specified at x=0.5,1.0 and y=1.0,2.0 and there are
c     mixed derivative conditions of the form
c
c          dp/dz - (x*y)*p = g(x,z) at z=0.25
c
c          dp/dz + (x*y)*p = h(x,y) at z=0.75
c
c     two full multigrid cycle using the default multigrid options
c     and line relaxation in the z direction is executed.  The
c     exact solution
c
c          pe(x,y,z) = exp(x*y*z)
c
c     is used to set the right hand side of the pde, boundary conditions
c     and compute error.  Choosing grid arguments
c
c       ixp = 5, jyq = 5, kzr = 7, iex = 4, jey = 3, kez = 42
c
c     gives the grid coarsening
c
c       41 X 21 X 57 > 21 X 11 X 29 > 11 X 6 X 15 > 6 X 6 X 8
c
c     The coarsest 6 by 6 by 8 grid has too many points for effective
c     error reduction with relaxation alone.  muh3 utilizes a direct
c     method whenever this grid is encountered within multigrid cycling
c     thus maintaining rapid multigrid convergence.  After muh3 is
c     called with two multigrid cycles, muh34 is called for a fourth
c     order estimate
c
c ******************************************************
c     output (64 bit floating point arithmetic)
c *******************************************************
c
c     muh3 test
c
c     input arguments
c     intl =  0 nxa =  1 nxb =  1 nyc =  1 nyd =  1
c     nze =  2 nzf =  2
c     ixp =  5 jyq =  5 kzr =  7
c     iex =  4 jey =  3 kez =  4
c     nx =  41 ny =  21 nz =  57 iguess =  0 maxcy =  1
c     method =  3 work space length input =  776771
c     xa =  0.50 xb =  1.00
c     yc =  1.00 yd =  2.00
c     ze =  0.25 zf =  0.75
c     tolmax =  0.000E+00
c
c     multigrid options
c     kcycle =  2
c     iprer =  2
c     ipost =  1
c     intpol =  3
c
c     discretization call to muh3 intl =  0
c     ierror =  0 minimum work space =  776711
c
c     approximation call to muh3
c     intl =  1 method =  3 iguess =  0 maxcy =  2
c     ierror =  0
c     maximum error  =   0.180E-04
c
c     muh34 test ierror =  0
c     maximum error  =   0.179E-05
c
c ************************************************************
c     end of output
c ************************************************************
c
      program tmuh34
      implicit none
c
c     set grid sizes with parameter statements
c
      integer iixp,jjyq,kkzr,iiex,jjey,kkez,llwork,nnx,nny,nnz
      integer mmx,mmy,mmz
      parameter(iixp=5,jjyq=5,kkzr=7)
      parameter (mmx=iixp+1,mmy=jjyq+1,mmz=kkzr+1)
      parameter(iiex=4,jjey=3,kkez=4)
      parameter (nnx = iixp*2**(iiex-1)+1)
      parameter (nny = jjyq*2**(jjey-1)+1)
      parameter (nnz = kkzr*2**(kkez-1)+1)
c
c     set minimal required work space (see tmuh3.f)
c
      parameter (llwork = 776771)
c
c     dimension solution,right hand side, and work arrays
c
      real phi(nnx,nny,nnz),rhs(nnx,nny,nnz),work(llwork)
      integer iw(mmx,mmy,mmz)
      integer iprm(23),mgopt(4)
      real fprm(8)
c
c     put integer and floating point arguments names in contiguous
c     storeage labelling
c
      integer intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,
     +              lwrkqd,itero
      common/itmud3/intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,
     +              kez,nx,ny,nz,iguess,maxcy,method,meth2,nwork,
     +              lwrkqd,itero

      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmud3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real dlx,dly,dlz,x,y,z,cxx,cyy,czz,cx,cy,cz,ce,errm
      real pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k,ierror
      equivalence(intl,iprm)
      equivalence(xa,fprm)
c
c     declare coefficient and boundary condition input subroutines external
c
      external cof,bndc
c
c     set for initial call
c
      intl = 0
c
c     set boundary condition flags
c
      nxa = 1
      nxb = 1
      nyc = 1
      nyd = 1
      nze = 2
      nzf = 2
c
c     set grid sizes from parameter statements
c
      ixp = iixp
      jyq = jjyq
      kzr = kkzr
      iex = iiex
      jey = jjey
      kez = kkez
      nx = nnx
      ny = nny
      nz = nnz
c
c     set two multigrid cycles
c
      maxcy = 2
c
c     set work space length approximation from parameter statement
c
      nwork = llwork
c
c     set method of relaxation--line in the z direction
c
      method = 3
c
c     meth2 only used in planar relaxation--but set
c
      meth2 = 0
c
c     set full multigrid cycling by flagging no initial guess at the finest
c     grid level
c
      iguess = 0
c
c     set end points of solution region in (x,y,z) space
c
      xa = 0.5
      xb = 1.0
      yc = 1.0
      yd = 2.0
      ze = 0.25
      zf = 0.75
c
c     set default multigrid options
c
      mgopt(1) = 2
      mgopt(2) = 2
      mgopt(3) = 1
      mgopt(4) = 3
c
c     set mesh increments
c
      dlx = (xb-xa)/float(nx-1)
      dly = (yd-yc)/float(ny-1)
      dlz = (zf-ze)/float(nz-1)
c
c     set for no error control
c
      tolmax = 0.0
c
c     set right hand side in rhs and phi to zero
c
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    rhs(i,j,k) = cxx*pxx+cyy*pyy+czz*pzz+cx*px+cy*py+cz*pz+ce*pe
	    phi(i,j,k) = 0.0
	  end do
	end do
      end do
c
c     set specified values at x and y boundaries in phi
c
      x = xa
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(1,j,k) = pe
	end do
      end do
      x = xb
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(nx,j,k) = pe
	end do
      end do
      y = yc
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,1,k) = pe
	end do
      end do
      y = yd
      do k=1,nz
	z = ze+(k-1)*dlz
	do i=1,nx
	  x = xa+float(i-1)*dlx
	  call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	  phi(i,ny,k) = pe
	end do
      end do
      write(6,50)
   50 format(//' muh3 test ')
c
c     print input arguments
c
      write(6,100)intl,nxa,nxb,nyc,nyd,nze,nzf,ixp,jyq,kzr,iex,jey,kez,
     +            nx,ny,nz,iguess,maxcy,method,nwork,xa,xb,yc,yd,ze,zf,
     +            tolmax,mgopt(1),mgopt(2),mgopt(3),mgopt(4)
  100 format(/' input arguments ',
     +/' intl = ',i2,' nxa = ',i2,' nxb = ',i2,' nyc = ',i2,' nyd = 'i2,
     +/' nze = ',i2, ' nzf = ',i2,
     +/' ixp = ',i2,' jyq = 'i2,' kzr = 'i2,
     +/' iex = ',i2, ' jey = 'i2, ' kez = 'i2,
     +/' nx = 'i3,' ny = 'i3,' nz = 'i3, ' iguess = 'i2,' maxcy = 'i2,
     +/' method = 'i2, ' work space length input = ',i7,
     +/' xa = 'f5.2,' xb = 'f5.2,
     +/' yc = 'f5.2,' yd = 'f5.2,
     +/' ze = 'f5.2,' zf = 'f5.2,
     +/' tolmax = ' ,e10.3
     +//' multigrid options '
     +/' kcycle = ',i2
     +/' iprer = ',i2
     +/' ipost = ',i2
     +/' intpol = ',i2 )
c
c     discretize pde
c
      write(*,104) intl
  104 format(/' discretization call to muh3', ' intl = ', i2)
      call muh3(iprm,fprm,work,iw,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,105) ierror,iprm(22)
  105 format(' ierror = ',i2, ' minimum work space = ',i7)
      if (ierror.gt.0) call exit(0)
c
c     approximate pde
c
      intl = 1
      write(*,106) intl,method,iguess,maxcy
  106 format(/' approximation call to muh3 ',
     +/' intl = ',i2, ' method = ',i2,' iguess = ',i2, ' maxcy = ',i2)
      call muh3(iprm,fprm,work,iw,cof,bndc,rhs,phi,mgopt,ierror)
      write (*,107) ierror
  107 format(' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
c
c     compute and print maximum error
c
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
  108 format(' maximum error  =  ',e10.3)
c
c     fourth-order estimate
c
      call muh34(work,iw,phi,ierror)
      write (*,109) ierror
  109 format(/' muh34 test', ' ierror = ',i2)
      if (ierror.gt.0) call exit(0)
      call error(nx,ny,nz,phi,errm)
      write(*,108) errm
      end

      subroutine error(nx,ny,nz,phi,errm)
c
c     compute the error in the estimate in phi
c
      implicit none
      integer nx,ny,nz
      real phi(nx,ny,nz),errm
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmud3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real dlx,dly,dlz,x,y,z,pxx,pyy,pzz,px,py,pz,pe
      integer i,j,k
      dlx = (xb-xa)/(nx-1)
      dly = (yd-yc)/(ny-1)
      dlz = (zf-ze)/(nz-1)
      errm = 0.0
      do k=1,nz
	z = ze+(k-1)*dlz
	do j=1,ny
	  y = yc+float(j-1)*dly
	  do i=1,nx
	    x = xa+float(i-1)*dlx
	    call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	    errm = amax1(errm,abs(phi(i,j,k)-pe))
	  end do
	end do
      end do
      return
      end

      subroutine cof(x,y,z,cxx,cyy,czz,cx,cy,cz,ce)
c
c     input pde coefficients at grid point (x,y,z) in the solution region
c     to subroutine muh3
c
      implicit none
      real x,y,z,cxx,cyy,czz,cx,cy,cz,ce
      cxx = 1.0
      cyy = 1.0
      czz = 1.0
      cx = -y*z
      cy = -x*z
      cz = -x*y
      ce = -(x*y*z)
      return
      end

      subroutine bndc(kbdy,xory,yorz,alfa,gbdy)
c
c     input mixed derivative conditions at z boundaries to muh3
c
      implicit none
      integer kbdy
      real xory,yorz,alfa,gbdy
      real xa,xb,yc,yd,ze,zf,tolmax,relmax
      common/ftmud3/xa,xb,yc,yd,ze,zf,tolmax,relmax
      real x,y,z,pxx,pyy,pzz,px,py,pz,pe
      if (kbdy.eq.5) then
c
c     z = ze (lower z boundary)
c
	z = ze
	x = xory
	y = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	alfa = -(x*y)
	gbdy = pz + alfa*pe
	return
      end if
      if (kbdy.eq.6) then
c
c     z=zf (upper z boundary)
c
	z = zf
	x = xory
	y = yorz
	call exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
	alfa = (x*y)
	gbdy = pz + alfa*pe
	return
      end if
      end

      subroutine exact(x,y,z,pxx,pyy,pzz,px,py,pz,pe)
c
c     this subroutine is used to set an exact solution for testing muh3
c
      implicit none
      real x,y,z,pe,px,py,pz,pxx,pyy,pzz
      pe = exp(x*y*z)
      px = y*z*pe
      py = x*z*pe
      pz = x*y*pe
      pxx = (y*z)*px
      pyy = (x*z)*py
      pzz = (x*y)*pz
      return
      end

</PRE>
<HR>
</p></body></html>

<center>
<p><a href="#beginning"><h2>Return to beginning of this document</h2></a></p>
</center>
