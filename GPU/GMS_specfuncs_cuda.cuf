

module specfuncs_cuda


!===================================================================================85
 !---------------------------- DESCRIPTION ------------------------------------------85
 !
 !
 !
 !          Module  name:
 !                         specfuncs_cuda
 !          
 !          Purpose:
 !                        CUDA implementation of special functions library.
 !                        
 !                        
 !          History:
 !                        Date: 01-01-2024
 !                        Time: 09:46AM GMT+2
 !                        
 !          Version:
 !
 !                      Major: 1
 !                      Minor: 0
 !                      Micro: 0
 !
 !          Author:  
 !                     Shanjie Zhang, Jianming Jin
 ! 
 !          Modified:
                       Bernard Gingold 
 !          
 !                 
 !          References:
 !         
 !                     
 !                        Shanjie Zhang, Jianming Jin,
 !                        Computation of Special Functions,
 !                        Wiley, 1996,
 !                        ISBN: 0-471-11963-6,
 !                        LC: QA351.C45.
 !          E-mail:
 !                  
 !                      beniekg@gmail.com
!==================================================================================85
    ! Tab:5 col - Type and etc.. definitions
    ! Tab:10,11 col - Type , function and subroutine code blocks.
    
    use mod_kinds,    only : i1,i4,sp
    use cudafor
    
    public
    implicit none
    


     ! Major version
    integer(kind=i4),  parameter :: SPECFUNCS_CUDA_MAJOR = 1
    ! Minor version
    integer(kind=i4),  parameter :: SPECFUNCS_CUDA_MINOR = 0
    ! Micro version
    integer(kind=i4),  parameter :: SPECFUNCS_CUDA_MICRO = 0
    ! Full version
    integer(kind=i4),  parameter :: SPECFUNCS_CUDA_FULLVER =   &
            1000*SPECFUNCS_CUDA_MAJOR+100*SPECFUNCS_CUDA_MINOR+10*SPECFUNCS_CUDA_MICRO
    ! Module creation date
    character(*),        parameter :: SPECFUNCS_CUDA_CREATE_DATE = "01-01-2024 10:01AM +00200 (MON 01 01 2024 GMT+2)"
    ! Module build date
    character(*),        parameter :: SPECFUNCS_CUDA_BUILD_DATE  = __DATE__ " " __TIME__
    ! Module author info
    character(*),        parameter :: SPECFUNCS_CUDA_AUTHOR      = "Shanjie Zhang, Jianming Jin, Modified by Bernard Gingold"
    ! Short description
    character(*),        parameter :: SPECFUNCS_CUDA_SYNOPSIS    = "Cuda implementation of Special Functions library."   

    
    contains
    
attributes(device) subroutine airya ( x, ai, bi, ad, bd )

!*****************************************************************************80
!
!! AIRYA computes Airy functions and their derivatives.
!
!  Licensing:
!
!    The original FORTRAN77 version of this routine is copyrighted by 
!    Shanjie Zhang and Jianming Jin.  However, they give permission to 
!    incorporate this routine into a user program that the copyright 
!    is acknowledged.
!
!  Modified:
!
!    30 June 2012
!
!  Author:
!
!    Original FORTRAN77 version by Shanjie Zhang, Jianming Jin.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!       
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument of the Airy function.
!
!    Output, real(kind=sp) ::  AI, BI, AD, BD, the values of Ai(x), Bi(x),
!    Ai'(x), Bi'(x).
!
  implicit none

  real(kind=sp) ::  ad
  real(kind=sp) ::  ai
  real(kind=sp) ::  bd
  real(kind=sp) ::  bi
  real(kind=sp) ::  c1
  real(kind=sp) ::  c2
  real(kind=sp) ::  pir
  real(kind=sp) ::  sr3
  real(kind=sp) ::  vi1
  real(kind=sp) ::  vi2
  real(kind=sp) ::  vj1
  real(kind=sp) ::  vj2
  real(kind=sp) ::  vk1
  real(kind=sp) ::  vk2
  real(kind=sp) ::  vy1
  real(kind=sp) ::  vy2
  real(kind=sp), value ::  x
  real(kind=sp) ::  xa
  real(kind=sp) ::  xq
  real(kind=sp) ::  z

  xa = abs ( x )
  pir = 0.318309886183891_sp
  c1 = 0.355028053887817_sp
  c2 = 0.258819403792807_sp
  sr3 = 1.732050807568877_sp
  z = xa ** 1.5_sp / 1.5_sp
  xq = sqrt ( xa )

  call ajyik ( z, vj1, vj2, vy1, vy2, vi1, vi2, vk1, vk2 )    

  if ( x == 0.0_sp ) then
    ai = c1
    bi = sr3 * c1
    ad = - c2
    bd = sr3 * c2
  else if ( 0.0_sp < x ) then
    ai = pir * xq / sr3 * vk1
    bi = xq * ( pir * vk1 + 2.0_sp / sr3 * vi1 ) ! pir * vk1 + 2.0_sp * invsr3 * vii
    ad = - xa / sr3 * pir * vk2
    bd = xa * ( pir * vk2 + 2.0_sp / sr3 * vi2 )
  else
    ai = 0.5_sp * xq * ( vj1 - vy1 / sr3 )
    bi = - 0.5_sp * xq * ( vj1 / sr3 + vy1 )
    ad = 0.5_sp * xa * ( vj2 + vy2 / sr3 )
    bd = 0.5_sp * xa * ( vj2 / sr3 - vy2 )
  end if

end subroutine airya


attributes(device) subroutine airyb ( x, ai, bi, ad, bd )

!*****************************************************************************80
!
!! AIRYB computes Airy functions and their derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    02 June 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, argument of Airy function.
!
!    Output, real(kind=sp) ::  AI, Ai(x).
!
!    Output, real(kind=sp) ::  BI, Bi(x).
!
!    Output, real(kind=sp) ::  AD, Ai'(x).
!
!    Output, real(kind=sp) ::  BD, Bi'(x).
!
  implicit none

  real(kind=sp) ::  ad
  real(kind=sp) ::  ai
  real(kind=sp) ::  bd
  real(kind=sp) ::  bi
  real(kind=sp) ::  c1
  real(kind=sp) ::  c2
  real(kind=sp) ::  ck(41)
  real(kind=sp) ::  df
  real(kind=sp) ::  dg
  real(kind=sp) ::  dk(41)
  real(kind=sp) ::  eps
  real(kind=sp) ::  fx
  real(kind=sp) ::  gx
  integer(kind=i4) ::  k
  integer(kind=i4) ::  km
  real(kind=sp) ::  pi
  real(kind=sp) ::  r
  real(kind=sp) ::  rp
  real(kind=sp) ::  sad
  real(kind=sp) ::  sai
  real(kind=sp) ::  sbd
  real(kind=sp) ::  sbi
  real(kind=sp) ::  sda
  real(kind=sp) ::  sdb
  real(kind=sp) ::  sr3
  real(kind=sp) ::  ssa
  real(kind=sp) ::  ssb
  real(kind=sp), value ::  x
  real(kind=sp) ::  xa
  real(kind=sp) ::  xar
  real(kind=sp) ::  xcs
  real(kind=sp) ::  xe
  real(kind=sp) ::  xf
  real(kind=sp) ::  xm
  real(kind=sp) ::  xp1
  real(kind=sp) ::  xq
  real(kind=sp) ::  xr1
  real(kind=sp) ::  xr2
  real(kind=sp) ::  xss

  eps = 1.0e-15_sp
  pi = 3.141592653589793_sp
  c1 = 0.355028053887817_sp
  c2 = 0.258819403792807_sp
  sr3 = 1.732050807568877_sp
  xa = abs ( x )
  xq = sqrt ( xa )

  if ( x <= 0.0_sp ) then
    xm = 8.0_sp
  else
    xm = 5.0_sp
  end if

  !if ( x == 0.0_sp ) then
  !  ai = c1
  !  bi = sr3 * c1
  !  ad = -c2
  !  bd = sr3 * c2
  !  return
  !end if

  if ( xa <= xm ) then

    fx = 1.0_sp
    r = 1.0_sp
    do k = 1, 40
      r = r * x / ( 3.0_sp * k ) * x / ( 3.0_sp * k - 1.0_sp ) * x
      fx = fx + r
      if ( abs ( r ) < abs ( fx ) * eps ) then
        exit
      end if
    end do

    gx = x
    r = x
    do k = 1, 40
      r = r * x / ( 3.0_sp * k ) * x / ( 3.0_sp * k + 1.0_sp ) * x
      gx = gx + r
      if ( abs ( r ) < abs ( gx ) * eps ) then
        exit
      end if
    end do

    ai = c1 * fx - c2 * gx
    bi = sr3 * ( c1 * fx + c2 * gx )
    df = 0.5_sp * x * x
    r = df
    do k = 1, 40
      r = r * x / ( 3.0_sp * k ) * x / ( 3.0_sp * k + 2.0_sp ) * x
      df = df + r 
      if ( abs ( r ) < abs ( df ) * eps ) then
        exit
      end if
    end do

    dg = 1.0_sp
    r = 1.0_sp
    do k = 1, 40
      r = r * x / ( 3.0_sp * k ) * x / ( 3.0_sp * k - 2.0_sp ) * x
      dg = dg + r
      if ( abs ( r ) < abs ( dg ) * eps ) then
        exit
      end if
    end do

    ad = c1 * df - c2 * dg
    bd = sr3 * ( c1 * df + c2 * dg )

  else

    xe = xa * xq / 1.5_sp
    xr1 = 1.0_sp / xe
    xar = 1.0_sp / xq
    xf = sqrt ( xar )
    rp = 0.5641895835477563_sp
    r = 1.0_sp
    do k = 1, 40
      r = r * ( 6.0_sp * k - 1.0_sp ) &
        / 216.0_sp * ( 6.0_sp * k - 3.0_sp ) &
        / k * ( 6.0_sp * k - 5.0_sp ) / ( 2.0_sp * k - 1.0_sp )
      ck(k) = r
      dk(k) = - ( 6.0_sp * k + 1.0_sp ) / ( 6.0_sp * k - 1.0_sp ) * ck(k)
    end do

    km = int ( 24.5_sp - xa )

    if ( xa < 6.0_sp ) then
      km = 14
    end if

    if ( 15.0_sp < xa ) then
      km = 10
    end if

    if ( 0.0_sp < x ) then
      sai = 1.0_sp
      sad = 1.0_sp
      r = 1.0_sp
      do k = 1, km
        r = - r * xr1
        sai = sai + ck(k) * r
        sad = sad + dk(k) * r
      end do
      sbi = 1.0_sp
      sbd = 1.0_sp
      r = 1.0_sp
      do k = 1, km
        r = r * xr1
        sbi = sbi + ck(k) * r
        sbd = sbd + dk(k) * r
      end do
      xp1 = exp ( - xe )
      ai = 0.5_sp * rp * xf * xp1 * sai
      bi = rp * xf / xp1 * sbi
      ad = -0.5_sp * rp / xf * xp1 * sad
      bd = rp / xf / xp1 * sbd
    else
      xcs = cos ( xe + pi / 4.0_sp )
      xss = sin ( xe + pi / 4.0_sp )
      ssa = 1.0_sp
      sda = 1.0_sp
      r = 1.0_sp
      xr2 = 1.0_sp / ( xe * xe )
      do k = 1, km
        r = - r * xr2
        ssa = ssa + ck(2*k) * r
        sda = sda + dk(2*k) * r
      end do
      ssb = ck(1) * xr1
      sdb = dk(1) * xr1
      r = xr1
      do k = 1, km
        r = - r * xr2
        ssb = ssb + ck(2*k+1) * r
        sdb = sdb + dk(2*k+1) * r
      end do
      ai = rp * xf * ( xss * ssa - xcs * ssb )
      bi = rp * xf * ( xcs * ssa + xss * ssb )
      ad = -rp / xf * ( xcs * sda + xss * sdb )
      bd =  rp / xf * ( xss * sda - xcs * sdb )
    end if

  end if
  
end subroutine airyb


attributes(device) subroutine ajyik ( x, vj1, vj2, vy1, vy2, vi1, vi2, vk1, vk2 )

!*****************************************************************************80
!
!! AJYIK computes Bessel functions Jv(x), Yv(x), Iv(x), Kv(x).
!
!  Discussion: 
!
!    Compute Bessel functions Jv(x) and Yv(x), and modified Bessel functions 
!    Iv(x) and Kv(x), and their derivatives with v = 1/3, 2/3.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    31 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.  X should not be zero.
!
!    Output, real(kind=sp) ::  VJ1, VJ2, VY1, VY2, VI1, VI2, VK1, VK2,
!    the values of J1/3(x), J2/3(x), Y1/3(x), Y2/3(x), I1/3(x), I2/3(x),
!    K1/3(x), K2/3(x).
!
  implicit none

  real(kind=sp) ::  a0
  real(kind=sp) ::  b0
  real(kind=sp) ::  c0
  real(kind=sp) ::  ck
  real(kind=sp) ::  gn
  real(kind=sp) ::  gn1
  real(kind=sp) ::  gn2
  real(kind=sp) ::  gp1
  real(kind=sp) ::  gp2
  integer(kind=i4) ::  k
  integer(kind=i4) ::  k0
  integer(kind=i4) ::  l
  real(kind=sp) ::  pi
  real(kind=sp) ::  pv1
  real(kind=sp) ::  pv2
  real(kind=sp) ::  px
  real(kind=sp) ::  qx
  real(kind=sp) ::  r
  real(kind=sp) ::  rp
  real(kind=sp) ::  rp2
  real(kind=sp) ::  rq
  real(kind=sp) ::  sk
  real(kind=sp) ::  sum
  real(kind=sp) ::  uj1
  real(kind=sp) ::  uj2
  real(kind=sp) ::  uu0
  real(kind=sp) ::  vi1
  real(kind=sp) ::  vi2
  real(kind=sp) ::  vil
  real(kind=sp) ::  vj1
  real(kind=sp) ::  vj2
  real(kind=sp) ::  vjl
  real(kind=sp) ::  vk1
  real(kind=sp) ::  vk2
  real(kind=sp) ::  vl
  real(kind=sp) ::  vsl
  real(kind=sp) ::  vv
  real(kind=sp) ::  vv0
  real(kind=sp) ::  vy1
  real(kind=sp) ::  vy2
  real(kind=sp), value ::  x
  real(kind=sp) ::  x2
  real(kind=sp) ::  xk

  !if ( x == 0.0_sp ) then
  !  vj1 = 0.0_sp
  !  vj2 = 0.0_sp
  !  vy1 = -1.0e+300
  !  vy2 = 1.0e+300
  !  vi1 = 0.0_sp
  !  vi2 = 0.0_sp
  !  vk1 = -1.0e+300
  !  vk2 = -1.0e+300
  !  return
  !end if

  pi = 3.141592653589793_sp
  rp2 = 0.63661977236758_sp
  gp1 = 0.892979511569249_sp
  gp2 = 0.902745292950934_sp
  gn1 = 1.3541179394264_sp
  gn2 = 2.678938534707747_sp
  vv0 = 0.444444444444444_sp
  uu0 = 1.1547005383793_sp
  x2 = x * x

  if ( x < 35.0_sp ) then
    k0 = 12
  else if ( x < 50.0_sp ) then
    k0 = 10
  else
    k0 = 8
  end if

  if ( x <= 12.0_sp ) then

    do l = 1, 2
      vl = l / 3.0_sp
      vjl = 1.0_sp
      r = 1.0_sp
      do k = 1, 40
        r = -0.25_sp * r * x2 / ( k * ( k + vl ) )
        vjl = vjl + r
        if ( abs ( r ) < 1.0e-15_sp ) then
          exit
        end if
      end do

      a0 = ( 0.5_sp * x ) ** vl
      if ( l == 1 ) then
        vj1 = a0 / gp1 * vjl
      else
        vj2 = a0 / gp2 * vjl
      end if

    end do

  else

    do l = 1, 2

      vv = vv0 * l * l
      px = 1.0_sp
      rp = 1.0_sp

      do k = 1, k0
        rp = - 0.78125e-02_sp * rp &
          * ( vv - ( 4.0_sp * k - 3.0_sp ) ** 2 ) &
          * ( vv - ( 4.0_sp * k - 1.0_sp ) ** 2 ) &
          / ( k * ( 2.0_sp * k - 1.0_sp ) * x2 )
        px = px + rp
      end do

      qx = 1.0_sp
      rq = 1.0_sp
      do k = 1, k0
        rq = - 0.78125e-02_sp * rq &
          * ( vv - ( 4.0_sp * k - 1.0_sp ) ** 2 ) &
          * ( vv - ( 4.0_sp * k + 1.0_sp ) ** 2 ) &
          / ( k * ( 2.0_sp * k + 1.0_sp ) * x2 )
        qx = qx + rq
      end do

      qx = 0.125_sp * ( vv - 1.0_sp ) * qx / x
      xk = x - ( 0.5_sp * l / 3.0_sp + 0.25_sp ) * pi
      a0 = sqrt ( rp2 / x )
      ck = cos ( xk )
      sk = sin ( xk )
      if ( l == 1) then
        vj1 = a0 * ( px * ck - qx * sk )
        vy1 = a0 * ( px * sk + qx * ck )
      else
        vj2 = a0 * ( px * ck - qx * sk )
        vy2 = a0 * ( px * sk + qx * ck )
      end if

    end do

  end if

  if ( x <= 12.0_sp ) then

    do l = 1, 2

      vl = l / 3.0_sp
      vjl = 1.0_sp
      r = 1.0_sp
      do k = 1, 40
        r = -0.25_sp * r * x2 / ( k * ( k - vl ) )
        vjl = vjl + r
        if ( abs ( r ) < 1.0e-15 ) then
          exit
        end if
      end do

      b0 = ( 2.0_sp / x ) ** vl
      if ( l == 1 ) then
        uj1 = b0 * vjl / gn1
      else
         uj2 = b0 * vjl / gn2
      end if

    end do

    pv1 = pi / 3.0_sp
    pv2 = pi / 1.5_sp
    vy1 = uu0 * ( vj1 * cos ( pv1 ) - uj1 )
    vy2 = uu0 * ( vj2 * cos ( pv2 ) - uj2 )

  end if

  if ( x <= 18.0_sp ) then

    do l = 1, 2
      vl = l / 3.0_sp
      vil = 1.0_sp
      r = 1.0_sp
      do k = 1, 40
        r = 0.25_sp * r * x2 / ( k * ( k + vl ) )
        vil = vil + r
        if ( abs ( r ) < 1.0e-15_sp ) then
          exit
        end if
      end do

      a0 = ( 0.5_sp * x ) ** vl

      if ( l == 1 ) then
        vi1 = a0 / gp1 * vil
      else
        vi2 = a0 / gp2 * vil
      end if

    end do

  else

    c0 = exp ( x ) / sqrt ( 2.0_sp * pi * x )

    do l = 1, 2
      vv = vv0 * l * l
      vsl = 1.0_sp
      r = 1.0_sp
      do k = 1, k0
        r = - 0.125_sp * r &
          * ( vv - ( 2.0_sp * k - 1.0_sp ) ** 2 ) / ( k * x )
        vsl = vsl + r
      end do
      if ( l == 1 ) then
        vi1 = c0 * vsl
      else
        vi2 = c0 * vsl
      end if
    end do

  end if

  if ( x <= 9.0_sp ) then

    do l = 1, 2
      vl = l / 3.0_sp
      if ( l == 1 ) then
        gn = gn1
      else
        gn = gn2
      end if
      a0 = ( 2.0_sp / x ) ** vl / gn
      sum = 1.0_sp
      r = 1.0_sp
      do k = 1, 60
        r = 0.25_sp * r * x2 / ( k * ( k - vl ) )
        sum = sum + r
        if ( abs ( r ) < 1.0e-15_sp ) then
          exit
        end if
      end do

      if ( l == 1 ) then
        vk1 = 0.5_sp * uu0 * pi * ( sum * a0 - vi1 )
      else
        vk2 = 0.5_sp * uu0 * pi * ( sum * a0 - vi2 )
      end if

    end do

  else

    c0 = exp ( - x ) * sqrt ( 0.5_sp * pi / x )

    do l = 1, 2
      vv = vv0 * l * l
      sum = 1.0_sp
      r = 1.0_sp
      do k = 1, k0
        r = 0.125_sp * r * ( vv - ( 2.0_sp * k - 1.0_sp ) ** 2 ) / ( k * x )
        sum = sum + r
      end do
      if ( l == 1 ) then
        vk1 = c0 * sum
      else
        vk2 = c0 * sum
      end if
    end do

  end if

end subroutine ajyik   


attributes(device) subroutine beta ( p, q, bt )

!*****************************************************************************80
!
!! BETA computes the Beta function B(p,q).
!
!  Licensing:
!
!    The original FORTRAN77 version of this routine is copyrighted by 
!    Shanjie Zhang and Jianming Jin.  However, they give permission to 
!    incorporate this routine into a user program that the copyright 
!    is acknowledged.
!
!  Modified:
!
!    12 March 2012
!
!  Author:
!
!    Original FORTRAN77 version by Shanjie Zhang, Jianming Jin.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45
!
!  Parameters:
!
!    Input, real(kind=sp) ::  P, Q, the parameters.
!    0 < P, 0 < Q.
!
!    Output, real(kind=sp) ::  BT, the value of B(P,Q).
!
  implicit none

  real(kind=sp) ::  bt
  real(kind=sp) ::  gp
  real(kind=sp) ::  gpq
  real(kind=sp) ::  gq
  real(kind=sp), value ::  p
  real(kind=sp) ::  ppq
  real(kind=sp), value ::  q

  call gamma ( p, gp )
  call gamma ( q, gq )
  ppq = p + q
  call gamma ( ppq, gpq )
  bt = gp * gq / gpq

 
end subroutine beta


attributes(device) subroutine cerf ( z, cer, cder )

!*****************************************************************************80
!
!! CERF computes the error function and derivative for a complex argument.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    25 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
! 
!  Parameters:
!
!    Input, complex(kind=sp) :: z , the argument.
!
!    Output, complex(kind=sp) ::  CER, CDER, the values of erf(z) and erf'(z).
!
  implicit none

  complex(kind=sp) ::  c0
  complex(kind=sp) ::  cder
  complex(kind=sp) ::  cer
  complex(kind=sp) ::  cs
  real(kind=sp) ::  ei1
  real(kind=sp) ::  ei2
  real(kind=sp) ::  eps
  real(kind=sp) ::  er
  real(kind=sp) ::  er0
  real(kind=sp) ::  er1
  real(kind=sp) ::  er2 
  real(kind=sp) ::  eri
  real(kind=sp) ::  err
  integer(kind=i4) ::  k
  integer(kind=i4) ::  n
  real(kind=sp) ::  pi
  real(kind=sp) ::  r
  real(kind=sp) ::  ss
  real(kind=sp) ::  w
  real(kind=sp) ::  w1
  real(kind=sp) ::  w2
  real(kind=sp) ::  x
  real(kind=sp) ::  x2
  real(kind=sp) ::  y
  complex(kind=sp), value ::  z

  eps = 1.0e-12_sp
  pi = 3.141592653589793_sp
  x = real ( z, kind=sp )
  y = imag ( z )
  x2 = x * x

  if ( x <= 3.5_sp ) then

    er = 1.0_sp
    r = 1.0_sp
    do k = 1, 100
      r = r * x2 / ( k + 0.5_sp )
      er = er + r
      if ( abs ( er - w ) <= eps * abs ( er ) ) then
        exit
      end if
      w = er
    end do

    c0 = 2.0_sp / sqrt ( pi ) * x * exp ( - x2 )
    er0 = c0 * er

  else

    er = 1.0_sp
    r = 1.0_sp
    do k = 1, 12
      r = - r * ( k - 0.5_sp ) / x2
      er = er + r
    end do
    c0 = exp ( - x2 ) / ( x * sqrt ( pi ) )
    er0 = 1.0_sp - c0 * er

  end if

  if ( y == 0.0_sp ) then
    err = er0
    eri = 0.0_sp
  else
    cs = cos ( 2.0_sp * x * y )
    ss = sin ( 2.0_sp * x * y )
    er1 = exp ( - x2 ) * ( 1.0_sp - cs ) / ( 2.0_sp * pi * x )
    ei1 = exp ( - x2 ) * ss / ( 2.0_sp * pi * x )
    er2 = 0.0_sp
    do n = 1, 100
      er2 = er2 + exp ( - 0.25_sp * n * n ) &
        / ( n * n + 4.0_sp * x2 ) * ( 2.0_sp * x &
        - 2.0_sp * x * cosh ( n * y ) * cs &
        + n * sinh ( n * y ) * ss )
      if ( abs ( ( er2 - w1 ) / er2 ) < eps ) then
        exit
      end if
      w1 = er2
    end do

    c0 = 2.0_sp * exp ( - x2 ) / pi
    err = er0 + er1 + c0 * er2
    ei2 = 0.0_sp
    do n = 1, 100
      ei2 = ei2 + exp ( - 0.25_sp * n * n ) &
        / ( n * n + 4.0_sp * x2 ) * ( 2.0_sp * x &
        * cosh ( n * y ) * ss + n * sinh ( n * y ) * cs )
      if ( abs ( ( ei2 - w2 ) / ei2 ) < eps ) then
        exit
      end if
      w2 = ei2
    end do

    eri = ei1 + c0 * ei2

  end if

  cer = cmplx ( err, eri, kind=sp )
  cder = 2.0_sp / sqrt ( pi ) * exp ( - z * z )

  
end subroutine cerf


attributes(device) subroutine cerror ( z, cer )

!*****************************************************************************80
!
!! CERROR computes the error function for a complex argument.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    15 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
! 
!  Parameters:
!
!    Input, complex(kind=sp) ::  Z, the argument.
!
!    Output, complex(kind=sp) ::  CER, the function value.
!
  implicit none

  real(kind=sp) ::  a0
  complex(kind=sp) ::  c0
  complex(kind=sp) ::  cer
  complex(kind=sp) ::  cl
  complex(kind=sp) ::  cr
  complex(kind=sp) ::  cs
  integer(kind=i4) ::  k
  real(kind=sp) ::  pi
  complex(kind=sp), value ::  z
  complex(kind=sp) ::  z1

  a0 = abs ( z )
  c0 = exp ( - z * z )
  pi = 3.141592653589793_sp
  z1 = z

  if ( real ( z, kind = sp ) < 0.0_sp ) then
    z1 = - z
  end if

  if ( a0 <= 5.8_sp ) then    

    cs = z1
    cr = z1
    do k = 1, 120
      cr = cr * z1 * z1 / ( k + 0.5_sp )
      cs = cs + cr
      if ( abs ( cr / cs ) < 1.0e-15_sp ) then
        exit
      end if
    end do

    cer = 2.0_sp * c0 * cs / sqrt ( pi )

  else

    cl = 1.0_sp / z1              
    cr = cl
    do k = 1, 13
      cr = -cr * ( k - 0.5_sp ) / ( z1 * z1 )
      cl = cl + cr
      if ( abs ( cr / cl ) < 1.0e-15_sp ) then
        exit
      end if
    end do

    cer = 1.0_sp - c0 * cl / sqrt ( pi )

  end if

  if ( real ( z, kind = sp ) < 0.0_sp ) then
    cer = -cer
  end if

  
end subroutine cerror


attributes(device) subroutine cfc ( z, zf, zd )

!*****************************************************************************80
!
!! CFC computes the complex Fresnel integral C(z) and C'(z).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    26 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, complex(kind=sp) ::  Z, the argument.
!
!    Output, complex(kind=sp) ::  ZF, ZD, the values of C(z) and C'(z).
!
  implicit none

  complex(kind=sp) ::  c
  complex(kind=sp) ::  cf
  complex(kind=sp) ::  cf0
  complex(kind=sp) ::  cf1
  complex(kind=sp) ::  cg
  complex(kind=sp) ::  cr
  real(kind=sp) ::  eps
  integer(kind=i4) ::  k
  integer(kind=i4) ::  m
  real(kind=sp) ::  pi
  real(kind=sp) ::  w0
  real(kind=sp) ::  wa
  real(kind=sp) ::  wa0
  complex(kind=sp), value ::  z
  complex(kind=sp) ::  z0
  complex(kind=sp) ::  zd
  complex(kind=sp) ::  zf
  complex(kind=sp) ::  zp
  complex(kind=sp) ::  zp2

  eps = 1.0e-14
  pi = 3.141592653589793_sp
  w0 = abs ( z )
  zp = 0.5_sp * pi * z * z
  zp2 = zp * zp
  z0 = cmplx ( 0.0_sp, 0.0_sp, kind = sp )

  if ( z .eq. z0 ) then

    c = z0

  else if ( w0 <= 2.5_sp ) then

    cr = z
    c = cr
    do k = 1, 80
      cr = -0.5_sp * cr * ( 4.0_sp * k - 3.0_sp ) &
        / k / ( 2.0_sp * k - 1.0_sp ) &
        / ( 4.0_sp * k + 1.0_sp ) * zp2
      c = c + cr
      wa = abs ( c )
      if ( abs ( ( wa - wa0 ) / wa ) < eps .and. 10 < k ) then
        exit
      end if
      wa0 = wa
    end do

  else if ( 2.5_sp < w0 .and. w0 < 4.5_sp ) then

    m = 85
    c = z0
    cf1 = z0
    cf0 = cmplx ( 1.0e-30_sp, 0.0_sp, kind = sp )
    do k = m, 0, -1
      cf = ( 2.0_sp * k + 3.0_sp ) * cf0 / zp - cf1
      if ( k .eq. int ( k / 2 ) * 2 ) then
        c = c + cf
      end if
      cf1 = cf0
      cf0 = cf
    end do
    c = sqrt ( 2.0_sp / ( pi * zp ) ) * sin ( zp ) / cf * c

  else

    cr = cmplx ( 1.0_sp, 0.0_sp, kind = sp )
    cf = cmplx ( 1.0_sp, 0.0_sp, kind = sp )
    do k = 1, 20
      cr = - 0.25_sp * cr * ( 4.0_sp * k - 1.0_sp ) &
        * ( 4.0_sp * k - 3.0_sp ) / zp2
      cf = cf + cr
    end do
    cr = 1.0_sp / ( pi * z * z )
    cg = cr
    do k = 1, 12
      cr = - 0.25_sp * cr * ( 4.0_sp * k + 1.0_sp ) &
        * ( 4.0_sp * k - 1.0_sp ) / zp2
      cg = cg + cr
    end do
    c = 0.5_sp + ( cf * sin ( zp ) - cg * cos ( zp ) ) / ( pi * z )

  end if

  zf = c
  zd = cos ( 0.5_sp * pi * z * z )

  
end subroutine cfc


attributes(device) subroutine cfs ( z, zf, zd )

!*****************************************************************************80
!
!! CFS computes the complex Fresnel integral S(z) and S'(z).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    24 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, complex(kind=sp) ::  Z, the argument.
!
!    Output, complex(kind=sp) ::  ZF, ZD, the values of S(z) and S'(z).
!
  implicit none

  complex(kind=sp) ::  cf
  complex(kind=sp) ::  cf0
  complex(kind=sp) ::  cf1
  complex(kind=sp) ::  cg
  complex(kind=sp) ::  cr
  real(kind=sp) ::  eps
  integer(kind=i4) ::  k
  integer(kind=i4) ::  m
  real(kind=sp) ::  pi
  complex(kind=sp) ::  s
  real(kind=sp) ::  w0
  real(kind=sp) ::  wb
  real(kind=sp) ::  wb0
  complex(kind=sp), value ::  z
  complex(kind=sp) ::  z0
  complex(kind=sp) ::  zd
  complex(kind=sp) ::  zf
  complex(kind=sp) ::  zp
  complex(kind=sp) ::  zp2

  eps = 1.0e-14_sp
  pi = 3.141592653589793_sp
  w0 = abs ( z )
  zp = 0.5_sp * pi * z * z
  zp2 = zp * zp
  z0 = cmplx ( 0.0_sp, 0.0_sp, kind = sp )

  if ( z == z0 ) then

    s = z0

  else if ( w0 <= 2.5_sp ) then

    s = z * zp / 3.0_sp
    cr = s
    do k = 1, 80
      cr = -0.5_sp * cr * ( 4.0_sp * k - 1.0_sp ) / k &
        / ( 2.0_sp * k + 1.0_sp ) &
        / ( 4.0_sp * k + 3.0_sp ) * zp2
      s = s + cr
      wb = abs ( s )
      if ( abs ( wb - wb0 ) < eps .and. 10 < k ) then
        exit
      end if
      wb0 = wb
    end do

  else if ( 2.5_sp < w0 .and. w0 < 4.5_sp ) then

    m = 85
    s = z0
    cf1 = z0
    cf0 = cmplx ( 1.0e-30_sp, 0.0_sp, kind = sp  )
    do k = m, 0, -1
      cf = ( 2.0_sp * k + 3.0_sp ) * cf0 / zp - cf1
      if ( k /= int ( k / 2 ) * 2 ) then
        s = s + cf
      end if
      cf1 = cf0
      cf0 = cf
    end do
    s = sqrt ( 2.0_sp / ( pi * zp ) ) * sin ( zp ) / cf * s

  else

    cr = cmplx ( 1.0_sp, 0.0_sp, kind = sp  )
    cf = cmplx ( 1.0_sp, 0.0_sp, kind = sp  )
    do k = 1, 20
      cr = -0.25_sp * cr * ( 4.0_sp * k - 1.0_sp ) &
        * ( 4.0_sp * k - 3.0_sp ) / zp2
      cf = cf + cr
    end do
    cr = 1.0_sp / ( pi * z * z )
    cg = cr
    do k = 1, 12
      cr = -0.25_sp * cr * ( 4.0_sp * k + 1.0_sp ) &
        * ( 4.0_sp * k - 1.0_sp ) / zp2
      cg = cg + cr
    end do
    s = 0.5_sp - ( cf * cos ( zp ) + cg * sin ( zp ) ) / ( pi * z )

  end if

  zf = s
  zd = sin ( 0.5_sp * pi * z * z )

  
end subroutine cfs


attributes(device) subroutine cgama ( x, y, kf, gr, gi )

!*****************************************************************************80
!
!! CGAMA computes the Gamma function for complex argument.
!
!  Discussion:
!
!    This procedcure computes the gamma function \E2(z) or ln[\E2(z)]
!    for a complex argument
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    26 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, Y, the real and imaginary parts of 
!    the argument Z.
!
!    Input, integer(kind=i4) ::  KF, the function code.
!    0 for ln[\E2(z)]
!    1 for \E2(z)
!
!    Output, real(kind=sp) ::  GR, GI, the real and imaginary parts of
!    the selected function.
!
  implicit none

  real(kind=sp) :: , dimension ( 10 ) :: a = (/ &
    8.333333333333333e-02_sp, -2.777777777777778e-03_sp, &
    7.936507936507937e-04_sp, -5.952380952380952e-04_sp, &
    8.417508417508418e-04_sp, -1.917526917526918e-03_sp, &
    6.410256410256410e-03_sp, -2.955065359477124e-02_sp, &
    1.796443723688307e-01_sp, -1.39243221690590_sp /)
  real(kind=sp) ::  g0
  real(kind=sp) ::  gi
  real(kind=sp) ::  gi1
  real(kind=sp) ::  gr
  real(kind=sp) ::  gr1
  integer(kind=i4) ::  j
  integer(kind=i4) ::  k
  integer(kind=i4), value ::  kf
  integer(kind=i4) ::  na
  real(kind=sp) ::  pi
  real(kind=sp) ::  si
  real(kind=sp) ::  sr
  real(kind=sp) ::  t
  real(kind=sp) ::  th
  real(kind=sp) ::  th1
  real(kind=sp) ::  th2
  real(kind=sp), value ::  x
  real(kind=sp) ::  x0
  real(kind=sp) ::  x1
  real(kind=sp), value ::  y
  real(kind=sp) ::  y1
  real(kind=sp) ::  z1
  real(kind=sp) ::  z2

  pi = 3.141592653589793_sp

  if ( y == 0.0_sp .and. x == int ( x ) .and. x <= 0.0_sp ) then
    gr = huge(1.0_sp,kind=sp)
    gi = 0.0_sp
    return
  else if ( x < 0.0_sp ) then
    x1 = x
    y1 = y
    x = -x
    y = -y
  end if

  x0 = x

  if ( x <= 7.0_sp ) then
    na = int ( 7 - x )
    x0 = x + na
  end if

  z1 = sqrt ( x0 * x0 + y * y )
  th = atan ( y / x0 )
  gr = ( x0 - 0.5_sp ) * log ( z1 ) - th * y - x0 &
    + 0.5_sp * log ( 2.0_sp * pi )
  gi = th * ( x0 - 0.5_sp ) + y * log ( z1 ) - y

  do k = 1, 10
    t = z1 ** ( 1 - 2 * k )
    gr = gr + a(k) * t * cos ( ( 2.0_sp * k - 1.0_sp ) * th )
    gi = gi - a(k) * t * sin ( ( 2.0_sp * k - 1.0_sp ) * th )
  end do

  if ( x <= 7.0_sp ) then
    gr1 = 0.0_sp
    gi1 = 0.0_sp
    do j = 0, na - 1
      gr1 = gr1 + 0.5_sp * log ( ( x + j ) ** 2 + y * y )
      gi1 = gi1 + atan ( y / ( x + j ) )
    end do
    gr = gr - gr1
    gi = gi - gi1
  end if

  if ( x1 < 0.0_sp ) then
    z1 = sqrt ( x * x + y * y )
    th1 = atan ( y / x )
    sr = - sin ( pi * x ) * cosh ( pi * y )
    si = - cos ( pi * x ) * sinh ( pi * y )
    z2 = sqrt ( sr * sr + si * si )
    th2 = atan ( si / sr )
    if ( sr < 0.0_sp ) then
      th2 = pi + th2
    end if
    gr = log ( pi / ( z1 * z2 ) ) - gr
    gi = - th1 - th2 - gi
    x = x1
    y = y1
  end if

  if ( kf == 1 ) then
    g0 = exp ( gr )
    gr = g0 * cos ( gi )
    gi = g0 * sin ( gi )
  end if

  
end subroutine cgama


attributes(device) subroutine cjk ( km, a )

!*****************************************************************************80
!
!! CJK: asymptotic expansion coefficients for Bessel functions of large order.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    01 August 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: KM, the maximum value of K.
!
!    Output, real(kind=sp) ::  A(L), the value of Cj(k) where j and k are 
!    related to L by L = j+1+[k*(k+1)]/2; j,k = 0,1,...,Km.
!
  implicit none

  real(kind=sp) ::  a(*)
  real(kind=sp) ::  f
  real(kind=sp) ::  f0
  real(kind=sp) ::  g
  real(kind=sp) ::  g0
  integer(kind=i4) :: j
  integer(kind=i4) :: k
  integer(kind=i4) :: km
  integer(kind=i4) :: l1
  integer(kind=i4) :: l2
  integer(kind=i4) :: l3
  integer(kind=i4) :: l4

  a(1) = 1.0_sp
  f0 = 1.0_sp
  g0 = 1.0_sp
  do k = 0, km - 1
    l1 = ( k + 1 ) * ( k + 2 ) / 2 + 1
    l2 = ( k + 1 ) * ( k + 2 ) / 2 + k + 2
    f = ( 0.5_sp * k + 0.125_sp / ( k + 1 ) ) * f0
    g = - ( 1.5_sp * k + 0.625_sp &
      / ( 3.0_sp * ( k + 1.0_sp ) ) ) * g0
    a(l1) = f
    a(l2) = g
    f0 = f
    g0 = g
  end do

  do k = 1, km - 1
    do j = 1, k
      l3 = k * ( k + 1 ) / 2 + j + 1
      l4 = ( k + 1 ) * ( k + 2 ) / 2 + j + 1
      a(l4) = ( j + 0.5_sp * k + 0.125_sp &
        / ( 2.0_sp * j + k + 1.0_sp ) ) * a(l3) &
        - ( j + 0.5_sp * k - 1.0_sp + 0.625_sp &
        / ( 2.0_sp * j + k + 1.0_sp ) ) * a(l3-1)
    end do
  end do

  
end subroutine cjk


attributes(device) subroutine cik01 ( z, cbi0, cdi0, cbi1, cdi1, cbk0, cdk0, cbk1, cdk1 )

!*****************************************************************************80
!
!! CIK01: modified Bessel I0(z), I1(z), K0(z) and K1(z) for complex argument.
!
!  Discussion:
!
!    This procedure computes the modified Bessel functions I0(z), I1(z), 
!    K0(z), K1(z), and their derivatives for a complex argument.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    31 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
! 
!  Parameters:
!
!    Input, complex(kind=sp) Z, the argument.
!
!    Output, complex(kind=sp) CBI0, CDI0, CBI1, CDI1, CBK0, CDK0, CBK1, 
!    CDK1, the values of I0(z), I0'(z), I1(z), I1'(z), K0(z), K0'(z), K1(z), 
!    and K1'(z).
!
  implicit none

  real(kind=sp),dimension ( 12 ) :: a = (/ &
    0.125_sp,           7.03125e-02_sp,&
    7.32421875e-02_sp,      1.1215209960938e-01_sp,&
    2.2710800170898e-01_sp, 5.7250142097473e-01_sp,&
    1.7277275025845_sp, 6.0740420012735_sp,&
    2.4380529699556e+01_sp, 1.1001714026925e+02_sp,&
    5.5133589612202e+02_sp, 3.0380905109224e+03_sp /)
  real(kind=sp) a0
  real(kind=sp),dimension ( 10 ) :: a1 = (/ &
    0.125_sp,            0.2109375_sp, &
    1.0986328125_sp,     1.1775970458984e+01_sp, &
    2.1461706161499_sp, 5.9511522710323e+03_sp, &
    2.3347645606175e+05_sp,  1.2312234987631e+07_sp, &
    8.401390346421e+08_sp,   7.2031420482627e+10_sp /)
  real(kind=sp),dimension ( 12 ) :: b = (/ &
   -0.375_sp,           -1.171875e-01_sp, &
   -1.025390625e-01_sp,     -1.4419555664063e-01_sp, &
   -2.7757644653320e-01_sp, -6.7659258842468e-01_sp, &
   -1.9935317337513_sp, -6.8839142681099_sp, &
   -2.7248827311269e+01_sp, -1.2159789187654e+02_sp, &
   -6.0384407670507e+02_sp, -3.3022722944809e+03_sp /)
  complex(kind=sp) :: ca
  complex(kind=sp) :: cb
  complex(kind=sp) :: cbi0
  complex(kind=sp) :: cbi1
  complex(kind=sp) :: cbk0
  complex(kind=sp) :: cbk1
  complex(kind=sp) :: cdi0
  complex(kind=sp) :: cdi1
  complex(kind=sp) :: cdk0
  complex(kind=sp) :: cdk1
  complex(kind=sp) :: ci
  complex(kind=sp) :: cr
  complex(kind=sp) :: cs
  complex(kind=sp) :: ct
  complex(kind=sp) :: cw
  integer(kind=i4) :: k
  integer(kind=i4) :: k0
  real(kind=sp) :: pi
  real(kind=sp) :: w0
  complex(kind=sp), value :: z
  complex(kind=sp) :: z1
  complex(kind=sp) :: z2
  complex(kind=sp) :: zr
  complex(kind=sp) :: zr2

  pi = 3.141592653589793_sp
  ci = cmplx ( 0.0_sp, 1.0_sp, kind=sp )
  a0 = abs ( z )
  z2 = z * z
  z1 = z

  

  if ( real ( z, kind=sp ) < 0.0_sp ) then
    z1 = -z
  end if

  if ( a0 <= 18.0_sp ) then

    cbi0 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, 50
      cr = 0.25_sp * cr * z2 / ( k * k )
      cbi0 = cbi0 + cr
      if ( abs ( cr / cbi0 ) < 1.0e-15_sp ) then
        exit
      end if
    end do

    cbi1 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, 50
      cr = 0.25_sp * cr * z2 / ( k * ( k + 1 ) )
      cbi1 = cbi1 + cr
      if ( abs ( cr / cbi1 ) < 1.0e-15_sp ) then
        exit
      end if
    end do

    cbi1 = 0.5_sp * z1 * cbi1

  else

    if ( a0 < 35.0_sp ) then
      k0 = 12
    else if ( a0 < 50.0_sp ) then
      k0 = 9
    else
      k0 = 7
    end if

    ca = exp ( z1 ) / sqrt ( 2.0_sp * pi * z1 )
    cbi0 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    zr = 1.0_sp / z1
    do k = 1, k0
      cbi0 = cbi0 + a(k) * zr ** k !! cbi0n, n=1,...8, for Sum(cbi01,cbi02, ....cbi08
    end do
    cbi0 = ca * cbi0
    cbi1 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, k0
      cbi1 = cbi1 + b(k) * zr ** k
    end do
    cbi1 = ca * cbi1

  end if

  if ( a0 <= 9.0_sp ) then

    cs = cmplx ( 0.0_sp, 0.0_sp, kind=sp )
    ct = - log ( 0.5_sp * z1 ) - 0.5772156649015329_sp
    w0 = 0.0_sp
    cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, 50
      w0 = w0 + 1.0_sp / k
      cr = 0.25_sp * cr / ( k * k ) * z2
      cs = cs + cr * ( w0 + ct )
      if ( abs ( ( cs - cw ) / cs ) < 1.0e-15_sp ) then
        exit
      end if
      cw = cs
    end do

    cbk0 = ct + cs

  else

    cb = 0.5_sp / z1
    zr2 = 1.0_sp / z2
    cbk0 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, 10
      cbk0 = cbk0 + a1(k) * zr2 ** k
    end do
    cbk0 = cb * cbk0 / cbi0

  end if

  cbk1 = ( 1.0_sp / z1 - cbi1 * cbk0 ) / cbi0

  if ( real ( z, kind=sp ) < 0.0_sp ) then

    if ( imag ( z ) < 0.0_sp ) then
      cbk0 = cbk0 + ci * pi * cbi0
      cbk1 = - cbk1 + ci * pi * cbi1
    else
      cbk0 = cbk0 - ci * pi * cbi0
      cbk1 = - cbk1 - ci * pi * cbi1
    end if

    cbi1 = - cbi1

  end if

  cdi0 = cbi1
  cdi1 = cbi0 - 1.0_sp / z * cbi1
  cdk0 = - cbk1
  cdk1 = - cbk0 - 1.0_sp / z * cbk1

  
end subroutine cik01


attributes(device) subroutine ciklv ( v, z, cbiv, cdiv, cbkv, cdkv )

!*****************************************************************************80
!
!! CIKLV: modified Bessel functions Iv(z), Kv(z), complex argument, large order.
!
!  Discussion:
!
!    This procedure computes modified Bessel functions Iv(z) and
!    Kv(z) and their derivatives with a complex argument and a large order.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    31 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) V, the order of Iv(z) and Kv(z).
!
!    Input, complex(kind=sp) Z, the argument.
!
!    Output, real(kind=sp) CBIV, CDIV, CBKV, CDKV, the values of
!    Iv(z), Iv'(z), Kv(z), Kv'(z).
!
  implicit none

  real(kind=sp) :: a(91)
  complex(kind=sp) :: cbiv
  complex(kind=sp) :: cbkv
  complex(kind=sp) :: cdiv
  complex(kind=sp) :: cdkv
  complex(kind=sp) :: ceta
  complex(kind=sp) :: cf(12)
  complex(kind=sp) :: cfi
  complex(kind=sp) :: cfk
  complex(kind=sp) :: csi
  complex(kind=sp) :: csk
  complex(kind=sp) :: ct
  complex(kind=sp) :: ct2
  complex(kind=sp) :: cws
  integer(kind=i4) :: i
  integer(kind=i4) :: k
  integer(kind=i4) :: km
  integer(kind=i4) :: l
  integer(kind=i4) :: l0
  integer(kind=i4) :: lf
  real(kind=sp) :: pi
  real(kind=sp), value :: v
  real(kind=sp) :: v0
  real(kind=sp) :: vr
  complex(kind=sp), value :: z

  pi = 3.141592653589793_sp
  km = 12
  call cjk ( km, a )

  do l = 1, 0, -1

    v0 = v - l
    cws = sqrt ( 1.0_sp + ( z / v0 ) * ( z / v0 ) )
    ceta = cws + log ( z / v0 / ( 1.0_sp + cws ) )
    ct = 1.0_sp / cws
    ct2 = ct * ct
    do k = 1, km
      l0 = k * ( k + 1 ) / 2 + 1
      lf = l0 + k
      cf(k) = a(lf)
      do i = lf - 1, l0, -1
        cf(k) = cf(k) * ct2 + a(i)
      end do
      cf(k) = cf(k) * ct ** k
    end do
    vr = 1.0_sp / v0
    csi = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, km
      csi = csi + cf(k) * vr ** k
    end do
    cbiv = sqrt ( ct / ( 2.0_sp * pi * v0 ) ) * exp ( v0 * ceta ) * csi
    if ( l == 1 ) then
      cfi = cbiv
    end if
    csk = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, km
      csk = csk + ( - 1 ) ** k * cf(k) * vr ** k
    end do
    cbkv = sqrt ( pi * ct / ( 2.0_sp * v0 ) ) * exp ( - v0 * ceta ) * csk

    if ( l == 1 ) then
      cfk = cbkv
    end if

  end do

  cdiv =   cfi - v / z * cbiv
  cdkv = - cfk - v / z * cbkv

  
end subroutine ciklv


attributes(device) subroutine ciknb ( n, z, nm, cbi, cdi, cbk, cdk )

!*****************************************************************************80
!
!! CIKNB computes complex modified Bessel functions In(z) and Kn(z).
!
!  Discussion:
!
!    This procedure also evaluates the derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    30 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order of In(z) and Kn(z).
!
!    Input, complex(kind=sp) ::  Z, the argument.
!
!    Output, integer(kind=i4) :: NM, the highest order computed.
!
!    Output, complex(kind=sp) ::  CB((0:N), CDI(0:N), CBK(0:N), CDK(0:N), 
!    the values of In(z), In'(z), Kn(z), Kn'(z).
!
  implicit none

  integer(kind=i4), value :: n

  real(kind=sp) ::  a0
  complex(kind=sp) ::  c
  complex(kind=sp) ::  ca0
  complex(kind=sp) ::  cbi(0:n)
  complex(kind=sp) ::  cbkl
  complex(kind=sp) ::  cbs
  complex(kind=sp) ::  cdi(0:n)
  complex(kind=sp) ::  cbk(0:n)
  complex(kind=sp) ::  cdk(0:n)
  complex(kind=sp) ::  cf
  complex(kind=sp) ::  cf0
  complex(kind=sp) ::  cf1
  complex(kind=sp) ::  cg
  complex(kind=sp) ::  cg0
  complex(kind=sp) ::  cg1
  complex(kind=sp) ::  ci
  complex(kind=sp) ::  cr
  complex(kind=sp) ::  cs0
  complex(kind=sp) ::  csk0
  real(kind=sp) ::  el
  real(kind=sp) ::  fac
  integer(kind=i4) :: k
  integer(kind=i4) :: k0
  integer(kind=i4) :: l
  integer(kind=i4) :: m
  integer(kind=i4) :: nm
  real(kind=sp) ::  pi
  real(kind=sp) ::  vt
  complex(kind=sp), value ::  z
  complex(kind=sp) ::  z1

  pi = 3.141592653589793_sp
  el = 0.57721566490153_sp
  a0 = abs ( z )
  nm = n

  

  ci = cmplx ( 0.0_sp, 1.0_sp, kind=sp )

  if ( real ( z, kind=sp ) < 0.0_sp ) then
    z1 = -z
  else
    z1 = z
  end if

  if ( n == 0 ) then
    nm = 1
  end if

  m = msta1 ( a0, 200 )

  if ( m < nm ) then
    nm = m
  else
    m = msta2 ( a0, nm, 15 )
  end if

  cbs = 0.0_sp
  csk0 = 0.0_sp
  cf0 = 0.0_sp
  cf1 = huge(1.0_sp,kind=sp)

  do k = m, 0, -1
    cf = 2.0_sp * ( k + 1.0_sp ) * cf1 / z1 + cf0
    if ( k <= nm ) then
      cbi(k) = cf
    end if
    if ( k /= 0 .and. k == 2 * int ( k / 2 ) ) then
      csk0 = csk0 + 4.0_sp * cf / k
    end if
    cbs = cbs + 2.0_sp * cf
    cf0 = cf1
    cf1 = cf
  end do

  cs0 = exp ( z1 ) / ( cbs - cf )

  do k = 0, nm
    cbi(k) = cs0 * cbi(k)
  end do

  if ( a0 <= 9.0_sp ) then

    cbk(0) = - ( log ( 0.5_sp * z1 ) + el ) * cbi(0) + cs0 * csk0
    cbk(1) = ( 1.0_sp / z1 - cbi(1) * cbk(0) ) / cbi(0)

  else

    ca0 = sqrt ( pi / ( 2.0_sp * z1 ) ) * exp ( -z1 )

    if ( a0 < 25.0_sp ) then
      k0 = 16
    else if ( a0 < 80.0_sp ) then
      k0 = 10
    else if ( a0 < 200.0_sp ) then
      k0 = 8
    else
      k0 = 6
    end if

    do l = 0, 1
      cbkl = 1.0_sp
      vt = 4.0_sp * l
      cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
      do k = 1, k0
        cr = 0.125_sp * cr &
          * ( vt - ( 2.0_sp * k - 1.0_sp ) ** 2 ) / ( k * z1 )
        cbkl = cbkl + cr
      end do
      cbk(l) = ca0 * cbkl
    end do
  end if

  cg0 = cbk(0)
  cg1 = cbk(1)
  do k = 2, nm
    cg = 2.0_sp * ( k - 1.0_sp ) / z1 * cg1 + cg0
    cbk(k) = cg
    cg0 = cg1
    cg1 = cg
  end do

  if ( real ( z, kind=sp ) < 0.0_sp ) then
    fac = 1.0_sp
    do k = 0, nm
      if ( imag ( z ) < 0.0_sp ) then
        cbk(k) = fac * cbk(k) + ci * pi * cbi(k)
      else
        cbk(k) = fac * cbk(k) - ci * pi * cbi(k)
      end if
      cbi(k) = fac * cbi(k)
      fac = - fac
    end do
  end if

  cdi(0) = cbi(1)
  cdk(0) = -cbk(1)
  do k = 1, nm
    cdi(k) = cbi(k-1) - k / z * cbi(k)
    cdk(k) = - cbk(k-1) - k / z * cbk(k)
  end do

end subroutine ciknb


attributes(device) subroutine cikva ( v, z, vm, cbi, cdi, cbk, cdk )

!*****************************************************************************80
!
!! CIKVA: modified Bessel functions Iv(z), Kv(z), arbitrary order, complex.
!
!  Discussion:
!
!    Compute the modified Bessel functions Iv(z), Kv(z)
!    and their derivatives for an arbitrary order and
!    complex argument
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    31 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:       
!
!    Input, real(kind=sp) ::  V, the order of the functions.
!
!    Input, complex(kind=sp) ::  Z, the argument.
!
!    Output, real(kind=sp) ::  VM, the highest order computed.
!
!    Output, real(kind=sp) ::  CBI(0:N), CDI(0:N), CBK(0:N), CDK(0:N),
!    the values of In+v0(z), In+v0'(z), Kn+v0(z), Kn+v0'(z).
!
  implicit none

  real(kind=sp) ::  a0
  complex(kind=sp) ::  ca
  complex(kind=sp) ::  ca1
  complex(kind=sp) ::  ca2
  complex(kind=sp) ::  cb
  complex(kind=sp) ::  cbi(0:*)
  complex(kind=sp) ::  cbi0
  complex(kind=sp) ::  cdi(0:*)
  complex(kind=sp) ::  cbk(0:*)
  complex(kind=sp) ::  cbk0
  complex(kind=sp) ::  cbk1
  complex(kind=sp) ::  cdk(0:*)
  complex(kind=sp) ::  cf
  complex(kind=sp) ::  cf1
  complex(kind=sp) ::  cf2
  complex(kind=sp) ::  cg0
  complex(kind=sp) ::  cg1
  complex(kind=sp) ::  cgk
  complex(kind=sp) ::  ci
  complex(kind=sp) ::  ci0
  complex(kind=sp) ::  cp
  complex(kind=sp) ::  cr
  complex(kind=sp) ::  cr1
  complex(kind=sp) ::  cr2
  complex(kind=sp) ::  cs
  complex(kind=sp) ::  csu
  complex(kind=sp) ::  ct
  complex(kind=sp) ::  cvk
  real(kind=sp) ::  gan
  real(kind=sp) ::  gap
  integer(kind=i4) :: k
  integer(kind=i4) :: k0
  integer(kind=i4) :: m
  
  integer(kind=i4) :: n
  real(kind=sp) ::  pi
  real(kind=sp) ::  piv
  real(kind=sp), value ::  v
  real(kind=sp) ::  v0
  real(kind=sp) ::  v0n
  real(kind=sp) ::  v0p
  real(kind=sp) ::  vm
  real(kind=sp) ::  vt
  real(kind=sp) ::  w0
  real(kind=sp) ::  ws
  real(kind=sp) ::  ws0
  complex(kind=sp), value ::  z
  complex(kind=sp) ::  z1
  complex(kind=sp) ::  z2

  pi = 3.141592653589793_sp
  ci = cmplx ( 0.0_sp, 1.0_sp, kind=sp )
  a0 = abs ( z )
  z1 = z
  z2 = z * z
  n = int ( v )
  v0 = v - n
  piv = pi * v0
  vt = 4.0_sp * v0 * v0

  if ( n == 0 ) then
    n = 1
  end if

  
  if ( a0 < 35.0_sp ) then
    k0 = 14
  else if ( a0 < 50.0_sp ) then
    k0 = 10
  else
    k0 = 8
  end if

  if ( real ( z, kind=sp ) < 0.0_sp ) then
    z1 = -z
  end if

  if ( a0 < 18.0_sp ) then

    if ( v0 == 0.0_sp ) then
      ca1 = cmplx (1.0_sp, 0.0_sp, kind=sp )
    else
      v0p = 1.0_sp + v0
      call gamma ( v0p, gap )
      ca1 = ( 0.5_sp * z1 ) ** v0 / gap
    end if

    ci0 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, 50
      cr = 0.25_sp * cr * z2 / ( k * ( k + v0 ) )
      ci0 = ci0 + cr
      if ( abs ( cr ) < abs ( ci0 ) * 1.0e-15_sp ) then
        exit
      end if
    end do

    cbi0 = ci0 * ca1

  else

    ca = exp ( z1 ) / sqrt ( 2.0_sp * pi * z1 )
    cs = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, k0
      cr = - 0.125_sp * cr &
        * ( vt - ( 2.0_sp * k - 1.0_sp ) ** 2 ) / ( k * z1 )
      cs = cs + cr
    end do
    cbi0 = ca * cs

  end if

  m = msta1 ( a0, 200 )

  if ( m < n ) then
     n = m
  else
     m = msta2 ( a0, n, 15 )
  end if

  cf2 = cmplx ( 0.0_sp, 0.0_sp, kind=sp )
  cf1 = cmplx ( 1.0e-30_sp, 0.0_sp, kind=sp )
  do k = m, 0, -1
    cf = 2.0_sp * ( v0 + k + 1.0_sp ) / z1 * cf1 + cf2
    if ( k <= n ) then
      cbi(k) = cf
    end if
    cf2 = cf1
    cf1 = cf
  end do

  cs = cbi0 / cf
  do k = 0, n
    cbi(k) = cs * cbi(k)
  end do

  if ( a0 <= 9.0_sp ) then

    if ( v0 == 0.0_sp ) then
      ct = - log ( 0.5_sp * z1 ) - 0.5772156649015329_sp
      cs = cmplx ( 0.0_sp, 0.0_sp, kind=sp )
      w0 = 0.0_sp
      cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
      do k = 1, 50
        w0 = w0 + 1.0_sp / k
        cr = 0.25_sp * cr / ( k * k ) * z2
        cp = cr * ( w0 + ct )
        cs = cs + cp
        if ( 10 <= k .and. abs ( cp / cs ) < 1.0e-15_sp ) then
          exit
        end if
      end do

      cbk0 = ct + cs

    else

      v0n = 1.0_sp - v0
      call gamma ( v0n, gan )
      ca2 = 1.0_sp / ( gan * ( 0.5_sp * z1 ) ** v0 )
      ca1 = ( 0.5_sp * z1 ) ** v0 / gap
      csu = ca2 - ca1
      cr1 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
      cr2 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
      do k = 1, 50
        cr1 = 0.25_sp * cr1 * z2 / ( k * ( k - v0 ) )
        cr2 = 0.25_sp * cr2 * z2 / ( k * ( k + v0 ) )
        csu = csu + ca2 * cr1 - ca1 * cr2
        ws = abs ( csu )
        if ( 10 <= k .and. abs ( ws - ws0 ) / ws < 1.0e-15_sp ) then
          exit
        end if
        ws0 = ws
      end do

      cbk0 = 0.5_sp * pi * csu / sin ( piv )

    end if

  else

    cb = exp ( - z1 ) * sqrt ( 0.5_sp * pi / z1 )
    cs = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, k0
      cr = 0.125_sp * cr &
        * ( vt - ( 2.0_sp * k - 1.0_sp ) ** 2 ) / ( k * z1 )
      cs = cs + cr
    end do
    cbk0 = cb * cs

  end if

  cbk1 = ( 1.0_sp / z1 - cbi(1) * cbk0 ) / cbi(0)
  cbk(0) = cbk0
  cbk(1) = cbk1
  cg0 = cbk0
  cg1 = cbk1

  do k = 2, n
    cgk = 2.0_sp * ( v0 + k - 1.0_sp ) / z1 * cg1 + cg0
    cbk(k) = cgk
    cg0 = cg1
    cg1 = cgk
  end do

  if ( real ( z, kind=sp ) < 0.0_sp ) then
    do k = 0, n
      cvk = exp ( ( k + v0 ) * pi * ci )
      if ( imag ( z ) < 0.0_sp ) then
        cbk(k) = cvk * cbk(k) + pi * ci * cbi(k)
        cbi(k) = cbi(k) / cvk
      else if ( 0.0_sp < imag ( z ) ) then
        cbk(k) = cbk(k) / cvk - pi * ci * cbi(k)
        cbi(k) = cvk * cbi(k)
      end if
    end do
  end if

  cdi(0) = v0 / z * cbi(0) + cbi(1)
  cdk(0) = v0 / z * cbk(0) - cbk(1)
  do k = 1, n
    cdi(k) = - ( k + v0 ) / z * cbi(k) + cbi(k-1)
    cdk(k) = - ( k + v0 ) / z * cbk(k) - cbk(k-1)
  end do

  vm = n + v0
  
end subroutine cikva


attributes(device) subroutine cisia ( x, ci, si )

!*****************************************************************************80
!
!! CISIA computes cosine Ci(x) and sine integrals Si(x).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    03 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument of Ci(x) and Si(x).
!
!    Output, real(kind=sp) ::  CI, SI, the values of Ci(x) and Si(x).
!
  implicit none

  real(kind=sp) ::  bj(101)
  real(kind=sp) ::  ci
  real(kind=sp) ::  el
  real(kind=sp) ::  eps
  integer(kind=i4) :: k
  integer(kind=i4) :: m
  real(kind=sp) ::  p2
  real(kind=sp) ::  si
  real(kind=sp) ::  x
  real(kind=sp) ::  x2
  real(kind=sp) ::  xa
  real(kind=sp) ::  xa0
  real(kind=sp) ::  xa1
  real(kind=sp) ::  xcs
  real(kind=sp) ::  xf
  real(kind=sp) ::  xg
  real(kind=sp) ::  xg1
  real(kind=sp) ::  xg2
  real(kind=sp) ::  xr
  real(kind=sp) ::  xs
  real(kind=sp) ::  xss

  p2 = 1.570796326794897_sp
  el = 0.5772156649015329_sp
  eps = 1.0e-15_sp
  x2 = x * x

  if ( x == 0.0_sp ) then

    ci = -huge(1.0_sp,kind=sp)
    si = 0.0_sp

  else if ( x <= 16.0_sp ) then

    xr = -0.25_sp * x2
    ci = el + log ( x ) + xr
    do k = 2, 40
      xr = -0.5_sp * xr * ( k - 1 ) / ( k * k * ( 2 * k - 1 ) ) * x2
      ci = ci + xr
      if ( abs ( xr ) < abs ( ci ) * eps ) then
        exit
      end if
    end do

    xr = x
    si = x
    do k = 1, 40
      xr = -0.5_sp * xr * ( 2 * k - 1 ) / k / ( 4 * k * k + 4 * k + 1 ) * x2
      si = si + xr
      if ( abs ( xr ) < abs ( si ) * eps ) then
        return
      end if
    end do

  else if ( x <= 32.0_sp ) then

    m = int ( 47.2_sp + 0.82_sp * x )
    xa1 = 0.0_sp
    xa0 = tiny(1.0_sp,kind=sp)
    do k = m, 1, -1
      xa = 4.0_sp * k * xa0 / x - xa1
      bj(k) = xa
      xa1 = xa0
      xa0 = xa
    end do
    xs = bj(1)
    do k = 3, m, 2
      xs = xs + 2.0_sp * bj(k)
    end do
    bj(1) = bj(1) / xs
    do k = 2, m
      bj(k) = bj(k) / xs
    end do
    xr = 1.0_sp
    xg1 = bj(1)
    do k = 2, m
      xr = 0.25_sp * xr * ( 2.0_sp * k - 3.0_sp ) **2 &
        / ( ( k - 1.0_sp ) * ( 2.0_sp * k - 1.0_sp ) ** 2 ) * x
      xg1 = xg1 + bj(k) * xr
    end do

    xr = 1.0_sp
    xg2 = bj(1)
    do k = 2, m
      xr = 0.25_sp * xr * ( 2.0_sp * k - 5.0_sp )**2 &
        / ( ( k-1.0_sp ) * ( 2.0_sp * k - 3.0_sp ) ** 2 ) * x
      xg2 = xg2 + bj(k) * xr
    end do

    xcs = cos ( x / 2.0_sp )
    xss = sin ( x / 2.0_sp )
    ci = el + log ( x ) - x * xss * xg1 + 2.0 * xcs * xg2 - 2.0 * xcs * xcs
    si = x * xcs * xg1 + 2.0 * xss * xg2 - sin ( x )

  else

    xr = 1.0_sp
    xf = 1.0_sp
    do k = 1, 9
      xr = -2.0_sp * xr * k * ( 2 * k - 1 ) / x2
      xf = xf + xr
    end do
    xr = 1.0_sp / x
    xg = xr
    do k = 1, 8
      xr = -2.0_sp * xr * ( 2 * k + 1 ) * k / x2
      xg = xg + xr
    end do
    ci = xf * sin ( x ) / x - xg * cos ( x ) / x
    si = p2 - xf * cos ( x ) / x - xg * sin ( x ) / x

  end if

end subroutine cisia


attributes(device) subroutine cisib ( x, ci, si )

!*****************************************************************************80
!
!! CISIB computes cosine and sine integrals.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    20 March 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument of Ci(x) and Si(x).
!
!    Output, real(kind=sp) ::  CI, SI, the values of Ci(x) and Si(x).
!
  implicit none

  real(kind=sp) ::  ci
  real(kind=sp) ::  fx
  real(kind=sp) ::  gx
  real(kind=sp) ::  si
  real(kind=sp), value ::  x
  real(kind=sp) ::  x2

  x2 = x * x

  if ( x == 0.0_sp ) then

    ci = -huge(1.0_sp,kind=sp)
    si = 0.0_sp

  else if ( x <= 1.0_sp ) then

    ci = (((( -3.0e-08_sp        * x2 &
             + 3.10e-06_sp     ) * x2 &
             - 2.3148e-04_sp   ) * x2 &
             + 1.041667e-02_sp ) * x2 &
             - 0.25_sp     ) * x2 + 0.577215665_sp + log ( x )

     si = (((( 3.1e-07_sp        * x2 &
             - 2.834e-05_sp    ) * x2 &
             + 1.66667e-03_sp  ) * x2 &
             - 5.555556e-02_sp ) * x2 + 1.0_sp ) * x

  else

    fx = (((( x2              &
      + 38.027264_sp  ) * x2 &
      + 265.187033_sp ) * x2 &
      + 335.67732_sp  ) * x2 &
      + 38.102495_sp  ) /    &
      (((( x2                 &
      + 40.021433_sp  ) * x2 &
      + 322.624911_sp ) * x2 &
      + 570.23628_sp  ) * x2 &
      + 157.105423_sp )

    gx = (((( x2               &
      + 42.242855_sp  ) * x2  &
      + 302.757865_sp ) * x2  &
      + 352.018498_sp ) * x2  &
      + 21.821899_sp ) /      &
      (((( x2                  &
      + 48.196927_sp   ) * x2 &
      + 482.485984_sp  ) * x2 &
      + 1114.978885_sp ) * x2 &
      + 449.690326_sp  ) / x

    ci = fx * sin ( x ) / x - gx * cos ( x ) / x

    si = 1.570796327_sp - fx * cos ( x ) / x - gx * sin ( x ) / x

  end if

  
end subroutine cisib


attributes(device) subroutine cjy01 ( z, cbj0, cdj0, cbj1, cdj1, cby0, cdy0, cby1, cdy1 )

!*****************************************************************************80
!
!! CJY01: complexBessel functions, derivatives, J0(z), J1(z), Y0(z), Y1(z).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    02 August 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
! 
!  Parameters:
!
!    Input, complex(kind=sp) ::  Z, the argument.
!
!    Output, complex(kind=sp) ::  CBJ0, CDJ0, CBJ1, CDJ1, CBY0, CDY0, CBY1, 
!    CDY1, the values of J0(z), J0'(z), J1(z), J1'(z), Y0(z), Y0'(z), 
!    Y1(z), Y1'(z).
!
  implicit none

  real(kind=sp)  ,  dimension ( 12 ) :: a = (/ &
    -0.703125e-01,0.112152099609375_sp, &
    -0.5725014209747314_sp,0.6074042001273483e+01, &
    -0.1100171402692467e+03,0.3038090510922384e+04, &
    -0.1188384262567832e+06,0.6252951493434797e+07, &
    -0.4259392165047669e+09,0.3646840080706556e+11, &
    -0.3833534661393944e+13,0.4854014686852901e+15 /)
  real(kind=sp) ::  a0
  real(kind=sp)  ,  dimension ( 12 ) :: a1 = (/ &
    0.1171875_sp,-0.144195556640625_sp, &
    0.6765925884246826_sp,-0.6883914268109947e+01, &
    0.1215978918765359e+03,-0.3302272294480852e+04, &
    0.1276412726461746e+06,-0.6656367718817688e+07, &
    0.4502786003050393e+09,-0.3833857520742790e+11, &
    0.4011838599133198e+13,-0.5060568503314727e+15 /)
  real(kind=sp)  ,  dimension ( 12 ) :: b = (/ &
    0.732421875e-01,-0.2271080017089844_sp, &
    0.1727727502584457e+01,-0.2438052969955606e+02, &
    0.5513358961220206e+03,-0.1825775547429318e+05, &
    0.8328593040162893e+06,-0.5006958953198893e+08, &
    0.3836255180230433e+10,-0.3649010818849833e+12, &
    0.4218971570284096e+14,-0.5827244631566907e+16 /)
  real(kind=sp)  ,  dimension ( 12 ) :: b1 = (/ &
    -0.1025390625_sp,0.2775764465332031_sp, &
    -0.1993531733751297e+01,0.2724882731126854e+02, &
    -0.6038440767050702e+03,0.1971837591223663e+05, &
    -0.8902978767070678e+06,0.5310411010968522e+08, &
    -0.4043620325107754e+10,0.3827011346598605e+12, &
    -0.4406481417852278e+14,0.6065091351222699e+16 /)
  complex(kind=sp) ::  cbj0
  complex(kind=sp) ::  cbj1
  complex(kind=sp) ::  cby0
  complex(kind=sp) ::  cby1
  complex(kind=sp) ::  cdj0
  complex(kind=sp) ::  cdj1
  complex(kind=sp) ::  cdy0
  complex(kind=sp) ::  cdy1
  complex(kind=sp) ::  ci
  complex(kind=sp) ::  cp
  complex(kind=sp) ::  cp0
  complex(kind=sp) ::  cp1
  complex(kind=sp) ::  cq0
  complex(kind=sp) ::  cq1
  complex(kind=sp) ::  cr
  complex(kind=sp) ::  cs
  complex(kind=sp) ::  ct1
  complex(kind=sp) ::  ct2
  complex(kind=sp) ::  cu
  real(kind=sp) ::  el
  integer(kind=i4) :: k
  integer(kind=i4) :: k0
  real(kind=sp) ::  pi
  real(kind=sp) ::  rp2
  real(kind=sp) ::  w0
  real(kind=sp) ::  w1
  complex(kind=sp), value ::  z
  complex(kind=sp) ::  z1
  complex(kind=sp) ::  z2

  pi = 3.141592653589793_sp
  el = 0.5772156649015329_sp
  rp2 = 2.0_sp / pi
  ci = cmplx ( 0.0_sp, 1.0_sp )
  a0 = abs ( z )
  z2 = z * z
  z1 = z

  !if ( a0 .eq. 0.0_sp ) then
  !  cbj0 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
  !  cbj1 = cmplx ( 0.0_sp, 0.0_sp, kind=sp )
  !  cdj0 = cmplx ( 0.0_sp, 0.0_sp, kind=sp )
  !  cdj1 = cmplx ( 0.5_sp, 0.0_sp, kind=sp )
  !  cby0 = - cmplx ( 1.0e+30, 0.0_sp, kind=sp )
  !  cby1 = - cmplx ( 1.0e+30, 0.0_sp, kind=sp )
  !  cdy0 = cmplx ( 1.0e+30, 0.0_sp, kind=sp )
  !  cdy1 = cmplx ( 1.0e+30, 0.0_sp, kind=sp )
  !  return
  !end if

  if ( real ( z, kind=sp ) < 0.0_sp ) then
    z1 = -z
  end if

  if ( a0 .le. 12.0_sp ) then

    cbj0 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, 40
      cr = -0.25_sp * cr * z2 / ( k * k )
      cbj0 = cbj0 + cr
      if ( abs ( cr ) < abs ( cbj0 ) * 1.0e-15_sp ) then
        exit
      end if
    end do

    cbj1 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, 40
      cr = -0.25_sp * cr * z2 / ( k * ( k + 1.0_sp ) )
      cbj1 = cbj1 + cr
      if ( abs ( cr ) < abs ( cbj1 ) * 1.0e-15_sp ) then
        exit
      end if
    end do

    cbj1 = 0.5_sp * z1 * cbj1
    w0 = 0.0_sp
    cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    cs = cmplx ( 0.0_sp, 0.0_sp, kind=sp )
    do k = 1, 40
      w0 = w0 + 1.0_sp / k
      cr = -0.25_sp * cr / ( k * k ) * z2
      cp = cr * w0
      cs = cs + cp
      if ( abs ( cp ) < abs ( cs ) * 1.0e-15_sp ) then
        exit
      end if
    end do

    cby0 = rp2 * ( log ( z1 / 2.0_sp ) + el ) * cbj0 - rp2 * cs
    w1 = 0.0_sp
    cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    cs = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, 40
      w1 = w1 + 1.0_sp / k
      cr = -0.25_sp * cr / ( k * ( k + 1 ) ) * z2
      cp = cr * ( 2.0_sp * w1 + 1.0_sp / ( k + 1.0_sp ) )
      cs = cs + cp
      if ( abs ( cp ) < abs ( cs ) * 1.0e-15_sp ) then
        exit
      end if
    end do

    cby1 = rp2 * ( ( log ( z1 / 2.0_sp ) + el ) * cbj1 &
      - 1.0_sp / z1 - 0.25_sp * z1 * cs )

  else

    if ( a0 < 35.0_sp ) then
      k0 = 12
    else if ( a0 < 50.0_sp ) then
      k0 = 10
    else
      k0 = 8
    end if

    ct1 = z1 - 0.25_sp * pi
    cp0 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, k0
      cp0 = cp0 + a(k) * z1 ** ( - 2 * k )
    end do
    cq0 = -0.125_sp / z1
    do k = 1, k0
      cq0 = cq0 + b(k) * z1 ** ( - 2 * k - 1 )
    end do
    cu = sqrt ( rp2 / z1 )
    cbj0 = cu * ( cp0 * cos ( ct1 ) - cq0 * sin ( ct1 ) )
    cby0 = cu * ( cp0 * sin ( ct1 ) + cq0 * cos ( ct1 ) )
    ct2 = z1 - 0.75_sp * pi
    cp1 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, k0
      cp1 = cp1 + a1(k) * z1 ** ( - 2 * k )
    end do
    cq1 = 0.375_sp / z1
    do k = 1, k0
      cq1 = cq1 + b1(k) * z1 ** ( - 2 * k - 1 )
    end do
    cbj1 = cu * ( cp1 * cos ( ct2 ) - cq1 * sin ( ct2 ) )
    cby1 = cu * ( cp1 * sin ( ct2 ) + cq1 * cos ( ct2 ) )

  end if

  if ( real ( z, kind=sp ) < 0.0_sp ) then
    if ( imag ( z ) < 0.0_sp ) then
      cby0 = cby0 - 2.0_sp * ci * cbj0
      cby1 = - ( cby1 - 2.0_sp * ci * cbj1 )
    else
      cby0 = cby0 + 2.0_sp * ci * cbj0
      cby1 = - ( cby1 + 2.0_sp * ci * cbj1 )
    end if
    cbj1 = -cbj1
  end if

  cdj0 = -cbj1
  cdj1 = cbj0 - 1.0_sp / z * cbj1
  cdy0 = -cby1
  cdy1 = cby0 - 1.0_sp / z * cby1

end subroutine cjy01


attributes(device) subroutine cjylv ( v, z, cbjv, cdjv, cbyv, cdyv )

!*****************************************************************************80
!
!! CJYLV: Bessel functions Jv(z), Yv(z) of complex argument and large order v.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    25 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  V, the order of Jv(z) and Yv(z).
!
!    Input, complex(kind=sp) ::  Z, the argument.
!
!    Output, complex(kind=sp) ::  CBJV, CDJV, CBYV, CDYV, the values of Jv(z), 
!    Jv'(z), Yv(z), Yv'(z).
!
  implicit none

  real(kind=sp) ::  a(91)
  complex(kind=sp) ::  cbjv
  complex(kind=sp) ::  cbyv
  complex(kind=sp) ::  cdjv
  complex(kind=sp) ::  cdyv
  complex(kind=sp) ::  ceta
  complex(kind=sp) ::  cf(12)
  complex(kind=sp) ::  cfj
  complex(kind=sp) ::  cfy
  complex(kind=sp) ::  csj
  complex(kind=sp) ::  csy
  complex(kind=sp) ::  ct
  complex(kind=sp) ::  ct2
  complex(kind=sp) ::  cws
  integer(kind=i4) :: i
  integer(kind=i4) :: k
  integer(kind=i4) :: km
  integer(kind=i4) :: l
  integer(kind=i4) :: l0
  integer(kind=i4) :: lf
  real(kind=sp) ::  pi
  real(kind=sp) ::  v
  real(kind=sp) ::  v0
  real(kind=sp) ::  vr
  complex(kind=sp) ::  z

  km = 12
  call cjk ( km, a )
  pi = 3.141592653589793_sp

  do l = 1, 0, -1

    v0 = v - l
    cws = sqrt ( 1.0_sp - ( z / v0 ) * ( z / v0 ) )
    ceta = cws + log ( z / v0 / ( 1.0_sp + cws ) )
    ct = 1.0_sp / cws
    ct2 = ct * ct

    do k = 1, km
      l0 = k * ( k + 1 ) / 2 + 1
      lf = l0 + k
      cf(k) = a(lf)
      do i = lf - 1, l0, -1
        cf(k) = cf(k) * ct2 + a(i)
      end do
      cf(k) = cf(k) * ct ** k
    end do

    vr = 1.0_sp / v0
    csj = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, km
      csj = csj + cf(k) * vr ** k
    end do
    cbjv = sqrt ( ct / ( 2.0_sp * pi * v0 ) ) * exp ( v0 * ceta ) * csj
    if ( l == 1 ) then
      cfj = cbjv
    end if
    csy = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, km
      csy = csy + ( -1.0_sp ) ** k * cf(k) * vr ** k
    end do
    cbyv = - sqrt ( 2.0_sp * ct / ( pi * v0 ) ) * exp ( - v0 * ceta ) * csy
    if ( l == 1 ) then
      cfy = cbyv
    end if

  end do

  cdjv = - v / z * cbjv + cfj
  cdyv = - v / z * cbyv + cfy

 
end subroutine cjylv


attributes(device) subroutine comelp ( hk, ck, ce )

!*****************************************************************************80
!
!! COMELP computes complete elliptic integrals K(k) and E(k).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    07 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  HK, the modulus.  0 <= HK <= 1.
!
!    Output, real(kind=sp) ::  CK, CE, the values of K(HK) and E(HK).
!
  implicit none

  real(kind=sp) ::  ae
  real(kind=sp) ::  ak
  real(kind=sp) ::  be
  real(kind=sp) ::  bk
  real(kind=sp) ::  ce
  real(kind=sp) ::  ck
  real(kind=sp) ::  hk
  real(kind=sp) ::  pk

  pk = 1.0_sp - hk * hk

  if ( hk == 1.0_sp ) then

    ck = huge(1.0_sp,kind=sp)
    ce = 1.0_sp

  else

    ak = ((( &
        0.01451196212_sp   * pk &
      + 0.03742563713_sp ) * pk &
      + 0.03590092383_sp ) * pk &
      + 0.09666344259_sp ) * pk &
      + 1.38629436112_sp

    bk = ((( &
        0.00441787012_sp   * pk &
      + 0.03328355346_sp ) * pk &
      + 0.06880248576_sp ) * pk &
      + 0.12498593597_sp ) * pk &
      + 0.5_sp

    ck = ak - bk * log ( pk )

    ae = ((( &
        0.01736506451_sp   * pk &
      + 0.04757383546_sp ) * pk &
      + 0.0626060122_sp  ) * pk &
      + 0.44325141463_sp ) * pk &
      + 1.0_sp

    be = ((( &
        0.00526449639_sp   * pk &
      + 0.04069697526_sp ) * pk &
      + 0.09200180037_sp ) * pk &
      + 0.2499836831_sp  ) * pk

    ce = ae - be * log ( pk )

  end if

  
end subroutine comelp


attributes(device) subroutine cpdla ( n, z, cdn )

!****************************************************************************80
!
!! CPDLA computes complex parabolic cylinder function Dn(z) for large argument.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    07 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer N, the order.
!
!    Input, complex(kind=sp) ::  Z, the argument.
!
!    Output, complex(kind=sp) ::  CDN, the function value.
!
  implicit none

  complex(kind=sp) ::  cb0
  complex(kind=sp) ::  cdn
  complex(kind=sp) ::  cr
  integer(kind=i4) :: k
  integer(kind=i4) :: n
  complex(kind=sp) ::  z

  cb0 = z ** n * exp ( -0.25_sp * z * z )
  cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
  cdn = cmplx ( 1.0_sp, 0.0_sp, kind=sp )

  do k = 1, 16

    cr = -0.5_sp * cr * ( 2.0_sp * k - n - 1.0_sp ) &
      * ( 2.0_sp * k - n - 2.0_sp ) / ( k * z * z )

    cdn = cdn + cr

    if ( abs ( cr ) < abs ( cdn ) * 1.0e-12_sp ) then
      exit
    end if

  end do

  cdn = cb0 * cdn

end subroutine cpdla



attributes(device) subroutine cpdsa ( n, z, cdn )

!*****************************************************************************80
!
!! CPDSA computes complex parabolic cylinder function Dn(z) for small argument.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    29 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order.
!
!    Input, complex(kind=sp) ::  Z, the argument.
!
!    Output, complex(kind=sp) ::  CDN, the value of DN(z).
!
  implicit none

  complex(kind=sp) ::  ca0
  complex(kind=sp) ::  cb0
  complex(kind=sp) ::  cdn
  complex(kind=sp) ::  cdw
  complex(kind=sp) ::  cr
  real(kind=sp) ::  eps
  real(kind=sp) ::  g0
  real(kind=sp) ::  g1
  real(kind=sp) ::  ga0
  real(kind=sp) ::  gm
  integer(kind=i4) :: m
  integer(kind=i4), value :: n
  real(kind=sp) ::  pd
  real(kind=sp) ::  pi
  real(kind=sp) ::  sq2
  real(kind=sp) ::  va0
  real(kind=sp) ::  vm
  real(kind=sp) ::  vt
  real(kind=sp) ::  xn
  complex(kind=sp), value ::  z

  eps = 1.0e-15
  pi = 3.141592653589793_sp
  sq2 = sqrt ( 2.0_sp )
  ca0 = exp ( - 0.25_sp * z * z )
  va0 = 0.5_sp * ( 1.0_sp - n )

  if ( n == 0 ) then

    cdn = ca0

  else

    if ( abs ( z ) == 0.0_sp ) then

      if ( va0 <= 0.0_sp .and. va0 == int ( va0 ) ) then
        cdn = 0.0_sp
      else
        call gaih ( va0, ga0 )
        pd = sqrt ( pi ) / ( 2.0_sp ** ( -0.5_sp * n ) * ga0 )
        cdn = cmplx ( pd, 0.0_sp, kind=sp )
      end if

    else

      xn = - n
      call gaih ( xn, g1 )
      cb0 = 2.0_sp ** ( -0.5_sp * n - 1.0_sp ) * ca0 / g1
      vt = -0.5_sp * n
      call gaih ( vt, g0 )
      cdn = cmplx ( g0, 0.0_sp, kind=sp )
      cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )

      do m = 1, 250
        vm = 0.5_sp * ( m - n )
        call gaih ( vm, gm )
        cr = - cr * sq2 * z / m
        cdw = gm * cr
        cdn = cdn + cdw
        if ( abs ( cdw ) < abs ( cdn ) * eps ) then
          exit
        end if
      end do

      cdn = cb0 * cdn

    end if

  end if

end subroutine cpdsa


attributes(device) subroutine cy01 ( kf, z, zf, zd )

!*****************************************************************************80
!
!! CY01 computes complex Bessel functions Y0(z) and Y1(z) and derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    01 August 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer KF, the function choice.
!    0 for ZF = Y0(z) and ZD = Y0'(z);
!    1 for ZF = Y1(z) and ZD = Y1'(z);
!    2 for ZF = Y1'(z) and ZD = Y1''(z).
!
!    Input, complex(kind=sp) ::  Z, the argument.
!
!    Output, complex(kind=sp) ::  ZF, ZD, the values of the requested function 
!    and derivative.
!
  implicit none

  real(kind=sp)  ,  dimension(12) :: a = (/ &
    -0.703125e-01, 0.112152099609375_sp, &
    -0.5725014209747314_sp, 0.6074042001273483e+01_sp, &
    -0.1100171402692467e+03_sp, 0.3038090510922384e+04_sp, &
    -0.1188384262567832e+06_sp, 0.6252951493434797e+07_sp, &
    -0.4259392165047669e+09_sp, 0.3646840080706556e+11_sp, &
    -0.3833534661393944e+13_sp, 0.4854014686852901e+15_sp /)
  real(kind=sp) ::  a0
  real(kind=sp)  ,  dimension(12) :: a1 = (/ &
    0.1171875_sp, -0.144195556640625_sp, &
    0.6765925884246826_sp, -0.6883914268109947e+01_sp, &
    0.1215978918765359e+03_sp, -0.3302272294480852e+04_sp, &
    0.1276412726461746e+06_sp, -0.6656367718817688e+07_sp, &
    0.4502786003050393e+09_sp, -0.3833857520742790e+11_sp, &
    0.4011838599133198e+13_sp, -0.5060568503314727e+15_sp /)
  real(kind=sp)  ,  dimension(12) :: b = (/ &
    0.732421875e-01, -0.2271080017089844_sp, &
    0.1727727502584457e+01_sp, -0.2438052969955606e+02_sp, &
    0.5513358961220206e+03_sp, -0.1825775547429318e+05_sp, &
    0.8328593040162893e+06_sp, -0.5006958953198893e+08_sp, &
    0.3836255180230433e+10_sp, -0.3649010818849833e+12_sp, &
    0.4218971570284096e+14_sp, -0.5827244631566907e+16_sp /)
  real(kind=sp)  ,  dimension(12) :: b1 = (/ &
    -0.1025390625_sp, 0.2775764465332031_sp, &
    -0.1993531733751297e+01_sp, 0.2724882731126854e+02_sp, &
    -0.6038440767050702e+03_sp, 0.1971837591223663e+05_sp, &
    -0.8902978767070678e+06_sp, 0.5310411010968522e+08_sp, &
    -0.4043620325107754e+10_sp, 0.3827011346598605e+12_sp, &
    -0.4406481417852278e+14_sp, 0.6065091351222699e+16_sp /)
  complex(kind=sp) ::  cbj0
  complex(kind=sp) ::  cbj1
  complex(kind=sp) ::  cby0
  complex(kind=sp) ::  cby1
  complex(kind=sp) ::  cdy0
  complex(kind=sp) ::  cdy1
  complex(kind=sp) ::  ci
  complex(kind=sp) ::  cp
  complex(kind=sp) ::  cp0
  complex(kind=sp) ::  cp1
  complex(kind=sp) ::  cq0
  complex(kind=sp) ::  cq1
  complex(kind=sp) ::  cr
  complex(kind=sp) ::  cs
  complex(kind=sp) ::  ct1
  complex(kind=sp) ::  ct2
  complex(kind=sp) ::  cu
  real(kind=sp) ::  el
  integer(kind=i4) :: k
  integer(kind=i4) :: k0
  integer(kind=i4) :: kf
  real(kind=sp) ::  pi
  real(kind=sp) ::  rp2
  real(kind=sp) ::  w0
  real(kind=sp) ::  w1
  complex(kind=sp) ::  z
  complex(kind=sp) ::  z1
  complex(kind=sp) ::  z2
  complex(kind=sp) ::  zd
  complex(kind=sp) ::  zf

  pi = 3.141592653589793_sp
  el = 0.5772156649015329_sp
  rp2 = 2.0_sp / pi
  ci = cmplx ( 0.0_sp, 1.0_sp, kind=sp )
  a0 = abs ( z )
  z2 = z * z
  z1 = z

  if ( a0 == 0.0_sp ) then

    cbj0 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    cbj1 = cmplx ( 0.0_sp, 0.0_sp, kind=sp )
    cby0 = cmplx ( -huge(1.0_sp,kind=sp), 0.0_sp, kind=sp )
    cby1 = cmplx ( -huge(1.0_sp,kind=sp), 0.0_sp, kind=sp )
    cdy0 = cmplx ( huge(1.0_sp,kind=sp), 0.0_sp, kind=sp )
    cdy1 = cmplx ( huge(1.0_sp,kind=sp), 0.0_sp, kind=sp )

  else

    if ( real ( z, kind=sp ) < 0.0_sp) then
      z1 = -z
    end if

    if ( a0 <= 12.0_sp ) then

      cbj0 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
      cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
      do k = 1, 40
        cr = - 0.25_sp * cr * z2 / ( k * k )
        cbj0 = cbj0 + cr
        if ( abs ( cr ) < abs ( cbj0 ) * 1.0e-15_sp ) then
          exit
        end if
      end do

      cbj1 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
      cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
      do k = 1, 40
        cr = -0.25_sp * cr * z2 / ( k * ( k + 1.0_sp ) )
        cbj1 = cbj1 + cr
        if ( abs ( cr ) < abs ( cbj1 ) * 1.0e-15_sp ) then
          exit
        end if
      end do

      cbj1 = 0.5_sp * z1 * cbj1
      w0 = 0.0_sp
      cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
      cs = cmplx ( 0.0_sp, 0.0_sp, kind=sp )
      do k = 1, 40
        w0 = w0 + 1.0_sp / k
        cr = -0.25_sp * cr / ( k * k ) * z2
        cp = cr * w0
        cs = cs + cp
        if ( abs ( cp ) < abs ( cs ) * 1.0e-15_sp ) then
          exit
        end if
      end do

      cby0 = rp2 * ( log ( z1 / 2.0_sp ) + el ) * cbj0 - rp2 * cs
      w1 = 0.0_sp
      cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
      cs = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
      do k = 1, 40
        w1 = w1 + 1.0_sp / k
        cr = - 0.25_sp * cr / ( k * ( k + 1 ) ) * z2
        cp = cr * ( 2.0_sp * w1 + 1.0_sp / ( k + 1.0_sp ) )
        cs = cs + cp
        if ( abs ( cp ) < abs ( cs ) * 1.0e-15_sp ) then
          exit
        end if
      end do

      cby1 = rp2 * ( ( log ( z1 / 2.0_sp ) + el ) * cbj1 &
        - 1.0_sp / z1 - 0.25_sp * z1 * cs )

    else

      if ( a0 < 35.0_sp ) then
        k0 = 12
      else if ( a0 < 50.0_sp ) then
        k0 = 10
      else
        k0 = 8
      end if

      ct1 = z1 - 0.25_sp * pi
      cp0 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
      do k = 1, k0
        cp0 = cp0 + a(k) * z1 ** ( - 2 * k )
      end do
      cq0 = -0.125_sp / z1
      do k = 1, k0
        cq0 = cq0 + b(k) * z1 ** ( - 2 * k - 1 )
      end do
      cu = sqrt ( rp2 / z1 )
      cbj0 = cu * ( cp0 * cos ( ct1 ) - cq0 * sin ( ct1 ) )
      cby0 = cu * ( cp0 * sin ( ct1 ) + cq0 * cos ( ct1 ) )
      ct2 = z1 - 0.75_sp * pi
      cp1 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
      do k = 1, k0
        cp1 = cp1 + a1(k) * z1 ** ( - 2 * k )
      end do
      cq1 = 0.375_sp / z1
      do k = 1, k0
        cq1 = cq1 + b1(k) * z1 ** ( - 2 * k - 1 )
      end do
      cbj1 = cu * ( cp1 * cos ( ct2 ) - cq1 * sin ( ct2 ) )
      cby1 = cu * ( cp1 * sin ( ct2 ) + cq1 * cos ( ct2 ) )
 
    end if

    if ( real ( z, kind=sp ) < 0.0_sp ) then

      if ( imag ( z ) < 0.0_sp ) then
        cby0 = cby0 - 2.0_sp * ci * cbj0
      else
        cby0 = cby0 + 2.0_sp * ci * cbj0
      end if

      if ( imag ( z ) < 0.0_sp ) then
        cby1 = - ( cby1 - 2.0_sp * ci * cbj1 )
      else
        cby1 = - ( cby1 + 2.0_sp * ci * cbj1 )
      end if
      cbj1 = - cbj1
 
    end if

    cdy0 = - cby1
    cdy1 = cby0 - 1.0_sp / z * cby1

  end if

  if ( kf == 0 ) then
    zf = cby0
    zd = cdy0
  else if ( kf == 1 ) then
    zf = cby1
    zd = cdy1
  else if ( kf == 2 ) then
    zf = cdy1
    zd = - cdy1 / z - ( 1.0_sp - 1.0_sp / ( z * z ) ) * cby1
  end if

  
end subroutine cy01


attributes(device) subroutine dvla ( va, x, pd )

!*****************************************************************************80
!
!! DVLA computes parabolic cylinder functions Dv(x) for large argument.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    06 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
! 
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Input, real(kind=sp) ::  VA, the order.
!
!    Output, real(kind=sp) ::  PD, the function value.
!
  implicit none

  real(kind=sp) ::  a0
  real(kind=sp) ::  ep
  real(kind=sp) ::  eps
  real(kind=sp) ::  gl
  integer(kind=i4) :: k
  real(kind=sp) ::  pd
  real(kind=sp) ::  pi
  real(kind=sp) ::  r
  real(kind=sp), value ::  va
  real(kind=sp) ::  vl
  real(kind=sp), value ::  x
  real(kind=sp) ::  x1

  pi = 3.141592653589793_sp
  eps = 1.0e-12_sp
  ep = exp ( -0.25_sp * x * x )
  a0 = abs ( x ) ** va * ep
  r = 1.0_sp
  pd = 1.0_sp
  do k = 1, 16
    r = -0.5_sp * r * ( 2.0_sp * k - va - 1.0_sp ) &
      * ( 2.0_sp * k - va - 2.0_sp ) / ( k * x * x )
    pd = pd + r
    if ( abs ( r / pd ) < eps ) then
      exit
    end if
  end do

  pd = a0 * pd

  if ( x < 0.0_sp ) then
    x1 = - x
    call vvla ( va, x1, vl )
    call gamma ( -va, gl )
    pd = pi * vl / gl + cos ( pi * va ) * pd
  end if

  return
end subroutine dvla


attributes(device) subroutine e1xa ( x, e1 )

!*****************************************************************************80
!
!! E1XA computes the exponential integral E1(x).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    06 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  E1, the function value.
!
  implicit none

  real(kind=sp) ::  e1
  real(kind=sp) ::  es1
  real(kind=sp) ::  es2
  real(kind=sp), value ::  x

  if ( x == 0.0_sp ) then

    e1 = huge(1.0_sp,kind=sp)

  else if ( x <= 1.0_sp ) then

    e1 = - log ( x ) + (((( &
        1.07857e-03_sp * x &
      - 9.76004e-03_sp ) * x &
      + 5.519968e-02_sp ) * x &
      - 0.24991055_sp ) * x &
      + 0.99999193_sp ) * x &
      - 0.57721566_sp

  else

    es1 = ((( x &
      + 8.5733287401_sp ) * x &
      +18.059016973_sp  ) * x &
      + 8.6347608925_sp ) * x &
      + 0.2677737343_sp

    es2 = ((( x &
      +  9.5733223454_sp ) * x &
      + 25.6329561486_sp ) * x &
      + 21.0996530827_sp ) * x &
      +  3.9584969228_sp

    e1 = exp ( - x ) / x * es1 / es2

  end if

end subroutine e1xa


attributes(device) subroutine e1xb ( x, e1 )

!*****************************************************************************80
!
!! E1XB computes the exponential integral E1(x).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    06 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  E1, the function value.
!
  implicit none

  real(kind=sp) ::  e1
  real(kind=sp) ::  ga
  integer(kind=i4) :: k
  integer(kind=i4) :: m
  real(kind=sp) ::  r
  real(kind=sp) ::  t
  real(kind=sp) ::  t0
  real(kind=sp), value ::  x

  if ( x == 0.0_sp ) then

    e1 = huge(1.0_sp,kind=sp)

  else if ( x <= 1.0_sp ) then

    e1 = 1.0_sp
    r = 1.0_sp

    do k = 1, 25
      r = -r * k * x / ( k + 1.0_sp )**2
      e1 = e1 + r
      if ( abs ( r ) <= abs ( e1 ) * 1.0e-15_sp ) then
        exit
      end if
    end do

    ga = 0.5772156649015328_sp
    e1 = - ga - log ( x ) + x * e1

  else

    m = 20 + int ( 80.0_sp / x )
    t0 = 0.0_sp
    do k = m, 1, -1
      t0 = k / ( 1.0_sp + k / ( x + t0 ) )
    end do
    t = 1.0_sp / ( x + t0 )
    e1 = exp ( -x ) * t

  end if
  
end subroutine e1xb


attributes(device) subroutine e1z ( z, ce1 )

!*****************************************************************************80
!
!! E1Z computes the complex exponential integral E1(z).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    16 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
! 
!  Parameters:
!
!    Input, complex(kind=sp) ::  Z, the argument.
!
!    Output, complex(kind=sp) ::  CE1, the function value.
!
  implicit none

  real(kind=sp) ::  a0
  complex(kind=sp) ::  ce1
  complex(kind=sp) ::  cr
  complex(kind=sp) ::  ct
  complex(kind=sp) ::  ct0
  real(kind=sp) ::  el
  integer(kind=i4) :: k
  real(kind=sp) ::  pi
  real(kind=sp) ::  x
  complex(kind=sp), value ::  z

  pi = 3.141592653589793_sp
  el = 0.5772156649015328_sp
  x = real ( z, kind=sp )
  a0 = abs ( z )

  if ( a0 == 0.0_sp ) then
    ce1 = cmplx ( huge(1.0_sp,kind=sp), 0.0_sp, kind=sp )
  else if ( a0 <= 10.0_sp .or. &
    ( x < 0.0_sp .and. a0 < 20.0_sp ) ) then
    ce1 = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    cr = cmplx ( 1.0_sp, 0.0_sp, kind=sp )
    do k = 1, 150
      cr = - cr * k * z / ( k + 1.0_sp )**2
      ce1 = ce1 + cr
      if ( abs ( cr ) <= abs ( ce1 ) * 1.0e-15_sp ) then
        exit
      end if
    end do

    ce1 = - el - log ( z ) + z * ce1

  else

    ct0 = cmplx ( 0.0_sp, 0.0_sp, kind=sp )
    do k = 120, 1, -1
      ct0 = k / ( 1.0_sp + k / ( z + ct0 ) )
    end do
    ct = 1.0_sp / ( z + ct0 )

    ce1 = exp ( - z ) * ct
    if ( x <= 0.0_sp .and. imag ( z ) == 0.0_sp ) then
      ce1 = ce1 - pi * cmplx ( 0.0_sp, 1.0_sp, kind=sp )
    end if

  end if

end subroutine e1z


attributes(device) subroutine eix ( x, ei )

!*****************************************************************************80
!
!! EIX computes the exponential integral Ei(x).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    10 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  EI, the function value.
!
  implicit none

  real(kind=sp) ::  ei
  real(kind=sp) ::  ga
  integer(kind=i4) :: k
  real(kind=sp) ::  r
  real(kind=sp), value ::  x

  if ( x == 0.0_sp ) then

    ei = -huge(1.0_sp,kind=sp)

  else if ( x <= 40.0_sp ) then

    ei = 1.0_sp
    r = 1.0_sp
    do k = 1, 100
      r = r * k * x / ( k + 1.0_sp )**2
      ei = ei + r
      if ( abs ( r / ei ) <= 1.0e-15_sp ) then
        exit
      end if
    end do

    ga = 0.5772156649015328_sp
    ei = ga + log ( x ) + x * ei

  else

    ei = 1.0_sp
    r = 1.0_sp
    do k = 1, 20
      r = r * k / x
      ei = ei + r
    end do
    ei = exp ( x ) / x * ei

  end if
  
end subroutine eix


attributes(device) subroutine elit ( hk, phi, fe, ee )

!*****************************************************************************80
!
!! ELIT: complete and incomplete elliptic integrals F(k,phi) and E(k,phi).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    12 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  HK, the modulus, between 0 and 1.
!
!    Input, real(kind=sp) ::  PHI, the argument in degrees.
!
!    Output, real(kind=sp) ::  FE, EE, the values of F(k,phi) and E(k,phi).
!
  implicit none

  real(kind=sp) ::  a
  real(kind=sp) ::  a0
  real(kind=sp) ::  b
  real(kind=sp) ::  b0
  real(kind=sp) ::  c
  real(kind=sp) ::  ce
  real(kind=sp) ::  ck
  real(kind=sp) ::  d
  real(kind=sp) ::  _sp
  real(kind=sp) ::  ee
  real(kind=sp) ::  fac
  real(kind=sp) ::  fe
  real(kind=sp) ::  g
  real(kind=sp), value ::  hk
  integer(kind=i4) :: n
  real(kind=sp), value ::  phi
  real(kind=sp) ::  pi
  real(kind=sp) ::  r

  g = 0.0_sp
  pi = 3.14159265358979_sp
  a0 = 1.0_sp
  b0 = sqrt ( 1.0_sp - hk * hk )
  _sp = ( pi / 180.0_sp ) * phi
  r = hk * hk

  if ( hk == 1.0_sp .and. phi == 90.0_sp ) then

    fe = huge(1.0_sp,kind=sp)
    ee = 1.0_sp

  else if ( hk == 1.0_sp ) then

    fe = log ( ( 1.0_sp + sin ( _sp ) ) / cos ( _sp ) )
    ee = sin ( _sp )

  else

    fac = 1.0_sp
    do n = 1, 40
      a = ( a0 + b0 ) * 0.5_sp
      b = sqrt ( a0 * b0 )
      c = ( a0 - b0 ) * 0.5_sp
      fac = 2.0_sp * fac
      r = r + fac * c * c
      if ( phi /= 90.0_sp ) then
        d = _sp + atan ( ( b0 / a0 ) * tan ( _sp ) )
        g = g + c * sin( d )
        _sp = d + pi * int ( d / pi + 0.5_sp )
      end if
      a0 = a
      b0 = b
      if ( c < 1.0e-07_sp ) then
        exit
      end if
    end do

    ck = pi / ( 2.0_sp * a )
    ce = pi * ( 2.0_sp - r ) / ( 4.0_sp * a )
    if ( phi == 90.0_sp ) then
      fe = ck
      ee = ce
    else
      fe = d / ( fac * a )
      ee = fe * ce / ck + g
    end if

  end if

end subroutine elit


attributes(device) subroutine elit3 ( phi, hk, c, el3 )

!*****************************************************************************80
!
!! ELIT3 computes the elliptic integral of the third kind.
!
!  Discussion:
!
!    Gauss-Legendre quadrature is used.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    14 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  PHI, the argument in degrees.
!
!    Input, real(kind=sp) ::  HK, the modulus, between 0 and 1.
!
!    Input, real(kind=sp) ::  C, the parameter, between 0 and 1.
!
!    Output, real(kind=sp) ::  EL3, the value of the elliptic integral
!    of the third kind.
!
  implicit none

  real(kind=sp) ::  c
  real(kind=sp) ::  c0
  real(kind=sp) ::  c1
  real(kind=sp) ::  c2
  real(kind=sp) ::  el3
  real(kind=sp) ::  f1
  real(kind=sp) ::  f2
  real(kind=sp) ::  hk
  integer(kind=i4) :: i 
  logical :: lb1
  logical :: lb2
  real(kind=sp) ::  phi
  real(kind=sp) , dimension ( 10 ) :: t = (/ &
    0.9931285991850949_sp, 0.9639719272779138_sp, &
    0.9122344282513259_sp, 0.8391169718222188_sp, &
    0.7463319064601508_sp, 0.6360536807265150_sp, &
    0.5108670019508271_sp, 0.3737060887154195_sp, &
    0.2277858511416451_sp, 0.7652652113349734e-01 /)
  real(kind=sp) ::  t1
  real(kind=sp) ::  t2
  real(kind=sp) , dimension ( 10 ) :: w = (/ &
    0.1761400713915212e-01, 0.4060142980038694e-01, &
    0.6267204833410907e-01, 0.8327674157670475e-01, &
    0.1019301198172404_sp, 0.1181945319615184_sp, &
    0.1316886384491766_sp, 0.1420961093183820_sp, &
    0.1491729864726037_sp, 0.1527533871307258_sp /)

  lb1 = ( hk == 1.0_sp ) .and. ( abs ( phi - 90.0_sp ) <= 1.0e-08_sp )

  lb2 = c == 1.0_sp .and. abs ( phi - 90.0_sp ) <= 1.0e-08_sp

  if ( lb1 .or. lb2 ) then
    el3 = huge(1.0_sp,kind=sp)
    return
  end if

  c1 = 0.87266462599716e-02_sp * phi
  c2 = c1

  el3 = 0.0_sp
  do i = 1, 10
    c0 = c2 * t(i)
    t1 = c1 + c0
    t2 = c1 - c0
    f1 = 1.0_sp / ( ( 1.0_sp - c * sin(t1) * sin(t1) ) &
      * sqrt ( 1.0_sp - hk * hk * sin ( t1 ) * sin ( t1 ) ) )
    f2 = 1.0_sp / ( ( 1.0_sp - c * sin ( t2 ) * sin ( t2 ) ) &
      * sqrt( 1.0_sp - hk * hk * sin ( t2 ) * sin ( t2 ) ) )
    el3 = el3 + w(i) * ( f1 + f2 )
  end do

  el3 = c1 * el3

end subroutine elit3


attributes(device) function envj ( n, x )

!*****************************************************************************80
!
!! ENVJ is a utility function used by MSTA1 and MSTA2.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    14 March 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, ?
!
!    Input, real(kind=sp) ::  X, ?
!
!    Output, real(kind=sp) ::  ENVJ, ?
!
  implicit none

  real(kind=sp) ::  envj
  integer(kind=i4) :: n
  real(kind=sp) ::  x

  envj = 0.5_sp * log10 ( 6.28_sp * n ) - n * log10 ( 1.36_sp * x / n )

end function envj


attributes(device) subroutine enxa ( n, x, en )

!*****************************************************************************80
!
!! ENXA computes the exponential integral En(x).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    07 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order.
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  EN(0:N), the function values.
!
  implicit none

  integer(kind=i4) :: n

  real(kind=sp) ::  e1
  real(kind=sp) ::  ek
  real(kind=sp) ::  en(0:n)
  integer(kind=i4) :: k
  real(kind=sp) ::  x

  en(0) = exp ( - x ) / x 
  call e1xb ( x, e1 )

  en(1) = e1
  do k = 2, n
    ek = ( exp ( - x ) - x * e1 ) / ( k - 1.0_sp )
    en(k) = ek
    e1 = ek
  end do

end subroutine enxa


attributes(device) subroutine enxb ( n, x, en )

!*****************************************************************************80
!
!! ENXB computes the exponential integral En(x).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    10 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order.
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  EN(0:N), the function values.
!
  implicit none

  integer(kind=i4) :: n

  real(kind=sp) ::  en(0:n)
  real(kind=sp) ::  ens
  integer(kind=i4) :: j
  integer(kind=i4) :: k
  integer(kind=i4) :: l
  integer(kind=i4) :: m
  real(kind=sp) ::  ps
  real(kind=sp) ::  r
  real(kind=sp) ::  rp
  real(kind=sp) ::  s
  real(kind=sp) ::  s0
  real(kind=sp) ::  t
  real(kind=sp) ::  t0
  real(kind=sp) ::  x

  !if ( x == 0.0_sp ) then
  !
  !  en(0) = 1.0e+300
  !  en(1) = 1.0e+300
  !  do k = 2, n
  !    en(k) = 1.0_sp / ( k - 1.0_sp )
  !  end do
  !  return

  if ( x <= 1.0_sp ) then

    en(0) = exp ( - x ) / x
    do l = 1, n
      rp = 1.0_sp
      do j = 1, l - 1
        rp = - rp * x / j
      end do
      ps = -0.5772156649015328_sp
      do m = 1, l - 1
        ps = ps + 1.0_sp / m
      end do
      ens = rp * ( - log ( x ) + ps )
      s = 0.0_sp
      do m = 0, 20
        if ( m /= l - 1 ) then
          r = 1.0_sp
          do j = 1, m
            r = - r * x / j
          end do
          s = s + r / ( m - l + 1.0_sp )
          if ( abs ( s - s0 ) < abs ( s ) * 1.0e-15_sp ) then
            exit
          end if
          s0 = s
        end if
      end do

      en(l) = ens - s

    end do

  else

    en(0) = exp ( - x ) / x
    m = 15 + int ( 100.0_sp / x )
    do l = 1, n
      t0 = 0.0_sp
      do k = m, 1, -1
        t0 = ( l + k - 1.0_sp ) / ( 1.0_sp + k / ( x + t0 ) )
      end do
      t = 1.0_sp / ( x + t0 )
      en(l) = exp ( - x ) * t
    end do

  end if
  
end subroutine enxb


attributes(device) subroutine error ( x, err )

!*****************************************************************************80
!
!! ERROR evaluates the error function.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    07 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  ERR, the function value.
!
  implicit none

  real(kind=sp) ::  c0
  real(kind=sp) ::  eps
  real(kind=sp) ::  er
  real(kind=sp) ::  err
  integer(kind=i4) :: k
  real(kind=sp) ::  pi
  real(kind=sp) ::  r
  real(kind=sp) ::  x
  real(kind=sp) ::  x2

  eps = 1.0e-15
  pi = 3.141592653589793_sp
  x2 = x * x

  if ( abs ( x ) < 3.5_sp ) then

    er = 1.0_sp
    r = 1.0_sp

    do k = 1, 50
      r = r * x2 / ( k + 0.5_sp )
      er = er + r
      if ( abs ( r ) <= abs ( er ) * eps ) then
        exit
      end if
    end do

    c0 = 2.0_sp / sqrt ( pi ) * x * exp ( - x2 )
    err = c0 * er

  else

    er = 1.0_sp
    r = 1.0_sp
    do k = 1, 12
      r = - r * ( k - 0.5_sp ) / x2
      er = er + r
    end do

    c0 = exp ( - x2 ) / ( abs ( x ) * sqrt ( pi ) )

    err = 1.0_sp - c0 * er
    if ( x < 0.0_sp ) then
      err = -err
    end if

  end if

end subroutinre error


attributes(device) subroutine fcs ( x, c, s )

!*****************************************************************************80
!
!! FCS computes Fresnel integrals C(x) and S(x).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    17 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
! 
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  C, S, the function values.
!
  implicit none

  real(kind=sp) ::  c
  real(kind=sp) ::  eps
  real(kind=sp) ::  f
  real(kind=sp) ::  f0
  real(kind=sp) ::  f1
  real(kind=sp) ::  g
  integer(kind=i4) :: k
  integer(kind=i4) :: m
  real(kind=sp) ::  pi
  real(kind=sp) ::  px
  real(kind=sp) ::  q
  real(kind=sp) ::  r
  real(kind=sp) ::  s
  real(kind=sp) ::  su
  real(kind=sp) ::  t
  real(kind=sp) ::  t0
  real(kind=sp) ::  t2
  real(kind=sp) ::  x
  real(kind=sp) ::  xa

  eps = 1.0e-15_sp
  pi = 3.141592653589793_sp
  xa = abs ( x )
  px = pi * xa
  t = 0.5_sp * px * xa
  t2 = t * t

  if ( xa == 0.0_sp ) then

    c = 0.0_sp
    s = 0.0_sp

  else if ( xa < 2.5_sp ) then

    r = xa
    c = r
    do k = 1, 50
      r = -0.5_sp * r * ( 4.0_sp * k - 3.0_sp ) / k &
        / ( 2.0_sp * k - 1.0_sp ) / ( 4.0_sp * k + 1.0_sp ) * t2
      c = c + r
      if ( abs ( r ) < abs ( c ) * eps ) then
        exit
      end if
    end do

    s = xa * t / 3.0_sp
    r = s
    do k = 1, 50
      r = - 0.5_sp * r * ( 4.0_sp * k - 1.0_sp ) / k &
        / ( 2.0_sp * k + 1.0_sp ) / ( 4.0_sp * k + 3.0_sp ) * t2
      s = s + r
      if ( abs ( r ) < abs ( s ) * eps ) then
        if ( x < 0.0_sp ) then
          c = -c
          s = -s
        end if
        return
      end if
    end do

  else if ( xa < 4.5_sp ) then

    m = int ( 42.0_sp + 1.75_sp * t )
    su = 0.0_sp
    c = 0.0_sp
    s = 0.0_sp
    f1 = 0.0_sp
    f0 = 1.0e-100

    do k = m, 0, -1
      f = ( 2.0_sp * k + 3.0_sp ) * f0 / t - f1
      if ( k == int ( k / 2 ) * 2 ) then
        c = c + f
      else
        s = s + f
      end if
      su = su + ( 2.0_sp * k + 1.0_sp ) * f * f
      f1 = f0
      f0 = f
    end do

    q = sqrt ( su )
    c = c * xa / q
    s = s * xa / q

  else

    r = 1.0_sp
    f = 1.0_sp
    do k = 1, 20
      r = -0.25_sp * r * ( 4.0_sp * k - 1.0_sp ) &
        * ( 4.0_sp * k - 3.0_sp ) / t2
      f = f + r
    end do
    r = 1.0_sp / ( px * xa )
    g = r
    do k = 1, 12
      r = -0.25_sp * r * ( 4.0_sp * k + 1.0_sp ) &
        * ( 4.0_sp * k - 1.0_sp ) / t2
      g = g + r
    end do

    t0 = t - int ( t / ( 2.0_sp * pi ) ) * 2.0_sp * pi
    c = 0.5_sp + ( f * sin ( t0 ) - g * cos ( t0 ) ) / px
    s = 0.5_sp - ( f * cos ( t0 ) + g * sin ( t0 ) ) / px

  end if

  if ( x < 0.0_sp ) then
    c = -c
    s = -s
  end if
 
end subroutine fcs


attributes(device) subroutine ffk ( ks, x, fr, fi, fm, fa, gr, gi, gm, ga )

!*****************************************************************************80
!
!! FFK computes modified Fresnel integrals F+/-(x) and K+/-(x).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    23 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: KS, the sign code.
!    0, to calculate F+(x) and K+(x);
!    1, to calculate F_(x) and K_(x).
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  FR, FI, FM, FA, the values of
!    Re[F+/-(x)], Im[F+/-(x)], |F+/-(x)|, Arg[F+/-(x)]  (Degs.).
!
!    Output, real(kind=sp) ::  GR, GI, GM, GA, the values of
!    Re[K+/-(x)], Im[K+/-(x)], |K+/-(x)|, Arg[K+/-(x)]  (Degs.).
!       
  implicit none

  real(kind=sp) ::  c1
  real(kind=sp) ::  cs
  real(kind=sp) ::  eps
  real(kind=sp) ::  fa
  real(kind=sp) ::  fi
  real(kind=sp) ::  fi0
  real(kind=sp) ::  fm
  real(kind=sp) ::  fr
  real(kind=sp) ::  ga
  real(kind=sp) ::  gi
  real(kind=sp) ::  gm
  real(kind=sp) ::  gr
  integer(kind=i4) :: k
  integer(kind=i4) :: ks
  integer(kind=i4) :: m
  real(kind=sp) ::  p2p
  real(kind=sp) ::  pi
  real(kind=sp) ::  pp2
  real(kind=sp) ::  s1
  real(kind=sp) ::  srd
  real(kind=sp) ::  ss
  real(kind=sp) ::  x
  real(kind=sp) ::  x2
  real(kind=sp) ::  x4
  real(kind=sp) ::  xa
  real(kind=sp) ::  xc
  real(kind=sp) ::  xf
  real(kind=sp) ::  xf0
  real(kind=sp) ::  xf1
  real(kind=sp) ::  xg
  real(kind=sp) ::  xp
  real(kind=sp) ::  xq
  real(kind=sp) ::  xq2
  real(kind=sp) ::  xr
  real(kind=sp) ::  xs
  real(kind=sp) ::  xsu
  real(kind=sp) ::  xw

  srd = 57.29577951308233_sp
  eps = 1.0e-15
  pi = 3.141592653589793_sp
  pp2 = 1.2533141373155_sp
  p2p = 0.7978845608028654_sp
  xa = abs ( x )
  x2 = x * x
  x4 = x2 * x2

  if ( x == 0.0_sp ) then

    fr = 0.5_sp * sqrt ( 0.5_sp * pi )
    fi = ( -1.0_sp ) ** ks * fr
    fm = sqrt ( 0.25_sp * pi )
    fa = ( -1.0_sp ) ** ks * 45.0_sp
    gr = 0.5_sp
    gi = 0.0_sp
    gm = 0.5_sp
    ga = 0.0_sp

  else

    if ( xa <= 2.5_sp ) then

      xr = p2p * xa
      c1 = xr
      do k = 1, 50
        xr = -0.5_sp * xr * ( 4.0_sp * k - 3.0_sp ) / k &
          / ( 2.0_sp * k - 1.0_sp ) &
          / ( 4.0_sp * k + 1.0_sp ) * x4
        c1 = c1 + xr
        if ( abs ( xr / c1 ) < eps ) then
          exit
        end if
      end do

      s1 = p2p * xa * xa * xa / 3.0_sp
      xr = s1
      do k = 1, 50
        xr = -0.5_sp * xr * ( 4.0_sp * k - 1.0_sp ) &
          / k / ( 2.0_sp * k + 1.0_sp ) &
          / ( 4.0_sp * k + 3.0_sp ) * x4
        s1 = s1 + xr
        if ( abs ( xr / s1 ) < eps ) then
          exit
        end if
      end do

    else if ( xa < 5.5_sp ) then

      m = int ( 42.0_sp + 1.75_sp * x2 )
      xsu = 0.0_sp
      xc = 0.0_sp
      xs = 0.0_sp
      xf1 = 0.0_sp
      xf0 = 1.0e-100
      do k = m, 0, -1
        xf = ( 2.0_sp * k + 3.0_sp ) * xf0 / x2 - xf1
        if ( k == 2 * int ( k / 2 ) )  then
          xc = xc + xf
        else
          xs = xs + xf
        end if
        xsu = xsu + ( 2.0_sp * k + 1.0_sp ) * xf * xf
        xf1 = xf0
        xf0 = xf
      end do
      xq = sqrt ( xsu )
      xw = p2p * xa / xq
      c1 = xc * xw
      s1 = xs * xw

    else

      xr = 1.0_sp
      xf = 1.0_sp
      do k = 1, 12
        xr = -0.25_sp * xr * ( 4.0_sp * k - 1.0_sp ) &
          * ( 4.0_sp * k - 3.0_sp ) / x4
        xf = xf + xr
      end do
      xr = 1.0_sp / ( 2.0_sp * xa * xa )
      xg = xr
      do k = 1, 12
        xr = -0.25_sp * xr * ( 4.0_sp * k + 1.0_sp ) &
          * ( 4.0_sp * k - 1.0_sp ) / x4
        xg = xg + xr
      end do
      c1 = 0.5_sp + ( xf * sin ( x2 ) - xg * cos ( x2 ) ) &
        / sqrt ( 2.0_sp * pi ) / xa
      s1 = 0.5_sp - ( xf * cos ( x2 ) + xg * sin ( x2 ) ) &
        / sqrt ( 2.0_sp * pi ) / xa

    end if
 
    fr = pp2 * ( 0.5_sp - c1 )
    fi0 = pp2 * ( 0.5_sp - s1 )
    fi = ( -1.0_sp ) ** ks * fi0
    fm = sqrt ( fr * fr + fi * fi )

    if ( 0.0_sp <= fr ) then
      fa = srd * atan ( fi / fr )
    else if ( 0.0_sp < fi ) then
      fa = srd * ( atan ( fi / fr ) + pi )
    else if ( fi < 0.0_sp ) then
      fa = srd * ( atan ( fi / fr ) - pi )
    end if

    xp = x * x + pi / 4.0_sp
    cs = cos ( xp )
    ss = sin ( xp )
    xq2 = 1.0_sp / sqrt ( pi )
    gr = xq2 * ( fr * cs + fi0 * ss )
    gi = ( -1.0_sp ) ** ks * xq2 * ( fi0 * cs - fr * ss )
    gm = sqrt ( gr * gr + gi * gi )

    if ( 0.0_sp <= gr ) then
      ga = srd * atan ( gi / gr )
    else if ( 0.0_sp < gi ) then
      ga = srd * ( atan ( gi / gr ) + pi )
    else if ( gi < 0.0_sp ) then
      ga = srd * ( atan ( gi / gr ) - pi )
    end if

    if ( x < 0.0_sp ) then
      fr = pp2 - fr
      fi = ( -1.0_sp ) ** ks * pp2 - fi
      fm = sqrt ( fr * fr + fi * fi )
      fa = srd * atan ( fi / fr )
      gr = cos ( x * x ) - gr
      gi = - ( -1.0_sp ) ** ks * sin ( x * x ) - gi
      gm = sqrt ( gr * gr + gi * gi )
      ga = srd * atan ( gi / gr )
    end if

  end if

end subroutine ffk


attributes(device) subroutine gamma ( x, ga )

!*****************************************************************************80
!
!! GAMMA evaluates the Gamma function.
!
!  Licensing:
!
!    The original FORTRAN77 version of this routine is copyrighted by 
!    Shanjie Zhang and Jianming Jin.  However, they give permission to 
!    incorporate this routine into a user program that the copyright 
!    is acknowledged.
!
!  Modified:
!
!    08 September 2007
!
!  Author:
!
!    Original FORTRAN77 version by Shanjie Zhang, Jianming Jin.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!    X must not be 0, or any negative integer.
!
!    Output, real(kind=sp) ::  GA, the value of the Gamma function.
!
  implicit none

  real(kind=sp) , dimension ( 26 ) :: g = (/ &
    1.0_sp, &
    0.5772156649015329_sp, &
   -0.6558780715202538_sp, &
   -0.420026350340952e-01_sp, &
    0.1665386113822915_sp, &
   -0.421977345555443e-01_sp, &
   -0.96219715278770e-02_sp, &
    0.72189432466630e-02_sp, &
   -0.11651675918591e-02_sp, &
   -0.2152416741149e-03_sp, &
    0.1280502823882e-03_sp, & 
   -0.201348547807e-04_sp, &
   -0.12504934821e-05_sp, &
    0.11330272320e-05_sp, &
   -0.2056338417e-06_sp, & 
    0.61160950e-08_sp, &
    0.50020075e-08_sp, &
   -0.11812746e-08_sp, &
    0.1043427e-09_sp, & 
    0.77823e-11_sp, &
   -0.36968e-11_sp, &
    0.51e-12_sp, &
   -0.206e-13_sp, &
   -0.54e-14_sp, &
    0.14e-14_sp, &
    0.1e-15_sp /)
  real(kind=sp) ::  ga
  real(kind=sp) ::  gr
  integer(kind=i4) :: k
  integer(kind=i4) :: m
  integer(kind=i4) :: m1
  real(kind=sp) :: , parameter :: pi = 3.141592653589793_sp
  real(kind=sp) ::  r
  real(kind=sp) ::  x
  real(kind=sp) ::  z

  if ( x == aint ( x ) ) then

    if ( 0.0_sp < x ) then
      ga = 1.0_sp
      m1 = int ( x ) - 1
      do k = 2, m1
        ga = ga * k
      end do
    else
      ga = huge(1.0_sp,kind=sp)
    end if

  else

    if ( 1.0_sp < abs ( x ) ) then
      z = abs ( x )
      m = int ( z )
      r = 1.0_sp
      do k = 1, m
        r = r * ( z - real ( k, kind=sp ) )
      end do
      z = z - real ( m, kind=sp )
    else
      z = x
    end if

    gr = g(26)
    do k = 25, 1, -1
      gr = gr * z + g(k)
    end do

    ga = 1.0_sp / ( gr * z )

    if ( 1.0_sp < abs ( x ) ) then
      ga = ga * r
      if ( x < 0.0_sp ) then
        ga = - pi / ( x* ga * sin ( pi * x ) )
      end if
    end if

  end if

end subroutine gamma


attributes(device) subroutine ik01a ( x, bi0, di0, bi1, di1, bk0, dk0, bk1, dk1 )

!*****************************************************************************80
!
!! IK01A compute Bessel function I0(x), I1(x), K0(x), and K1(x).
!
!  Discussion:
!
!    This procedure computes modified Bessel functions I0(x), I1(x),
!    K0(x) and K1(x), and their derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    16 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  BI0, DI0, BI1, DI1, BK0, DK0, BK1, DK1, the
!    values of I0(x), I0'(x), I1(x), I1'(x), K0(x), K0'(x), K1(x), K1'(x).
!
  implicit none

  real(kind=sp) , dimension ( 12 ) :: a = (/ &
    0.125_sp, 7.03125e-02_sp, &
    7.32421875e-02_sp, 1.1215209960938e-01_sp, &
    2.2710800170898e-01, 5.7250142097473e-01_sp, &
    1.7277275025845_sp, 6.0740420012735_sp, &
    2.4380529699556e+01_sp, 1.1001714026925e+02_sp, &
    5.5133589612202e+02_sp, 3.0380905109224e+03_sp /)
  real(kind=sp) , dimension ( 8 ) :: a1 = (/ &
    0.125_sp, 0.2109375_sp, &
    1.0986328125_sp, 1.1775970458984e+01_sp, &
    2.1461706161499e+02_sp, 5.9511522710323e+03_sp, &
    2.3347645606175e+05_sp, 1.2312234987631e+07_sp /)
  real(kind=sp) , dimension ( 12 ) :: b = (/ &
    -0.375_sp, -1.171875e-01_sp, &
    -1.025390625e-01_sp, -1.4419555664063e-01_sp, &
    -2.7757644653320e-01, -6.7659258842468e-01_sp, &
    -1.9935317337513_sp, -6.8839142681099_sp, &
    -2.7248827311269e+01_sp, -1.2159789187654e+02_sp, &
    -6.0384407670507e+02_sp, -3.3022722944809e+03_sp /)
  real(kind=sp) ::  bi0
  real(kind=sp) ::  bi1
  real(kind=sp) ::  bk0
  real(kind=sp) ::  bk1
  real(kind=sp) ::  ca
  real(kind=sp) ::  cb
  real(kind=sp) ::  ct
  real(kind=sp) ::  di0
  real(kind=sp) ::  di1
  real(kind=sp) ::  dk0
  real(kind=sp) ::  dk1
  real(kind=sp) ::  el
  integer(kind=i4) :: k
  integer(kind=i4) :: k0
  real(kind=sp) ::  pi
  real(kind=sp) ::  r
  real(kind=sp) ::  w0
  real(kind=sp) ::  ww
  real(kind=sp) ::  x
  real(kind=sp) ::  x2
  real(kind=sp) ::  xr
  real(kind=sp) ::  xr2

  pi = 3.141592653589793_sp
  el = 0.5772156649015329_sp
  x2 = x * x

  !if ( x == 0.0_sp ) then
  !
  !  bi0 = 1.0_sp
  !  bi1 = 0.0_sp
  !  bk0 = 1.0e+300
  !  bk1 = 1.0e+300
  !  di0 = 0.0_sp
  !  di1 = 0.5_sp
  ! ! dk0 = -1.0e+300
  !  dk1 = -1.0e+300
  !  return

  if ( x <= 18.0_sp ) then

    bi0 = 1.0_sp
    r = 1.0_sp
    do k = 1, 50
      r = 0.25_sp * r * x2 / ( k * k )
      bi0 = bi0 + r
      if ( abs ( r / bi0 ) < 1.0e-15_sp ) then
        exit
      end if
    end do

    bi1 = 1.0_sp
    r = 1.0_sp
    do k = 1, 50
      r = 0.25_sp * r * x2 / ( k * ( k + 1 ) )
      bi1 = bi1 + r
      if ( abs ( r / bi1 ) < 1.0e-15_sp ) then
        exit
      end if
    end do

    bi1 = 0.5_sp * x * bi1

  else

    if ( x < 35.0_sp ) then
      k0 = 12
    else if ( x < 50.0_sp ) then
      k0 = 9
    else
      k0 = 7
    end if

    ca = exp ( x ) / sqrt ( 2.0_sp * pi * x )
    bi0 = 1.0_sp
    xr = 1.0_sp / x
    do k = 1, k0
      bi0 = bi0 + a(k) * xr ** k
    end do
    bi0 = ca * bi0
    bi1 = 1.0_sp
    do k = 1, k0
      bi1 = bi1 + b(k) * xr ** k
    end do
    bi1 = ca * bi1

  end if

  if ( x <= 9.0_sp ) then

    ct = - ( log ( x / 2.0_sp ) + el )
    bk0 = 0.0_sp
    w0 = 0.0_sp
    r = 1.0_sp
    do k = 1, 50
      w0 = w0 + 1.0_sp / k
      r = 0.25_sp * r / ( k * k ) * x2
      bk0 = bk0 + r * ( w0 + ct )
      if ( abs ( ( bk0 - ww ) / bk0 ) < 1.0e-15_sp ) then
        exit
      end if
      ww = bk0
    end do

    bk0 = bk0 + ct

  else

    cb = 0.5_sp / x
    xr2 = 1.0_sp / x2
    bk0 = 1.0_sp
    do k = 1, 8
      bk0 = bk0 + a1(k) * xr2 ** k
    end do
    bk0 = cb * bk0 / bi0

  end if

  bk1 = ( 1.0_sp / x - bi1 * bk0 ) / bi0
  di0 = bi1
  di1 = bi0 - bi1 / x
  dk0 = - bk1
  dk1 = - bk0 - bk1 / x

end subroutine ik01a


attributes(device) subroutine ik01b ( x, bi0, di0, bi1, di1, bk0, dk0, bk1, dk1 )

!*****************************************************************************80
!
!! IK01B: Bessel functions I0(x), I1(x), K0(x), and K1(x) and derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    17 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  BI0, DI0, BI1, DI1, BK0, DK0, BK1, DK1, the
!    values of I0(x), I0'(x), I1(x), I1'(x), K0(x), K0'(x), K1(x), K1'(x).
!
  implicit none

  real(kind=sp) ::  bi0
  real(kind=sp) ::  bi1
  real(kind=sp) ::  bk0
  real(kind=sp) ::  bk1
  real(kind=sp) ::  di0
  real(kind=sp) ::  di1
  real(kind=sp) ::  dk0
  real(kind=sp) ::  dk1
  real(kind=sp) ::  t
  real(kind=sp) ::  t2
  real(kind=sp) ::  x

  !if ( x == 0.0_sp ) then
  !
  !  bi0 = 1.0_sp
  !  bi1 = 0.0_sp
  !  bk0 = 1.0e+300
  !  bk1 = 1.0e+300
  !  di0 = 0.0_sp
  !  di1 = 0.5_sp
  !  dk0 = -1.0e+300
  !  dk1 = -1.0e+300
  !  return

  if ( x <= 3.75_sp ) then

    t = x / 3.75_sp
    t2 = t * t

    bi0 = ((((( &
        0.0045813_sp   * t2 &
      + 0.0360768_sp ) * t2 &
      + 0.2659732_sp ) * t2 &
      + 1.2067492_sp ) * t2 &
      + 3.0899424_sp ) * t2 &
      + 3.5156229_sp ) * t2 &
      + 1.0_sp

    bi1 = x * (((((( &
        0.00032411_sp   * t2 &
      + 0.00301532_sp ) * t2 &
      + 0.02658733_sp ) * t2 &
      + 0.15084934_sp ) * t2 &
      + 0.51498869_sp ) * t2 &
      + 0.87890594_sp ) * t2 &
      + 0.5_sp )

  else

    t = 3.75_sp / x

    bi0 = (((((((( &
        0.00392377_sp   * t &
      - 0.01647633_sp ) * t &
      + 0.02635537_sp ) * t &
      - 0.02057706_sp ) * t &
      + 0.916281e-02 ) * t &
      - 0.157565e-02 ) * t &
      + 0.225319e-02 ) * t &
      + 0.01328592_sp ) * t &
      + 0.39894228_sp ) * exp ( x ) / sqrt ( x )

    bi1 = (((((((( &
      - 0.420059e-02     * t &
      + 0.01787654_sp ) * t &
      - 0.02895312_sp ) * t &
      + 0.02282967_sp ) * t &
      - 0.01031555_sp ) * t &
      + 0.163801e-02 ) * t &
      - 0.00362018_sp ) * t &
      - 0.03988024_sp ) * t &
      + 0.39894228_sp ) * exp ( x ) / sqrt ( x )

  end if

  if ( x <= 2.0_sp ) then

    t = x / 2.0_sp
    t2 = t * t

    bk0 = ((((( &
        0.0000074_sp   * t2 &
      + 0.0001075_sp ) * t2 &
      + 0.00262698_sp ) * t2 &
      + 0.0348859_sp ) * t2 &
      + 0.23069756_sp ) * t2 &
      + 0.4227842_sp ) * t2 &
      - 0.57721566_sp - bi0 * log ( t )

    bk1 = (((((( &
      - 0.00004686_sp   * t2 &
      - 0.00110404_sp ) * t2 &
      - 0.01919402_sp ) * t2 &
      - 0.18156897_sp ) * t2 &
      - 0.67278579_sp ) * t2 &
      + 0.15443144_sp ) * t2 &
      + 1.0_sp ) / x + bi1 * log ( t )

  else

    t = 2.0_sp / x
    t2 = t * t

    bk0 = (((((( &
        0.00053208_sp   * t &
      - 0.0025154_sp )  * t &
      + 0.00587872_sp ) * t &
      - 0.01062446_sp ) * t &
      + 0.02189568_sp ) * t &
      - 0.07832358_sp ) * t &
      + 1.25331414_sp ) * exp ( - x ) / sqrt ( x )

    bk1 = (((((( &
      - 0.00068245_sp   * t &
      + 0.00325614_sp ) * t &
      - 0.00780353_sp ) * t &
      + 0.01504268_sp ) * t &
      - 0.0365562_sp  ) * t & 
      + 0.23498619_sp ) * t &
      + 1.25331414_sp ) * exp ( - x ) / sqrt ( x )

  end if

  di0 = bi1
  di1 = bi0 - bi1 / x
  dk0 = -bk1
  dk1 = -bk0 - bk1 / x
  
end subroutine ik01b


attributes(device) subroutine ikna ( n, x, nm, bi, di, bk, dk )

!*****************************************************************************80
!
!! IKNA compute Bessel function In(x) and Kn(x), and derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    16 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order of In(x) and Kn(x).
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, integer(kind=i4) :: NM, the highest order computed.
!
!    Output, real(kind=sp) ::  BI(0:N), DI(0:N), BK(0:N), DK(0:N),
!    the values of In(x), In'(x), Kn(x), Kn'(x).
!
  implicit none

  integer(kind=i4) :: n

  real(kind=sp) ::  bi(0:n)
  real(kind=sp) ::  bi0
  real(kind=sp) ::  bi1
  real(kind=sp) ::  bk(0:n)
  real(kind=sp) ::  bk0
  real(kind=sp) ::  bk1
  real(kind=sp) ::  di(0:n)
  real(kind=sp) ::  di0
  real(kind=sp) ::  di1
  real(kind=sp) ::  dk(0:n)
  real(kind=sp) ::  dk0
  real(kind=sp) ::  dk1
  real(kind=sp) ::  f
  real(kind=sp) ::  f0
  real(kind=sp) ::  f1
  real(kind=sp) ::  g
  real(kind=sp) ::  g0
  real(kind=sp) ::  g1
  real(kind=sp) ::  h
  real(kind=sp) ::  h0
  real(kind=sp) ::  h1
  integer(kind=i4) :: k
  integer(kind=i4) :: m
  integer(kind=i4) :: nm
  real(kind=sp) ::  s0
  real(kind=sp) ::  x

 
  if ( n <= 1 ) then
    return
  end if
  nm = n

  call ik01a ( x, bi0, di0, bi1, di1, bk0, dk0, bk1, dk1 )
  bi(0) = bi0
  bi(1) = bi1
  bk(0) = bk0
  bk(1) = bk1
  di(0) = di0
  di(1) = di1
  dk(0) = dk0
  dk(1) = dk1

  

  if ( 40.0_sp < x .and. n < int ( 0.25_sp * x ) ) then

    h0 = bi0
    h1 = bi1
    do k = 2, n
      h = -2.0_sp * ( k - 1.0_sp ) / x * h1 + h0
      bi(k) = h
      h0 = h1
      h1 = h
    end do

  else

    m = msta1 ( x, 200 )

    if ( m < n ) then
      nm = m
    else
      m = msta2 ( x, n, 15 )
    end if

    f0 = 0.0_sp
    f1 = tiny(1.0_sp,kind=sp)
    do k = m, 0, -1
      f = 2.0_sp * ( k + 1.0_sp ) * f1 / x + f0
      if ( k <= nm ) then
        bi(k) = f
      end if
      f0 = f1
      f1 = f
    end do
    s0 = bi0 / f
    do k = 0, nm
      bi(k) = s0 * bi(k)
    end do
  end if

  g0 = bk0
  g1 = bk1
  do k = 2, nm
    g = 2.0_sp * ( k - 1.0_sp ) / x * g1 + g0
    bk(k) = g
    g0 = g1
    g1 = g
  end do

  do k = 2, nm
    di(k) = bi(k-1) - k / x * bi(k)
    dk(k) = - bk(k-1) - k / x * bk(k)
  end do

end subroutine ikna


attributes(device) subroutine iknb ( n, x, nm, bi, di, bk, dk )

!*****************************************************************************80
!
!! IKNB compute Bessel function In(x) and Kn(x).
!
!  Discussion:
!
!    Compute modified Bessel functions In(x) and Kn(x),
!    and their derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    17 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order of In(x) and Kn(x).
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, integer(kind=i4) :: NM, the highest order computed.
!
!    Output, real(kind=sp) ::  BI(0:N), DI(0:N), BK(0:N), DK(0:N),
!    the values of In(x), In'(x), Kn(x), Kn'(x).
!
  implicit none

  integer(kind=i4) :: n

  real(kind=sp) ::  a0
  real(kind=sp) ::  bi(0:n)
  real(kind=sp) ::  bk(0:n)
  real(kind=sp) ::  bkl
  real(kind=sp) ::  bs
  real(kind=sp) ::  di(0:n)
  real(kind=sp) ::  dk(0:n)
  real(kind=sp) ::  el
  real(kind=sp) ::  f
  real(kind=sp) ::  f0
  real(kind=sp) ::  f1
  real(kind=sp) ::  g
  real(kind=sp) ::  g0
  real(kind=sp) ::  g1
  integer(kind=i4) :: k
  integer(kind=i4) :: k0
  integer(kind=i4) :: l
  integer(kind=i4) :: m
  
  integer(kind=i4) :: nm
  real(kind=sp) ::  pi
  real(kind=sp) ::  r
  real(kind=sp) ::  s0
  real(kind=sp) ::  sk0
  real(kind=sp) ::  vt
  real(kind=sp) ::  x

  pi = 3.141592653589793_sp
  el = 0.5772156649015329_sp
  nm = n

 

  if ( n == 0 ) then
    nm = 1
  end if

  m = msta1 ( x, 200 )
  if ( m < nm ) then
    nm = m
  else
    m = msta2 ( x, nm, 15 )
  end if

  bs = 0.0_sp
  sk0 = 0.0_sp
  f0 = 0.0_sp
  f1 = tiny(1.0_sp,kind=sp)
  do k = m, 0, -1
    f = 2.0_sp * ( k + 1.0_sp ) / x * f1 + f0
    if ( k <= nm ) then
      bi(k) = f
    end if
    if ( k /= 0 .and. k == 2 * int ( k / 2 ) ) then
      sk0 = sk0 + 4.0_sp * f / k
    end if
    bs = bs + 2.0_sp * f
    f0 = f1
    f1 = f
  end do

  s0 = exp ( x ) / ( bs - f )
  do k = 0, nm
    bi(k) = s0 * bi(k)
  end do

  if ( x <= 8.0_sp ) then
    bk(0) = - ( log ( 0.5_sp * x ) + el ) * bi(0) + s0 * sk0
    bk(1) = ( 1.0_sp / x - bi(1) * bk(0) ) / bi(0)
  else
    a0 = sqrt ( pi / ( 2.0_sp * x ) ) * exp ( - x ) 

    if ( x < 25.0_sp ) then
      k0 = 16
    else if ( x < 80.0_sp ) then
      k0 = 10
    else if ( x < 200.0_sp ) then
      k0 = 8
    else
      k0 = 6
    end if

    do l = 0, 1
      bkl = 1.0_sp
      vt = 4.0_sp * l
      r = 1.0_sp
      do k = 1, k0
        r = 0.125_sp * r * ( vt - ( 2.0_sp * k - 1.0_sp ) ** 2 ) / ( k * x )
        bkl = bkl + r
      end do
      bk(l) = a0 * bkl
    end do
  end if

  g0 = bk(0)
  g1 = bk(1)
  do k = 2, nm
    g = 2.0_sp * ( k - 1.0_sp ) / x * g1 + g0
    bk(k) = g
    g0 = g1
    g1 = g
  end do

  di(0) = bi(1)
  dk(0) = -bk(1)
  do k = 1, nm
    di(k) = bi(k-1) - k / x * bi(k)
    dk(k) = -bk(k-1) - k / x * bk(k)
  end do

end subroutine iknb


attributes(device) subroutine incob ( a, b, x, bix )

!*****************************************************************************80
!
!! INCOB computes the incomplete beta function Ix(a,b).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    22 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  A, B, parameters.
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  BIX, the function value.
!
  implicit none

  real(kind=sp) ::  a
  real(kind=sp) ::  b
  real(kind=sp) ::  bix
  real(kind=sp) ::  bt
  real(kind=sp) ::  dk(51)
  real(kind=sp) ::  fk(51)
  integer(kind=i4) :: k
  real(kind=sp) ::  s0
  real(kind=sp) ::  t1
  real(kind=sp) ::  t2
  real(kind=sp) ::  ta
  real(kind=sp) ::  tb
  real(kind=sp) ::  x

  s0 = ( a + 1.0_sp ) / ( a + b + 2.0_sp )
  call beta ( a, b, bt )

  if ( x <= s0 ) then

    do k = 1, 20
      dk(2*k) = k * ( b - k ) * x / &
        ( a + 2.0_sp * k - 1.0_sp ) / ( a + 2.0_sp * k )
    end do

    do k = 0, 20
      dk(2*k+1) = - ( a + k ) * ( a + b + k ) * x &
        / ( a + 2.0_sp * k ) / ( a + 2.0_sp * k + 1.0_sp )
    end do

    t1 = 0.0_sp
    do k = 20, 1, -1
      t1 = dk(k) / ( 1.0_sp + t1 )
    end do
    ta = 1.0_sp / ( 1.0_sp + t1 )
    bix = x ** a * ( 1.0_sp - x ) ** b / ( a * bt ) * ta

  else

    do k = 1, 20
      fk(2*k) = k * ( a - k ) * ( 1.0_sp - x ) &
        / ( b + 2.0_sp * k - 1.0_sp ) / ( b + 2.0_sp * k )
    end do

    do k = 0,20
      fk(2*k+1) = - ( b + k ) * ( a + b + k ) * ( 1.0_sp - x ) &
        / ( b + 2.0_sp * k ) / ( b + 2.0_sp * k + 1.0_sp )
    end do

    t2 = 0.0_sp
    do k = 20, 1, -1
      t2 = fk(k) / ( 1.0_sp + t2 )
    end do
    tb = 1.0_sp / ( 1.0_sp + t2 )
    bix = 1.0_sp - x ** a * ( 1.0_sp - x ) ** b / ( b * bt ) * tb

  end if

end subroutine incob


attributes(device) subroutine incog ( a, x, gin, gim, gip )

!*****************************************************************************80
!
!! INCOG computes the incomplete gamma function r(a,x), ,(a,x), P(a,x).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    22 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  A, the parameter.
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  GIN, GIM, GIP, the values of
!    r(a,x), \E2(a,x), P(a,x).
!
  implicit none

  real(kind=sp) ::  a
  real(kind=sp) ::  ga
  real(kind=sp) ::  gim
  real(kind=sp) ::  gin
  real(kind=sp) ::  gip
  integer(kind=i4) :: k
  real(kind=sp) ::  r
  real(kind=sp) ::  s
  real(kind=sp) ::  t0
  real(kind=sp) ::  x
  real(kind=sp) ::  xam

  xam = -  x + a * log ( x )

 

  if ( x == 0.0_sp ) then

    gin = 0.0_sp
    call gamma ( a, ga )
    gim = ga
    gip = 0.0_sp

  else if ( x <= 1.0_sp + a ) then

    s = 1.0_sp / a
    r = s
    do k = 1, 60
      r = r * x / ( a + k )
      s = s + r
      if ( abs ( r / s ) < 1.0e-15_sp ) then
        exit
      end if
    end do

    gin = exp ( xam ) * s
    call gamma ( a, ga )
    gip = gin / ga
    gim = ga - gin

  else if ( 1.0_sp + a < x ) then

    t0 = 0.0_sp
    do k = 60, 1, -1
      t0 = ( k - a ) / ( 1.0_sp + k / ( x + t0 ) )
    end do
    gim = exp ( xam ) / ( x + t0 )
    call gamma ( a, ga )
    gin = ga - gim
    gip = 1.0_sp - gim / ga

  end if

end subroutine incog


attributes(device) subroutine itairy ( x, apt, bpt, ant, bnt )

!****************************************************************************80
!
!! ITAIRY computes the integrals of Airy functions.
!
!  Discussion:
!
!    Compute the integrals of Airy functions with respect to t,
!    from 0 and x.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    19 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the upper limit of the integral.
!
!    Output, real(kind=sp) ::  APT, BPT, ANT, BNT, the integrals, from 0 to x,
!    of Ai(t), Bi(t), Ai(-t), and Bi(-t).
!       
  implicit none

  real(kind=sp), dimension ( 16 ) :: a = (/ &
    0.569444444444444_sp, 0.891300154320988_sp, &
    0.226624344493027e+01_sp, 0.798950124766861e+01_sp, &
    0.360688546785343e+02_sp, 0.198670292131169e+03_sp, &
    0.129223456582211e+04_sp, 0.969483869669600e+04_sp, &
    0.824184704952483e+05_sp, 0.783031092490225e+06_sp, &
    0.822210493622814e+07_sp, 0.945557399360556e+08_sp, &
    0.118195595640730e+10_sp, 0.159564653040121e+11_sp, &
    0.231369166433050e+12_sp, 0.358622522796969e+13_sp /)
  real(kind=sp) ::  ant
  real(kind=sp) ::  apt
  real(kind=sp) ::  bnt
  real(kind=sp) ::  bpt
  real(kind=sp) ::  c1
  real(kind=sp) ::  c2
  real(kind=sp) ::  eps
  real(kind=sp) ::  fx
  real(kind=sp) ::  gx
  integer(kind=i4) :: k
  integer(kind=i4) :: l
  real(kind=sp) ::  pi
  real(kind=sp) ::  q0
  real(kind=sp) ::  q1
  real(kind=sp) ::  q2
  real(kind=sp) ::  r
  real(kind=sp) ::  sr3
  real(kind=sp) ::  su1
  real(kind=sp) ::  su2
  real(kind=sp) ::  su3
  real(kind=sp) ::  su4
  real(kind=sp) ::  su5
  real(kind=sp) ::  su6
  real(kind=sp) ::  x
  real(kind=sp) ::  xe
  real(kind=sp) ::  xp6
  real(kind=sp) ::  xr1
  real(kind=sp) ::  xr2

  eps = 1.0e-15_sp
  pi = 3.141592653589793_sp
  c1 = 0.355028053887817_sp
  c2 = 0.258819403792807_sp
  sr3 = 1.732050807568877_sp

  if ( x == 0.0_sp ) then

    apt = 0.0_sp
    bpt = 0.0_sp
    ant = 0.0_sp
    bnt = 0.0_sp

  else

    if ( abs ( x ) <= 9.25_sp ) then

      do l = 0, 1

        x = ( -1.0_sp ) ** l * x
        fx = x
        r = x

        do k = 1, 40
          r = r * ( 3.0_sp * k - 2.0_sp ) &
            / ( 3.0_sp * k + 1.0_sp ) * x / ( 3.0_sp * k ) &
            * x / ( 3.0_sp * k - 1.0_sp ) * x 
          fx = fx + r
          if ( abs ( r ) < abs ( fx ) * eps ) then
            exit
          end if
        end do

        gx = 0.5_sp * x * x
        r = gx

        do k = 1, 40
          r = r * ( 3.0_sp * k - 1.0_sp ) &
            / ( 3.0_sp * k + 2.0_sp ) * x / ( 3.0_sp * k ) * x &
            / ( 3.0_sp * k + 1.0_sp ) * x
          gx = gx + r
          if ( abs ( r ) < abs ( gx ) * eps ) then
            exit
          end if
        end do

        ant = c1 * fx - c2 * gx
        bnt = sr3 * ( c1 * fx + c2 * gx )

        if ( l == 0 ) then
          apt = ant
          bpt = bnt
        else
          ant = -ant
          bnt = -bnt
          x = -x
        end if

      end do

    else

      q2 = 1.414213562373095_sp
      q0 = 0.3333333333333333_sp
      q1 = 0.6666666666666667_sp
      xe = x * sqrt ( x ) / 1.5_sp
      xp6 = 1.0_sp / sqrt ( 6.0_sp * pi * xe )
      su1 = 1.0_sp
      r = 1.0_sp
      xr1 = 1.0_sp / xe
      do k = 1, 16
        r = - r * xr1
        su1 = su1 + a(k) * r
      end do
      su2 = 1.0_sp
      r = 1.0_sp
      do k = 1, 16
        r = r * xr1
        su2 = su2 + a(k) * r
      end do

      apt = q0 - exp ( - xe ) * xp6 * su1
      bpt = 2.0_sp * exp ( xe ) * xp6 * su2
      su3 = 1.0_sp
      r = 1.0_sp
      xr2 = 1.0_sp / ( xe * xe )
      do k = 1, 8
        r = - r * xr2
        su3 = su3 + a(2*k) * r
      end do
      su4 = a(1) * xr1
      r = xr1
      do k = 1, 7
        r = -r * xr2
        su4 = su4 + a(2*k+1) * r
      end do
      su5 = su3 + su4
      su6 = su3 - su4
      ant = q1 - q2 * xp6 * ( su5 * cos ( xe ) - su6 * sin ( xe ) )
      bnt = q2 * xp6 * ( su5 * sin ( xe ) + su6 * cos ( xe ) )

    end if

  end if
  
end subroutine itairy


attributes(device) subroutine itika ( x, ti, tk )

!*****************************************************************************80
!
!! ITIKA computes the integral of the modified Bessel functions I0(t) and K0(t).
!
!  Discussion:
!
!    This procedure integrates modified Bessel functions I0(t) and
!    K0(t) with respect to t from 0 to x.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    18 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the upper limit of the integral.
!
!    Output, real(kind=sp) ::  TI, TK, the integrals of I0(t) and K0(t)
!    from 0 to X.
!
  implicit none

  real(kind=sp), dimension ( 10 ) :: a = (/ &
    0.625_sp,           1.0078125_sp, &
    2.5927734375_sp,    9.1868591308594_sp, &
    4.1567974090576e+01_sp, 2.2919635891914e+02_sp, &
    1.491504060477e+03_sp,  1.1192354495579e+04_sp, &
    9.515939374212e+04_sp,  9.0412425769041e+05_sp /)
  real(kind=sp) ::  b1
  real(kind=sp) ::  b2
  real(kind=sp) ::  e0
  real(kind=sp) ::  el
  integer(kind=i4) :: k
  real(kind=sp) ::  pi
  real(kind=sp) ::  r
  real(kind=sp) ::  rc1
  real(kind=sp) ::  rc2
  real(kind=sp) ::  rs
  real(kind=sp) ::  ti
  real(kind=sp) ::  tk
  real(kind=sp) ::  tw
  real(kind=sp) ::  x
  real(kind=sp) ::  x2

  pi = 3.141592653589793_sp
  el = 0.5772156649015329_sp

 

  if ( x < 20.0_sp ) then

    x2 = x * x
    ti = 1.0_sp
    r = 1.0_sp
    do k = 1, 50
      r = 0.25_sp * r * ( 2 * k - 1.0_sp ) / ( 2 * k + 1.0_sp ) &
        / ( k * k ) * x2
      ti = ti + r
      if ( abs ( r / ti ) < 1.0e-12_sp ) then
        exit
      end if
    end do

    ti = ti * x

  else

    ti = 1.0_sp
    r = 1.0_sp
    do k = 1, 10
      r = r / x
      ti = ti + a(k) * r
    end do
    rc1 = 1.0_sp / sqrt ( 2.0_sp * pi * x )
    ti = rc1 * exp ( x ) * ti

  end if

  if ( x < 12.0_sp ) then

    e0 = el + log ( x / 2.0_sp )
    b1 = 1.0_sp - e0
    b2 = 0.0_sp
    rs = 0.0_sp
    r = 1.0_sp
    do k = 1, 50
      r = 0.25_sp * r * ( 2 * k - 1.0_sp ) &
        / ( 2 * k + 1.0_sp ) / ( k * k ) * x2
      b1 = b1 + r * ( 1.0_sp / ( 2 * k + 1 ) - e0 )
      rs = rs + 1.0_sp / k
      b2 = b2 + r * rs
      tk = b1 + b2
      if ( abs ( ( tk - tw ) / tk ) < 1.0e-12_sp ) then
        exit
      end if
      tw = tk
    end do

    tk = tk * x

  else

    tk = 1.0_sp
    r = 1.0_sp
    do k = 1, 10
      r = -r / x
      tk = tk + a(k) * r
    end do 
    rc2 = sqrt ( pi / ( 2.0_sp * x ) )
    tk = pi / 2.0_sp - rc2 * tk * exp ( - x )

  end if

end subroutine itika


attributes(device) subroutine itikb ( x, ti, tk )

!*****************************************************************************80
!
!! ITIKB computes the integral of the Bessel functions I0(t) and K0(t).
!
!  Discussion:
!
!    This procedure integrates Bessel functions I0(t) and K0(t)
!    with respect to t from 0 to x.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    24 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
! 
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the upper limit of the integral.
!
!    Output, real(kind=sp) ::  TI, TK, the integral of I0(t) and K0(t)
!    from 0 to X.
!
  implicit none

  real(kind=sp) ::  pi
  real(kind=sp) ::  t
  real(kind=sp) ::  t1
  real(kind=sp) ::  ti
  real(kind=sp) ::  tk
  real(kind=sp) ::  x

  pi = 3.141592653589793_sp

  if ( x == 0.0_sp ) then

    ti = 0.0_sp

  else if ( x < 5.0_sp ) then

    t1 = x / 5.0_sp
    t = t1 * t1
    ti = (((((((( &
        0.59434e-03_sp * t &
      + 0.4500642e-02_sp ) * t &
      + 0.044686921_sp ) * t &
      + 0.300704878_sp ) * t &
      + 1.471860153_sp ) * t &
      + 4.844024624_sp ) * t &
      + 9.765629849_sp ) * t &
      +10.416666367_sp ) * t &
      + 5.0_sp ) * t1

  else if ( 5.0_sp <= x .and. x <= 8.0_sp ) then

    t = 5.0_sp / x
    ti = ((( &
      - 0.015166_sp * t &
      - 0.0202292_sp ) * t &
      + 0.1294122_sp ) * t &
      - 0.0302912_sp ) * t &
      + 0.4161224_sp
    ti = ti * exp ( x ) / sqrt ( x )

  else

    t = 8.0_sp / x
    ti = ((((( &
      - 0.0073995_sp * t &
      + 0.017744_sp ) * t &
      - 0.0114858_sp ) * t &
      + 0.55956e-02_sp ) * t &
      + 0.59191e-02_sp ) * t &
      + 0.0311734_sp ) * t &
      + 0.3989423_sp
    ti = ti * exp ( x ) / sqrt ( x )

  end if

  if ( x == 0.0_sp ) then

    tk = 0.0_sp

  else if ( x <= 2.0_sp ) then

    t1 = x / 2.0_sp
    t = t1 * t1
    tk = (((((( &
        0.116e-05_sp        * t &
      + 0.2069e-04_sp )     * t &
      + 0.62664e-03_sp )    * t &
      + 0.01110118_sp ) * t &
      + 0.11227902_sp ) * t &
      + 0.50407836_sp ) * t &
      + 0.84556868_sp ) * t1
    tk = tk - log ( x / 2.0_sp ) * ti

  else if ( 2.0_sp < x .and. x <= 4.0_sp ) then

    t = 2.0_sp / x
    tk = ((( &
        0.0160395_sp   * t &
      - 0.0781715_sp ) * t &
      + 0.185984_sp )  * t &
      - 0.3584641_sp ) * t &
      + 1.2494934_sp
    tk = pi / 2.0_sp - tk * exp ( - x ) / sqrt ( x )

  else if ( 4.0_sp < x .and. x <= 7.0_sp ) then

    t = 4.0_sp / x
    tk = ((((( &
        0.37128e-02_sp * t &
      - 0.0158449_sp ) * t &
      + 0.0320504_sp ) * t &
      - 0.0481455_sp ) * t &
      + 0.0787284_sp ) * t &
      - 0.1958273_sp ) * t &
      + 1.2533141_sp
    tk = pi / 2.0_sp - tk * exp ( - x ) / sqrt ( x )

  else

    t = 7.0_sp / x
    tk = ((((( &
        0.33934e-03_sp      * t &
      - 0.163271e-02_sp )   * t &
      + 0.417454e-02_sp )   * t &
      - 0.933944e-02_sp )   * t &
      + 0.02576646_sp ) * t &
      - 0.11190289_sp ) * t &
      + 1.25331414_sp
    tk = pi / 2.0_sp - tk * exp ( - x ) / sqrt ( x )

  end if

end subroutine itikb


attributes(device) subroutine itjya ( x, tj, ty )

!*****************************************************************************80
!
!! ITJYA computes integrals of Bessel functions J0(t) and Y0(t).
!
!  Discussion:
!
!    This procedure integrates Bessel functions J0(t) and Y0(t) with
!    respect to t from 0 to x.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    25 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the upper limit of the integral.
!
!    Output, real(kind=sp) ::  TJ, TY, the integrals of J0(t) and Y0(t) 
!    from 0 to x.
!
  implicit none

  real(kind=sp) ::  a(18)
  real(kind=sp) ::  a0
  real(kind=sp) ::  a1
  real(kind=sp) ::  af
  real(kind=sp) ::  bf
  real(kind=sp) ::  bg
  real(kind=sp) ::  el
  real(kind=sp) ::  eps
  integer(kind=i4) :: k
  real(kind=sp) ::  pi
  real(kind=sp) ::  r
  real(kind=sp) ::  r2
  real(kind=sp) ::  rc
  real(kind=sp) ::  rs
  real(kind=sp) ::  tj
  real(kind=sp) ::  ty
  real(kind=sp) ::  ty1
  real(kind=sp) ::  ty2
  real(kind=sp) ::  x
  real(kind=sp) ::  x2
  real(kind=sp) ::  xp

  pi = 3.141592653589793_sp
  el = 0.5772156649015329_sp
  eps = 1.0e-12

  if ( x == 0.0_sp ) then

    tj = 0.0_sp
    ty = 0.0_sp

  else if ( x <= 20.0_sp ) then

    x2 = x * x
    tj = x
    r = x
    do k = 1, 60
      r = -0.25_sp * r * ( 2 * k - 1.0_sp ) / ( 2 * k + 1.0_sp ) &
        / ( k * k ) * x2
      tj = tj + r
      if ( abs ( r ) < abs ( tj ) * eps ) then
        exit
      end if
    end do

    ty1 = ( el + log ( x / 2.0_sp ) ) * tj
    rs = 0.0_sp
    ty2 = 1.0_sp
    r = 1.0_sp

    do k = 1, 60
      r = -0.25_sp * r * ( 2 * k - 1.0_sp ) / ( 2 * k + 1.0_sp ) &
        / ( k * k ) * x2
      rs = rs + 1.0_sp / k
      r2 = r * ( rs + 1.0_sp / ( 2.0_sp * k + 1.0_sp ) )
      ty2 = ty2 + r2
      if ( abs ( r2 ) < abs ( ty2 ) * eps ) then
        exit
      end if
    end do

    ty = ( ty1 - x * ty2 ) * 2.0_sp / pi

  else

    a0 = 1.0_sp
    a1 = 5.0_sp / 8.0_sp
    a(1) = a1

    do k = 1, 16
      af = ( ( 1.5_sp * ( k + 0.5_sp ) * ( k + 5.0_sp / 6.0_sp ) &
        * a1 - 0.5_sp * ( k + 0.5_sp ) * ( k + 0.5_sp )  &
        * ( k - 0.5_sp ) * a0 ) ) / ( k + 1.0_sp )
      a(k+1) = af
      a0 = a1
      a1 = af
    end do

    bf = 1.0_sp
    r = 1.0_sp
    do k = 1, 8
      r = -r / ( x * x )
      bf = bf + a(2*k) * r
    end do
    bg = a(1) / x
    r = 1.0_sp / x
    do k = 1, 8
      r = -r / ( x * x )
      bg = bg + a(2*k+1) * r
    end do
    xp = x + 0.25_sp * pi
    rc = sqrt ( 2.0_sp / ( pi * x ) )
    tj = 1.0_sp - rc * ( bf * cos ( xp ) + bg * sin ( xp ) )
    ty = rc * ( bg * cos ( xp ) - bf * sin ( xp ) )

  end if
  
end subroutine itjya


attributes(device) subroutine itjyb ( x, tj, ty )

!*****************************************************************************80
!
!! ITJYB computes integrals of Bessel functions J0(t) and Y0(t).
!
!  Discussion:
!
!    This procedure integrates Bessel functions J0(t) and Y0(t)
!    with respect to t from 0 to x.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    25 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the upper limit of the integral.
!
!    Output, real(kind=sp) ::  TJ, TY, the integrals of J0(t) and Y0(t) 
!    from 0 to x.
!
  implicit none

  real(kind=sp) ::  f0
  real(kind=sp) ::  g0
  real(kind=sp) ::  pi
  real(kind=sp) ::  t
  real(kind=sp) ::  tj
  real(kind=sp) ::  ty
  real(kind=sp) ::  x
  real(kind=sp) ::  x1
  real(kind=sp) ::  xt

  pi = 3.141592653589793_sp

  if ( x == 0.0_sp ) then

    tj = 0.0_sp
    ty = 0.0_sp

  else if ( x <= 4.0_sp ) then

    x1 = x / 4.0_sp
    t = x1 * x1

    tj = ((((((( &
      - 0.133718e-03_sp      * t &
      + 0.2362211e-02_sp )   * t &
      - 0.025791036_sp ) * t &
      + 0.197492634_sp ) * t &
      - 1.015860606_sp ) * t &
      + 3.199997842_sp ) * t &
      - 5.333333161_sp ) * t &
      + 4.0_sp ) * x1

    ty = (((((((( &
        0.13351e-04_sp       * t &
      - 0.235002e-03_sp )    * t &
      + 0.3034322e-02_sp )   * t &
      - 0.029600855_sp ) * t &
      + 0.203380298_sp ) * t &
      - 0.904755062_sp ) * t &
      + 2.287317974_sp ) * t &
      - 2.567250468_sp ) * t &
      + 1.076611469_sp ) * x1

    ty = 2.0_sp / pi * log ( x / 2.0_sp ) * tj - ty

  else if ( x <= 8.0_sp ) then

    xt = x - 0.25_sp * pi
    t = 16.0_sp / ( x * x )

    f0 = (((((( &
        0.1496119e-02_sp     * t &
      - 0.739083e-02_sp )    * t &
      + 0.016236617_sp ) * t &
      - 0.022007499_sp ) * t &
      + 0.023644978_sp ) * t &
      - 0.031280848_sp ) * t &
      + 0.124611058_sp ) * 4.0_sp / x

    g0 = ((((( &
        0.1076103e-02_sp     * t &
      - 0.5434851e-02_sp )   * t &
      + 0.01242264_sp )  * t &
      - 0.018255209_sp ) * t &
      + 0.023664841_sp ) * t &
      - 0.049635633_sp ) * t &
      + 0.79784879_sp

    tj = 1.0_sp - ( f0 * cos ( xt ) - g0 * sin ( xt ) ) / sqrt ( x )

    ty = - ( f0 * sin ( xt ) + g0 * cos ( xt ) ) / sqrt ( x )

  else

    t = 64.0_sp / ( x * x )
    xt = x-0.25_sp * pi

    f0 = ((((((( &
      - 0.268482e-04_sp     * t &
      + 0.1270039e-03_sp )  * t &
      - 0.2755037e-03_sp )  * t &
      + 0.3992825e-03_sp )  * t &
      - 0.5366169e-03_sp )  * t &
      + 0.10089872e-02_sp ) * t &
      - 0.40403539e-02_sp ) * t &
      + 0.0623347304_sp ) * 8.0_sp / x

    g0 = (((((( &
      - 0.226238e-04_sp        * t &
      + 0.1107299e-03_sp )     * t &
      - 0.2543955e-03_sp )     * t &
      + 0.4100676e-03_sp )     * t &
      - 0.6740148e-03_sp )     * t &
      + 0.17870944e-02_sp )    * t &
      - 0.01256424405_sp ) * t &
      + 0.79788456_sp

    tj = 1.0_sp  - ( f0 * cos ( xt ) - g0 * sin ( xt ) ) / sqrt ( x )

    ty = - ( f0 * sin ( xt ) + g0 * cos ( xt ) ) / sqrt ( x )

  end if

end subroutine itjyb


attributes(device) subroutine itsh0 ( x, th0 )

!*****************************************************************************80
!
!! ITSH0 integrates the Struve function H0(t) from 0 to x.
!
!  Discussion:
!
!    This procedure evaluates the integral of Struve function
!    H0(t) with respect to t from 0 and x.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    25 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the upper limit of the integral.
!
!    Output, real(kind=sp) ::  TH0, the integral of H0(t) from 0 to x.
!
  implicit none

  real(kind=sp) ::  a(25)
  real(kind=sp) ::  a0
  real(kind=sp) ::  a1
  real(kind=sp) ::  af
  real(kind=sp) ::  bf
  real(kind=sp) ::  bg
  real(kind=sp) ::  el
  integer(kind=i4) :: k
  real(kind=sp) ::  pi
  real(kind=sp) ::  r
  real(kind=sp) ::  rd
  real(kind=sp) ::  s
  real(kind=sp) ::  s0
  real(kind=sp) ::  th0
  real(kind=sp) ::  ty
  real(kind=sp) ::  x
  real(kind=sp) ::  xp

  pi = 3.141592653589793_sp
  r = 1.0_sp            

  if ( x <= 30.0_sp ) then

    s = 0.5_sp

    do k = 1, 100

      if ( k == 1 ) then
        rd = 0.5_sp
      else
        rd = 1.0_sp
      end if

      r = - r * rd * k / ( k + 1.0_sp ) &
        * ( x / ( 2.0_sp * k + 1.0_sp ) ) ** 2
      s = s + r

      if ( abs ( r ) < abs ( s ) * 1.0e-12_sp ) then
        exit
      end if

    end do

    th0 = 2.0_sp / pi * x * x * s

  else

    s = 1.0_sp
    do k = 1, 12
      r = - r * k / ( k + 1.0_sp ) &
        * ( ( 2.0_sp * k + 1.0_sp ) / x ) ** 2
      s = s + r
      if ( abs ( r ) < abs ( s ) * 1.0e-12_sp ) then
        exit
      end if
    end do

    el = 0.57721566490153_sp
    s0 = s / ( pi * x * x ) + 2.0_sp / pi &
      * ( log ( 2.0_sp * x ) + el )
    a0 = 1.0_sp
    a1 = 5.0_sp / 8.0_sp
    a(1) = a1
    do k = 1, 20
      af = ( ( 1.5_sp * ( k + 0.5_sp ) &
        * ( k + 5.0_sp / 6.0_sp ) * a1 - 0.5_sp &
        * ( k + 0.5_sp ) * ( k + 0.5_sp ) &
        * ( k - 0.5_sp ) * a0 ) ) / ( k + 1.0_sp )
      a(k+1) = af
      a0 = a1
      a1 = af
    end do

    bf = 1.0_sp
    r = 1.0_sp
    do k = 1, 10
      r = - r / ( x * x )
      bf = bf + a(2*k) * r
    end do
    bg = a(1) / x
    r = 1.0_sp / x
    do k = 1, 10
      r = - r / ( x * x ) 
      bg = bg + a(2*k+1) * r
    end do
    xp = x + 0.25_sp * pi
    ty = sqrt ( 2.0_sp / ( pi * x ) ) &
      * ( bg * cos ( xp ) - bf * sin ( xp ) )
    th0 = ty + s0

  end if
  
end subroutine itsh0


attributes(device) subroutine itsl0 ( x, tl0 )

!*****************************************************************************80
!
!! ITSL0 integrates the Struve function L0(t) from 0 to x.
!
!  Discussion:
!
!    This procedure evaluates the integral of modified Struve function
!    L0(t) with respect to t from 0 to x.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    31 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the upper limit of the integral.
!
!    Output, real(kind=sp) ::  TL0, the integral of L0(t) from 0 to x.
!
  implicit none

  real(kind=sp) ::  a(18)
  real(kind=sp) ::  a0
  real(kind=sp) ::  a1
  real(kind=sp) ::  af
  real(kind=sp) ::  el
  integer(kind=i4) :: k
  real(kind=sp) ::  pi
  real(kind=sp) ::  r
  real(kind=sp) ::  rd
  real(kind=sp) ::  s
  real(kind=sp) ::  s0
  real(kind=sp) ::  ti
  real(kind=sp) ::  tl0
  real(kind=sp) ::  x

  pi = 3.141592653589793_sp
  r = 1.0_sp

  if ( x <= 20.0_sp ) then

    s = 0.5_sp
    do k = 1, 100
 
      if ( k == 1 ) then
        rd = 0.5_sp
      else
        rd = 1.0_sp
      end if
      r = r * rd * k / ( k + 1.0_sp ) &
        * ( x / ( 2.0_sp * k + 1.0_sp ) ) ** 2
      s = s + r
      if ( abs ( r / s ) < 1.0e-12_sp ) then
        exit
      end if
    end do

    tl0 = 2.0_sp / pi * x * x * s

  else

    s = 1.0_sp
    do k = 1, 10
      r = r * k / ( k + 1.0_sp ) &
        * ( ( 2.0_sp * k + 1.0_sp ) / x ) ** 2
      s = s + r
      if ( abs ( r / s ) < 1.0e-12_sp ) then
        exit
      end if
    end do

    el = 0.57721566490153_sp
    s0 = - s / ( pi * x * x ) + 2.0_sp / pi &
      * ( log ( 2.0_sp * x ) + el )
    a0 = 1.0_sp
    a1 = 5.0_sp / 8.0_sp
    a(1) = a1
    do k = 1, 10
      af = ( ( 1.5_sp * ( k + 0.50_sp ) &
        * ( k + 5.0_sp / 6.0_sp ) * a1 - 0.5_sp &
        * ( k + 0.5_sp ) ** 2 * ( k -0.5_sp ) * a0 ) ) &
        / ( k + 1.0_sp )
      a(k+1) = af
      a0 = a1
      a1 = af
    end do

    ti = 1.0_sp
    r = 1.0_sp
    do k = 1, 11
      r = r / x
      ti = ti + a(k) * r
    end do
    tl0 = ti / sqrt ( 2.0_sp * pi * x ) * exp ( x ) + s0

  end if

  
end subroutine itsl0 


subroutine itth0 ( x, tth )

!*****************************************************************************80
!
!! ITTH0 integrates H0(t)/t from x to oo.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    23 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the lower limit of the integral.
!
!    Output, real(kind=sp) ::  TTH, the integral of H0(t)/t from x to oo.
!
  implicit none

  real(kind=sp) ::  f0
  real(kind=sp) ::  g0
  integer(kind=i4) :: k
  real(kind=sp) ::  pi
  real(kind=sp) ::  r
  real(kind=sp) ::  s
  real(kind=sp) ::  t
  real(kind=sp) ::  tth
  real(kind=sp) ::  tty
  real(kind=sp) ::  x
  real(kind=sp) ::  xt

  pi = 3.141592653589793_sp
  s = 1.0_sp
  r = 1.0_sp

  if ( x < 24.5_sp ) then

    do k = 1, 60
      r = - r * x * x * ( 2.0_sp * k - 1.0_sp ) &
        / ( 2.0_sp * k + 1.0_sp ) ** 3
      s = s + r
      if ( abs ( r ) < abs ( s ) * 1.0e-12_sp ) then
        exit
      end if
    end do

    tth = pi / 2.0_sp - 2.0_sp / pi * x * s

  else

    do k = 1, 10
      r = - r * ( 2.0_sp * k - 1.0_sp ) ** 3 &
        / ( ( 2.0_sp * k + 1.0_sp ) * x * x )
      s = s + r
      if ( abs ( r ) < abs ( s ) * 1.0e-12_sp ) then
        exit
      end if
    end do

    tth = 2.0_sp / ( pi * x ) * s
    t = 8.0_sp / x
    xt = x + 0.25_sp * pi
    f0 = ((((( &
        0.18118e-02_sp * t &
      - 0.91909e-02_sp ) * t &
      + 0.017033_sp ) * t &
      - 0.9394e-03_sp ) * t &
      - 0.051445_sp ) * t &
      - 0.11e-05_sp ) * t &
      + 0.7978846_sp
    g0 = ((((( &
      - 0.23731e-02_sp * t &
      + 0.59842e-02_sp ) * t &
      + 0.24437e-02_sp ) * t &
      - 0.0233178_sp ) * t &
      + 0.595e-04_sp ) * t &
      + 0.1620695_sp ) * t
    tty = ( f0 * sin ( xt ) - g0 * cos ( xt ) ) / ( sqrt ( x ) * x )
    tth = tth + tty

    end if
  
end subroutine itth0


attributes(device) subroutine ittika ( x, tti, ttk )

!*****************************************************************************80
!
!! ITTIKA integrates (I0(t)-1)/t from 0 to x, K0(t)/t from x to infinity.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    23 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the integral limit.
!
!    Output, real(kind=sp) ::  TTI, TTK, the integrals of [I0(t)-1]/t 
!    from 0 to x, and of K0(t)/t from x to oo.
!
  implicit none

  real(kind=sp) ::  b1
  real(kind=sp)  , dimension ( 8 ) :: c = (/ &
    1.625_sp, 4.1328125_sp, &
    1.45380859375e+01_sp, 6.553353881835e+01_sp, &
    3.6066157150269e+02_sp, 2.3448727161884e+03_sp, &
    1.7588273098916e+04_sp, 1.4950639538279e+05_sp /)
  real(kind=sp) ::  e0
  real(kind=sp) ::  el
  integer(kind=i4) :: k
  real(kind=sp) ::  pi
  real(kind=sp) ::  r
  real(kind=sp) ::  r2
  real(kind=sp) ::  rc
  real(kind=sp) ::  rs
  real(kind=sp) ::  tti
  real(kind=sp) ::  ttk
  real(kind=sp) ::  x

  pi = 3.141592653589793_sp
  el = 0.5772156649015329_sp

 

  if ( x < 40.0_sp ) then
    tti = 1.0_sp
    r = 1.0_sp
    do k = 2, 50
      r = 0.25_sp * r * ( k - 1.0_sp ) / ( k * k * k ) * x * x
      tti = tti + r
      if ( abs ( r / tti ) < 1.0e-12_sp ) then
        exit
      end if
    end do

    tti = tti * 0.125_sp * x * x

  else

    tti = 1.0_sp
    r = 1.0_sp
    do k = 1, 8
      r = r / x
      tti = tti + c(k) * r
    end do
    rc = x * sqrt ( 2.0_sp * pi * x )
    tti = tti * exp ( x ) / rc

  end if

  if ( x <= 12.0_sp ) then

    e0 = ( 0.5_sp * log ( x / 2.0_sp ) + el ) &
      * log ( x / 2.0_sp ) + pi * pi / 24.0_sp + 0.5_sp * el * el
    b1 = 1.5_sp - ( el + log ( x / 2.0_sp ) )
    rs = 1.0_sp
    r = 1.0_sp
    do k = 2, 50
      r = 0.25_sp * r * ( k - 1.0_sp ) / ( k * k * k ) * x * x
      rs = rs + 1.0_sp / k
      r2 = r * ( rs + 1.0_sp / ( 2.0_sp * k ) &
        - ( el + log ( x / 2.0_sp ) ) )
      b1 = b1 + r2
      if ( abs ( r2 / b1 ) < 1.0e-12_sp ) then
        exit
      end if
    end do

    ttk = e0 - 0.125_sp * x * x * b1

  else

    ttk = 1.0_sp
    r = 1.0_sp
    do k = 1, 8
      r = - r / x
      ttk = ttk + c(k) * r
    end do
    rc = x * sqrt ( 2.0_sp / pi * x )
    ttk = ttk * exp ( - x ) / rc

  end if
  
end subroutine ittika


attributes(device) subroutine ittikb ( x, tti, ttk )

!*****************************************************************************80
!
!! ITTIKB integrates (I0(t)-1)/t from 0 to x, K0(t)/t from x to infinity.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    28 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the integral limit.
!
!    Output, real(kind=sp) ::  TTI, TTK, the integrals of
!    [I0(t)-1]/t from 0 to x, and K0(t)/t from x to oo.
!
  implicit none

  real(kind=sp) ::  e0
  real(kind=sp) ::  el
  real(kind=sp) ::  pi
  real(kind=sp) ::  t
  real(kind=sp) ::  t1
  real(kind=sp) ::  tti
  real(kind=sp) ::  ttk
  real(kind=sp) ::  x
  real(kind=sp) ::  x1

  pi = 3.141592653589793_sp
  el = 0.5772156649015329_sp

  if ( x == 0.0_sp ) then

    tti = 0.0_sp

  else if ( x <= 5.0_sp ) then

    x1 = x / 5.0_sp
    t = x1 * x1
    tti = ((((((( &
        0.1263e-03_sp       * t &
      + 0.96442e-03_sp )    * t &
      + 0.968217e-02_sp )   * t &
      + 0.06615507_sp ) * t &
      + 0.33116853_sp ) * t &
      + 1.13027241_sp ) * t &
      + 2.44140746_sp ) * t &
      + 3.12499991_sp ) * t

  else

    t = 5.0_sp / x
    tti = ((((((((( &
         2.1945464_sp   * t &
      -  3.5195009_sp ) * t &
      - 11.9094395_sp ) * t &
      + 40.394734_sp  ) * t &
      - 48.0524115_sp ) * t &
      + 28.1221478_sp ) * t &
      -  8.6556013_sp ) * t &
      +  1.4780044_sp ) * t &
      -  0.0493843_sp ) * t &
      +  0.1332055_sp ) * t &
      +  0.3989314_sp
    tti = tti * exp ( x ) / ( sqrt ( x ) * x )

  end if

  if ( x == 0.0_sp ) then

    ttk = huge(1.0_sp,kind=sp)

  else if ( x <= 2.0_sp ) then

    t1 = x / 2.0_sp
    t = t1 * t1
    ttk = ((((( &
        0.77e-06_sp         * t &
      + 0.1544e-04_sp )     * t &
      + 0.48077e-03_sp )    * t &
      + 0.925821e-02_sp )   * t &
      + 0.10937537_sp ) * t &
      + 0.74999993_sp ) * t
    e0 = el + log ( x / 2.0_sp )
    ttk = pi * pi / 24.0_sp + e0 * ( 0.5_sp * e0 + tti ) - ttk

  else if ( x <= 4.0_sp ) then

    t = 2.0_sp / x
    ttk = ((( &
        0.06084_sp    * t &
      - 0.280367_sp ) * t &
      + 0.590944_sp ) * t &
      - 0.850013_sp ) * t &
      + 1.234684_sp
    ttk = ttk * exp ( - x ) / ( sqrt ( x ) * x )

  else

    t = 4.0_sp / x
    ttk = ((((( &
        0.02724_sp     * t &
      - 0.1110396_sp ) * t &
      + 0.2060126_sp ) * t &
      - 0.2621446_sp ) * t &
      + 0.3219184_sp ) * t &
      - 0.5091339_sp ) * t &
      + 1.2533141_sp
    ttk = ttk * exp ( - x ) / ( sqrt ( x ) * x )

  end if

end subroutine ittikb


attributes(device) subroutine ittjya ( x, ttj, tty )

!*****************************************************************************80
!
!! ITTJYA integrates (1-J0(t))/t from 0 to x, and Y0(t)/t from x to infinity.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    28 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the integral limit.
!
!    Output, real(kind=sp) ::  TTJ, TTY, the integrals of [1-J0(t)]/t 
!    from 0 to x and of Y0(t)/t from x to oo.
!
  implicit none

  real(kind=sp) ::  a0
  real(kind=sp) ::  b1
  real(kind=sp) ::  bj0
  real(kind=sp) ::  bj1
  real(kind=sp) ::  by0
  real(kind=sp) ::  by1
  real(kind=sp) ::  e0
  real(kind=sp) ::  el
  real(kind=sp) ::  g0
  real(kind=sp) ::  g1
  integer(kind=i4) :: k
  integer(kind=i4) :: l
  real(kind=sp) ::  pi
  real(kind=sp) ::  px
  real(kind=sp) ::  qx
  real(kind=sp) ::  r
  real(kind=sp) ::  r0
  real(kind=sp) ::  r1
  real(kind=sp) ::  r2
  real(kind=sp) ::  rs
  real(kind=sp) ::  t
  real(kind=sp) ::  ttj
  real(kind=sp) ::  tty
  real(kind=sp) ::  vt
  real(kind=sp) ::  x
  real(kind=sp) ::  xk

  pi = 3.141592653589793_sp
  el = 0.5772156649015329_sp

  if ( x == 0.0_sp ) then

    ttj = 0.0_sp
    tty = -huge(1.0_sp,kind=sp)

  else if ( x <= 20.0_sp ) then

    ttj = 1.0_sp
    r = 1.0_sp
    do k = 2, 100
      r = - 0.25_sp * r * ( k - 1.0_sp ) / ( k * k * k ) * x * x
      ttj = ttj + r
      if ( abs ( r ) < abs ( ttj ) * 1.0e-12_sp ) then
        exit
      end if
    end do

    ttj = ttj * 0.125_sp * x * x
    e0 = 0.5_sp * ( pi * pi / 6.0_sp - el * el ) &
      - ( 0.5_sp * log ( x / 2.0_sp ) + el ) &
      * log ( x / 2.0_sp )
    b1 = el + log ( x / 2.0_sp ) - 1.5_sp
    rs = 1.0_sp
    r = -1.0_sp
    do k = 2, 100
      r = - 0.25_sp * r * ( k - 1.0_sp ) / ( k * k * k ) * x * x
      rs = rs + 1.0_sp / k
      r2 = r * ( rs + 1.0_sp / ( 2.0_sp * k ) &
        - ( el + log ( x / 2.0_sp ) ) ) 
      b1 = b1 + r2
      if ( abs ( r2 ) < abs ( b1 ) * 1.0e-12_sp ) then
        exit
      end if
    end do

    tty = 2.0_sp / pi * ( e0 + 0.125_sp * x * x * b1 )

  else

    a0 = sqrt ( 2.0_sp / ( pi * x ) )

    do l = 0, 1

      vt = 4.0_sp * l * l
      px = 1.0_sp
      r = 1.0_sp
      do k = 1, 14
        r = - 0.0078125_sp * r &
          * ( vt - ( 4.0_sp * k - 3.0_sp ) ** 2 ) &
          / ( x * k ) * ( vt - ( 4.0_sp * k - 1.0_sp ) ** 2 ) &
          / ( ( 2.0_sp * k - 1.0_sp ) * x )
        px = px + r
        if ( abs ( r ) < abs ( px ) * 1.0e-12_sp ) then
          exit
        end if
      end do

      qx = 1.0_sp
      r = 1.0_sp
      do k = 1, 14
        r = -0.0078125_sp * r &
          * ( vt - ( 4.0_sp * k - 1.0_sp ) ** 2 ) &
          / ( x * k ) * ( vt - ( 4.0_sp * k + 1.0_sp ) ** 2 ) &
          / ( 2.0_sp * k + 1.0_sp ) / x
        qx = qx + r
        if ( abs ( r ) < abs ( qx ) * 1.0e-12_sp ) then
          exit
        end if
      end do

      qx = 0.125_sp * ( vt - 1.0_sp ) / x * qx
      xk = x - ( 0.25_sp + 0.5_sp * l ) * pi
      bj1 = a0 * ( px * cos ( xk ) - qx * sin ( xk ) )
      by1 = a0 * ( px * sin ( xk ) + qx * cos ( xk ) )
      if ( l == 0 ) then
        bj0 = bj1
        by0 = by1
      end if

    end do

    t = 2.0_sp / x
    g0 = 1.0_sp
    r0 = 1.0_sp
    do k = 1, 10
      r0 = - k * k * t * t *r0
      g0 = g0 + r0
    end do

    g1 = 1.0_sp
    r1 = 1.0_sp
    do k = 1, 10
      r1 = - k * ( k + 1.0_sp ) * t * t * r1
      g1 = g1 + r1
    end do

    ttj = 2.0_sp * g1 * bj0 / ( x * x ) - g0 * bj1 / x &
      + el + log ( x / 2.0_sp )
    tty = 2.0_sp * g1 * by0 / ( x * x ) - g0 * by1 / x

  end if
 
end subroutine ittjya


attributes(device) subroutine ittjyb ( x, ttj, tty )

!*****************************************************************************80
!
!! ITTJYB integrates (1-J0(t))/t from 0 to x, and Y0(t)/t from x to infinity.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    01 August 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the integral limit.
!
!    Output, real(kind=sp) ::  TTJ, TTY, the integrals of [1-J0(t)]/t 
!    from 0 to x and of Y0(t)/t from x to oo.
!
  implicit none

  real(kind=sp) ::  e0
  real(kind=sp) ::  el
  real(kind=sp) ::  f0
  real(kind=sp) ::  g0
  real(kind=sp) ::  pi
  real(kind=sp) ::  t
  real(kind=sp) ::  t1
  real(kind=sp) ::  ttj
  real(kind=sp) ::  tty
  real(kind=sp) ::  x
  real(kind=sp) ::  x1
  real(kind=sp) ::  xt

  pi = 3.141592653589793_sp
  el = 0.5772156649015329_sp

  if ( x == 0.0_sp ) then

    ttj = 0.0_sp
    tty = -huge(1.0_sp,kinds=sp)

  else if ( x <= 4.0_sp ) then

    x1 = x / 4.0_sp
    t = x1 * x1

    ttj = (((((( &
        0.35817e-04_sp * t &
      - 0.639765e-03_sp ) * t &
      + 0.7092535e-02_sp ) * t &
      - 0.055544803_sp ) * t &
      + 0.296292677_sp ) * t &
      - 0.999999326_sp ) * t &
      + 1.999999936_sp ) * t
 
    tty = ((((((( &
      - 0.3546e-05_sp        * t &
      + 0.76217e-04_sp )     * t &
      - 0.1059499e-02_sp )   * t &
      + 0.010787555_sp ) * t &
      - 0.07810271_sp )  * t &
      + 0.377255736_sp ) * t &
      - 1.114084491_sp ) * t &
      + 1.909859297_sp ) * t

    e0 = el + log ( x / 2.0_sp )
    tty = pi / 6.0_sp + e0 / pi * ( 2.0_sp * ttj - e0 ) - tty

  else if ( x <= 8.0_sp ) then

    xt = x + 0.25_sp * pi
    t1 = 4.0_sp / x
    t = t1 * t1

    f0 = ((((( &
        0.0145369_sp * t &
      - 0.0666297_sp ) * t &
      + 0.1341551_sp ) * t &
      - 0.1647797_sp ) * t &
      + 0.1608874_sp ) * t &
      - 0.2021547_sp ) * t &
      + 0.7977506_sp

    g0 = (((((( &
        0.0160672_sp   * t &
      - 0.0759339_sp ) * t &
      + 0.1576116_sp ) * t &
      - 0.1960154_sp ) * t &
      + 0.1797457_sp ) * t &
      - 0.1702778_sp ) * t &
      + 0.3235819_sp ) * t1

    ttj = ( f0 * cos ( xt ) + g0 * sin ( xt ) ) / ( sqrt ( x ) * x )
    ttj = ttj + el + log ( x / 2.0_sp )
    tty = ( f0 * sin ( xt ) - g0 * cos ( xt ) ) / ( sqrt ( x ) * x )

  else

    t = 8.0_sp / x
    xt = x + 0.25_sp * pi

    f0 = ((((( &
        0.18118e-02_sp    * t &
      - 0.91909e-02_sp )  * t &
      + 0.017033_sp ) * t &
      - 0.9394e-03_sp )   * t &
      - 0.051445_sp ) * t &
      - 0.11e-05_sp )     * t &
      + 0.7978846_sp

    g0 = ((((( &
      - 0.23731e-02_sp     * t &
      + 0.59842e-02_sp )   * t &
      + 0.24437e-02_sp )   * t &
      - 0.0233178_sp ) * t &
      + 0.595e-04_sp )     * t &
      + 0.1620695_sp ) * t

    ttj = ( f0 * cos ( xt ) + g0 * sin ( xt ) )  &
      / ( sqrt ( x ) * x ) + el + log ( x / 2.0_sp )
    tty = ( f0 * sin ( xt ) - g0 * cos ( xt ) )  &
      / ( sqrt ( x ) * x )

  end if

end subroutine ittjyb


attributes(device) subroutine jelp ( u, hk, esn, ecn, edn, eph )

!*****************************************************************************80
!
!! JELP computes Jacobian elliptic functions SN(u), CN(u), DN(u).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    08 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  U, the argument.
!
!    Input, real(kind=sp) ::  HK, the modulus, between 0 and 1.
!
!    Output, real(kind=sp) ::  ESN, ECN, EDN, EPH, the values of
!    sn(u), cn(u), dn(u), and phi (in degrees).
!
  implicit none

  real(kind=sp) ::  a
  real(kind=sp) ::  a0
  real(kind=sp) ::  b
  real(kind=sp) ::  b0
  real(kind=sp) ::  c
  real(kind=sp) ::  d
  real(kind=sp) ::  dn
  real(kind=sp) ::  ecn
  real(kind=sp) ::  edn
  real(kind=sp) ::  eph
  real(kind=sp) ::  esn
  real(kind=sp) ::  hk
  integer(kind=i4) :: j
  integer(kind=i4) :: n 
  real(kind=sp) ::  pi
  real(kind=sp) ::  r(40)
  real(kind=sp) ::  sa
  real(kind=sp) ::  t
  real(kind=sp) ::  u

  pi = 3.14159265358979_sp
  a0 = 1.0_sp
  b0 = sqrt ( 1.0_sp - hk * hk )

  do n = 1, 40

    a = ( a0 + b0 ) / 2.0_sp
    b = sqrt ( a0 * b0 )
    c = ( a0 - b0 ) / 2.0_sp
    r(n) = c / a

    if ( c < 1.0e-07_sp ) then
      exit
    end if

    a0 = a
    b0 = b

  end do

  dn = 2.0_sp ** n * a * u

  do j = n, 1, -1
    t = r(j) * sin ( dn )
    sa = atan ( t / sqrt ( abs ( 1.0_sp - t * t )))
    d = 0.5_sp * ( dn + sa )
    dn = d
  end do

  eph = d * 180.0_sp / pi
  esn = sin ( d )
  ecn = cos ( d )
  edn = sqrt ( 1.0_sp - hk * hk * esn * esn )

end subroutine jelp


attributes(device) subroutine jy01a ( x, bj0, dj0, bj1, dj1, by0, dy0, by1, dy1 )

!*****************************************************************************80
!
!! JY01A computes Bessel functions J0(x), J1(x), Y0(x), Y1(x) and derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    01 August 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  BJ0, DJ0, BJ1, DJ1, BY0, DY0, BY1, DY1,
!    the values of J0(x), J0'(x), J1(x), J1'(x), Y0(x), Y0'(x), Y1(x), Y1'(x).
!
  implicit none

  real(kind=sp) , dimension(12) :: a = (/ &
    -0.7031250000000000e-01, 0.1121520996093750_sp, &
    -0.5725014209747314_sp, 0.6074042001273483e+01, &
    -0.1100171402692467e+03, 0.3038090510922384e+04, &
    -0.1188384262567832e+06, 0.6252951493434797e+07, &
    -0.4259392165047669e+09, 0.3646840080706556e+11, &
    -0.3833534661393944e+13, 0.4854014686852901e+15 /)
  real(kind=sp) , dimension(12) :: a1 = (/ &
    0.1171875000000000_sp, -0.1441955566406250_sp, &
    0.6765925884246826_sp, -0.6883914268109947e+01, &
    0.1215978918765359e+03, -0.3302272294480852e+04, &
    0.1276412726461746e+06, -0.6656367718817688e+07, &
    0.4502786003050393e+09, -0.3833857520742790e+11, &
    0.4011838599133198e+13, -0.5060568503314727e+15 /)
  real(kind=sp) , dimension(12) :: b = (/ &
    0.7324218750000000e-01, -0.2271080017089844_sp, &
    0.1727727502584457e+01, -0.2438052969955606e+02, &
    0.5513358961220206e+03, -0.1825775547429318e+05, &
    0.8328593040162893e+06, -0.5006958953198893e+08, &
    0.3836255180230433e+10, -0.3649010818849833e+12, &
    0.4218971570284096e+14, -0.5827244631566907e+16 /)
  real(kind=sp) , dimension(12) :: b1 = (/ &
    -0.1025390625000000_sp, 0.2775764465332031_sp, &
    -0.1993531733751297e+01, 0.2724882731126854e+02, &
    -0.6038440767050702e+03, 0.1971837591223663e+05, &
    -0.8902978767070678e+06, 0.5310411010968522e+08, &
    -0.4043620325107754e+10, 0.3827011346598605e+12, &
    -0.4406481417852278e+14, 0.6065091351222699e+16 /)
  real(kind=sp) ::  bj0
  real(kind=sp) ::  bj1
  real(kind=sp) ::  by0
  real(kind=sp) ::  by1
  real(kind=sp) ::  cs0
  real(kind=sp) ::  cs1
  real(kind=sp) ::  cu
  real(kind=sp) ::  dj0
  real(kind=sp) ::  dj1
  real(kind=sp) ::  dy0
  real(kind=sp) ::  dy1
  real(kind=sp) ::  ec
  integer(kind=i4) :: k
  integer(kind=i4) :: k0
  real(kind=sp) ::  p0
  real(kind=sp) ::  p1
  real(kind=sp) ::  pi
  real(kind=sp) ::  q0
  real(kind=sp) ::  q1
  real(kind=sp) ::  r
  real(kind=sp) ::  r0
  real(kind=sp) ::  r1
  real(kind=sp) ::  rp2
  real(kind=sp) ::  t1
  real(kind=sp) ::  t2
  real(kind=sp) ::  w0
  real(kind=sp) ::  w1
  real(kind=sp) ::  x
  real(kind=sp) ::  x2

  pi = 3.141592653589793_sp
  rp2 = 0.63661977236758_sp
  x2 = x * x

  

  if ( x <= 12.0_sp ) then

    bj0 = 1.0_sp
    r = 1.0_sp
    do k = 1,30
      r = -0.25_sp * r * x2 / ( k * k )
      bj0 = bj0 + r
      if ( abs ( r ) < abs ( bj0 ) * 1.0e-15_sp ) then
        exit
      end if
    end do

    bj1 = 1.0_sp
    r = 1.0_sp
    do k = 1, 30
      r = -0.25_sp * r * x2 / ( k * ( k + 1.0_sp ) )
      bj1 = bj1 + r
      if ( abs ( r ) < abs ( bj1 ) * 1.0e-15_sp ) then
        exit
      end if
    end do

    bj1 = 0.5_sp * x * bj1
    ec = log ( x / 2.0_sp ) + 0.5772156649015329_sp
    cs0 = 0.0_sp
    w0 = 0.0_sp
    r0 = 1.0_sp
    do k = 1, 30
      w0 = w0 + 1.0_sp / k
      r0 = -0.25_sp * r0 / ( k * k ) * x2
      r = r0 * w0
      cs0 = cs0 + r
      if ( abs ( r ) < abs ( cs0 ) * 1.0e-15_sp ) then
        exit
      end if
    end do

    by0 = rp2 * ( ec * bj0 - cs0 )
    cs1 = 1.0_sp
    w1 = 0.0_sp
    r1 = 1.0_sp
    do k = 1, 30
      w1 = w1 + 1.0_sp / k
      r1 = -0.25_sp * r1 / ( k * ( k + 1 ) ) * x2
      r = r1 * ( 2.0_sp * w1 + 1.0_sp / ( k + 1.0_sp ) )
      cs1 = cs1 + r
      if ( abs ( r ) < abs ( cs1 ) * 1.0e-15_sp ) then
        exit
      end if
    end do

    by1 = rp2 * ( ec * bj1 - 1.0_sp / x - 0.25_sp * x * cs1 )

  else

    if ( x < 35.0_sp ) then
      k0 = 12
    else if ( x < 50.0_sp ) then
      k0 = 10
    else
      k0 = 8
    end if

    t1 = x - 0.25_sp * pi
    p0 = 1.0_sp
    q0 = -0.125_sp / x
    do k = 1, k0
      p0 = p0 + a(k) * x ** ( - 2 * k )
      q0 = q0 + b(k) * x ** ( - 2 * k - 1 )
    end do
    cu = sqrt ( rp2 / x )
    bj0 = cu * ( p0 * cos ( t1 ) - q0 * sin ( t1 ) )
    by0 = cu * ( p0 * sin ( t1 ) + q0 * cos ( t1 ) )
    t2 = x - 0.75_sp * pi
    p1 = 1.0_sp
    q1 = 0.375_sp / x
    do k = 1, k0
      p1 = p1 + a1(k) * x ** ( - 2 * k )
      q1 = q1 + b1(k) * x ** ( - 2 * k - 1 )
    end do
    cu = sqrt ( rp2 / x )
    bj1 = cu * ( p1 * cos ( t2 ) - q1 * sin ( t2 ) )
    by1 = cu * ( p1 * sin ( t2 ) + q1 * cos ( t2 ) )

  end if

  dj0 = - bj1
  dj1 = bj0 - bj1 / x
  dy0 = - by1
  dy1 = by0 - by1 / x

 
end subroutine jy01a


attributes(device) subroutine jy01b ( x, bj0, dj0, bj1, dj1, by0, dy0, by1, dy1 )

!*****************************************************************************80
!
!! JY01B computes Bessel functions J0(x), J1(x), Y0(x), Y1(x) and derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    02 August 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  BJ0, DJ0, BJ1, DJ1, BY0, DY0, BY1, DY1,
!    the values of J0(x), J0'(x), J1(x), J1'(x), Y0(x), Y0'(x), Y1(x), Y1'(x).
!
  implicit none

  real(kind=sp) ::  a0
  real(kind=sp) ::  bj0
  real(kind=sp) ::  bj1
  real(kind=sp) ::  by0
  real(kind=sp) ::  by1
  real(kind=sp) ::  dj0
  real(kind=sp) ::  dj1
  real(kind=sp) ::  dy0
  real(kind=sp) ::  dy1
  real(kind=sp) ::  p0
  real(kind=sp) ::  p1
  real(kind=sp) ::  pi
  real(kind=sp) ::  q0
  real(kind=sp) ::  q1
  real(kind=sp) ::  t
  real(kind=sp) ::  t2
  real(kind=sp) ::  ta0
  real(kind=sp) ::  ta1
  real(kind=sp) ::  x

  pi = 3.141592653589793_sp

  

  if ( x <= 4.0_sp ) then

    t = x * 0.25_sp
    t2 = t * t

    bj0 = (((((( &
      - 0.5014415e-03_sp * t2 &
      + 0.76771853e-02_sp ) * t2 &
      - 0.0709253492_sp ) * t2 &
      + 0.4443584263_sp ) * t2 &
      - 1.7777560599_sp ) * t2 &
      + 3.9999973021_sp ) * t2 &
      - 3.9999998721_sp ) * t2 &
      + 1.0_sp

    bj1 = t * ((((((( &
      - 0.1289769e-03_sp * t2 &
      + 0.22069155e-02_sp ) * t2 &
      - 0.0236616773_sp ) * t2 &
      + 0.1777582922_sp ) * t2 &
      - 0.8888839649_sp ) * t2 &
      + 2.6666660544_sp ) * t2 &
      - 3.9999999710_sp ) * t2 &
      + 1.9999999998_sp )

    by0 = ((((((( &
      - 0.567433e-04_sp * t2 &
      + 0.859977e-03_sp ) * t2 &
      - 0.94855882e-02_sp ) * t2 &
      + 0.0772975809_sp ) * t2 &
      - 0.4261737419_sp ) * t2 &
      + 1.4216421221_sp ) * t2 &
      - 2.3498519931_sp ) * t2 &
      + 1.0766115157_sp ) * t2 &
      + 0.3674669052_sp

    by0 = 2.0_sp / pi * log ( x * 0.5_sp ) * bj0 + by0

    by1 = (((((((( &
        0.6535773e-03_sp * t2 &
      - 0.0108175626_sp ) * t2 &
      + 0.107657606_sp ) * t2 &
      - 0.7268945577_sp ) * t2 &
      + 3.1261399273_sp ) * t2 &
      - 7.3980241381_sp ) * t2 &
      + 6.8529236342_sp ) * t2 &
      + 0.3932562018_sp ) * t2 &
      - 0.6366197726_sp ) / x

    by1 = 2.0_sp / pi * log ( x * 0.5_sp ) * bj1 + by1

  else

    t = 4.0_sp / x
    t2 = t * t
    a0 = sqrt ( 2.0_sp / ( pi * x ) )

    p0 = (((( &
      - 0.9285e-05_sp * t2 &
      + 0.43506e-04_sp ) * t2 &
      - 0.122226e-03_sp ) * t2 &
      + 0.434725e-03_sp ) * t2 &
      - 0.4394275e-02_sp ) * t2 &
      + 0.999999997_sp

    q0 = t * ((((( &
        0.8099e-05_sp * t2 &
      - 0.35614e-04_sp ) * t2 &
      + 0.85844e-04_sp ) * t2 &
      - 0.218024e-03_sp ) * t2 &
      + 0.1144106e-02_sp ) * t2 &
      - 0.031249995_sp )

    ta0 = x - 0.25_sp * pi
    bj0 = a0 * ( p0 * cos ( ta0 ) - q0 * sin ( ta0 ) )
    by0 = a0 * ( p0 * sin ( ta0 ) + q0 * cos ( ta0 ) )

    p1 = (((( &
        0.10632e-04_sp * t2 &
      - 0.50363e-04_sp ) * t2 &
      + 0.145575e-03_sp ) * t2 &
      - 0.559487e-03_sp ) * t2 &
      + 0.7323931e-02_sp ) * t2 &
      + 1.000000004_sp

    q1 = t * ((((( &
      - 0.9173e-05_sp      * t2 &
      + 0.40658e-04_sp )   * t2 &
      - 0.99941e-04_sp )   * t2 &
      + 0.266891e-03_sp )  * t2 &
      - 0.1601836e-02_sp ) * t2 &
      + 0.093749994_sp )

    ta1 = x - 0.75_sp * pi
    bj1 = a0 * ( p1 * cos ( ta1 ) - q1 * sin ( ta1 ) )
    by1 = a0 * ( p1 * sin ( ta1 ) + q1 * cos ( ta1 ) )

  end if

  dj0 = - bj1
  dj1 = bj0 - bj1 / x
  dy0 = - by1
  dy1 = by0 - by1 / x

 
end subroutine jy01b


attributes(device) subroutine jyna ( n, x, nm, bj, dj, by, dy )

!*****************************************************************************80
!
!! JYNA computes Bessel functions Jn(x) and Yn(x) and derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    29 April 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order.
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, integer(kind=i4) :: NM, the highest order computed.
!
!    Output, real(kind=sp) ::  BJ(0:N), DJ(0:N), BY(0:N), DY(0:N), the values
!    of Jn(x), Jn'(x), Yn(x), Yn'(x).
!
  implicit none

  integer(kind=i4) :: n

  real(kind=sp) ::  bj(0:n)
  real(kind=sp) ::  bj0
  real(kind=sp) ::  bj1
  real(kind=sp) ::  bjk
  real(kind=sp) ::  by(0:n)
  real(kind=sp) ::  by0
  real(kind=sp) ::  by1
  real(kind=sp) ::  cs
  real(kind=sp) ::  dj(0:n)
  real(kind=sp) ::  dj0
  real(kind=sp) ::  dj1
  real(kind=sp) ::  dy(0:n)
  real(kind=sp) ::  dy0
  real(kind=sp) ::  dy1
  real(kind=sp) ::  f
  real(kind=sp) ::  f0
  real(kind=sp) ::  f1
  real(kind=sp) ::  f2
  integer(kind=i4) :: k
  integer(kind=i4) :: m
  integer(kind=i4) :: nm
  real(kind=sp) ::  x

  nm = n

 

  call jy01b ( x, bj0, dj0, bj1, dj1, by0, dy0, by1, dy1 )
  bj(0) = bj0
  bj(1) = bj1
  by(0) = by0
  by(1) = by1
  dj(0) = dj0
  dj(1) = dj1
  dy(0) = dy0
  dy(1) = dy1

  

  if ( n < int ( 0.9_sp * x) ) then

    do k = 2, n
      bjk = 2.0_sp * ( k - 1.0_sp ) / x * bj1 - bj0
      bj(k) = bjk
      bj0 = bj1
      bj1 = bjk
    end do

  else

    m = msta1 ( x, 200 )

    if ( m < n ) then
      nm = m
    else
      m = msta2 ( x, n, 15 )
    end if

    f2 = 0.0_sp
    f1 = huge(1.0_sp,kind=sp)
    do k = m, 0, -1
      f = 2.0_sp * ( k + 1.0_sp ) / x * f1 - f2
      if ( k <= nm ) then
        bj(k) = f
      end if
      f2 = f1
      f1 = f
    end do

    if ( abs ( bj1 ) < abs ( bj0 ) ) then
      cs = bj0 / f
    else
      cs = bj1 / f2
    end if

    do k = 0, nm
      bj(k) = cs * bj(k)
    end do

  end if

  do k = 2, nm
    dj(k) = bj(k-1) - k / x * bj(k)
  end do

  f0 = by(0)
  f1 = by(1)
  do k = 2, nm
    f = 2.0_sp * ( k - 1.0_sp ) / x * f1 - f0
    by(k) = f
    f0 = f1
    f1 = f
  end do

  do k = 2, nm
    dy(k) = by(k-1) - k * by(k) / x
  end do

 
end subroutine jyna


attributes(device) subroutine jynb ( n, x, nm, bj, dj, by, dy )

!*****************************************************************************80
!
!! JYNB computes Bessel functions Jn(x) and Yn(x) and derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    02 August 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order.
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, integer(kind=i4) :: NM, the highest order computed.
!
!    Output, real(kind=sp) ::  BJ(0:N), DJ(0:N), BY(0:N), DY(0:N), the values
!    of Jn(x), Jn'(x), Yn(x), Yn'(x).
!
  implicit none

  integer(kind=i4) :: n

  real(kind=sp) , dimension ( 4 ) :: a = (/ &
    -0.7031250000000000e-01_sp, 0.1121520996093750_sp, &
    -0.5725014209747314_sp, 0.6074042001273483e+01_sp /)
  real(kind=sp) , dimension ( 4 ) :: a1 = (/ &
    0.1171875000000000_sp, -0.1441955566406250_sp, &
    0.6765925884246826_sp, -0.6883914268109947e+01_sp /)
  real(kind=sp) , dimension ( 4 ) :: b = (/ &
    0.7324218750000000e-01_sp, -0.2271080017089844_sp, &
    0.1727727502584457e+01_sp, -0.2438052969955606e+02_sp /)
  real(kind=sp) , dimension ( 4 ) :: b1 = (/ &
    -0.1025390625000000_sp, 0.2775764465332031_sp, &
    -0.1993531733751297e+01_sp, 0.2724882731126854e+02_sp /)
  real(kind=sp) ::  bj(0:n)
  real(kind=sp) ::  bj0
  real(kind=sp) ::  bj1
  real(kind=sp) ::  bjk
  real(kind=sp) ::  bs
  real(kind=sp) ::  by(0:n)
  real(kind=sp) ::  by0
  real(kind=sp) ::  by1
  real(kind=sp) ::  byk
  real(kind=sp) ::  cu
  real(kind=sp) ::  dj(0:n)
  real(kind=sp) ::  dy(0:n)
  real(kind=sp) ::  ec
  real(kind=sp) ::  f
  real(kind=sp) ::  f1
  real(kind=sp) ::  f2
  integer(kind=i4) :: k
  integer(kind=i4) :: m
  integer(kind=i4) :: nm
  real(kind=sp) ::  p0
  real(kind=sp) ::  p1
  real(kind=sp) ::  pi
  real(kind=sp) ::  q0
  real(kind=sp) ::  q1
  real(kind=sp) ::  r2p
  real(kind=sp) ::  s0
  real(kind=sp) ::  su
  real(kind=sp) ::  sv
  real(kind=sp) ::  t1
  real(kind=sp) ::  t2
  real(kind=sp) ::  x

  pi = 3.141592653589793_sp
  r2p = 0.63661977236758_sp
  nm = n

  

  if ( x <= 300.0_sp .or. int ( 0.9_sp * x ) < n ) then

    if ( n == 0 ) then
      nm = 1
    end if

    m = msta1 ( x, 200 )

    if ( m < nm ) then
      nm = m
    else
      m = msta2 ( x, nm, 15 )
    end if

    bs = 0.0_sp
    su = 0.0_sp
    sv = 0.0_sp
    f2 = 0.0_sp
    f1 = tiny(1.0_sp,kind=sp)

    do k = m, 0, -1
      f = 2.0_sp * ( k + 1.0_sp ) / x * f1 - f2
      if ( k <= nm ) then
        bj(k) = f
      end if
      if ( k == 2 * int ( k / 2 ) .and. k /= 0 ) then
        bs = bs + 2.0_sp * f
        su = su + ( -1.0_sp ) ** ( k / 2 ) * f / k
      else if ( 1 < k ) then
        sv = sv + ( -1.0_sp ) ** ( k / 2 ) * k / ( k * k - 1.0_sp ) * f
      end if
      f2 = f1
      f1 = f
    end do

    s0 = bs + f
    do k = 0, nm
      bj(k) = bj(k) / s0
    end do

    ec = log ( x / 2.0_sp ) + 0.5772156649015329_sp
    by0 = r2p * ( ec * bj(0) - 4.0_sp * su / s0 )
    by(0) = by0
    by1 = r2p * ( ( ec - 1.0_sp ) * bj(1) - bj(0) / x - 4.0_sp * sv / s0 )
    by(1) = by1

  else

    t1 = x - 0.25_sp * pi
    p0 = 1.0_sp
    q0 = -0.125_sp / x
    do k = 1, 4
      p0 = p0 + a(k) * x ** ( - 2 * k )
      q0 = q0 + b(k) * x ** ( - 2 * k - 1 )
    end do
    cu = sqrt ( r2p / x )
    bj0 = cu * ( p0 * cos ( t1 ) - q0 * sin ( t1 ) )
    by0 = cu * ( p0 * sin ( t1 ) + q0 * cos ( t1 ) )
    bj(0) = bj0
    by(0) = by0
    t2 = x - 0.75_sp * pi
    p1 = 1.0_sp
    q1 = 0.375_sp / x
    do k = 1, 4
      p1 = p1 + a1(k) * x ** ( - 2 * k )
      q1 = q1 + b1(k) * x ** ( - 2 * k - 1 )
    end do
    bj1 = cu * ( p1 * cos ( t2 ) - q1 * sin ( t2 ) )
    by1 = cu * ( p1 * sin ( t2 ) + q1 * cos ( t2 ) )
    bj(1) = bj1
    by(1) = by1
    do k = 2, nm
      bjk = 2.0_sp * ( k - 1.0_sp ) / x * bj1 - bj0
      bj(k) = bjk
      bj0 = bj1
      bj1 = bjk
    end do
  end if

  dj(0) = -bj(1)
  do k = 1, nm
    dj(k) = bj(k-1) - k / x * bj(k)
  end do

  do k = 2, nm
    byk = 2.0_sp * ( k - 1.0_sp ) * by1 / x - by0
    by(k) = byk
    by0 = by1
    by1 = byk
  end do

  dy(0) = -by(1)
  do k = 1, nm
    dy(k) = by(k-1) - k * by(k) / x
  end do

end subroutine jynb


attributes(device) subroutine jyndd ( n, x, bjn, djn, fjn, byn, dyn, fyn )

!*****************************************************************************80
!
!! JYNDD: Bessel functions Jn(x) and Yn(x), first and second derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    02 August 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order.
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  BJN, DJN, FJN, BYN, DYN, FYN, the values of
!    Jn(x), Jn'(x), Jn"(x), Yn(x), Yn'(x), Yn"(x).
!
  implicit none

  real(kind=sp) ::  bj(102)
  real(kind=sp) ::  bjn
  real(kind=sp) ::  byn
  real(kind=sp) ::  bs
  real(kind=sp) ::  by(102)
  real(kind=sp) ::  djn
  real(kind=sp) ::  dyn
  real(kind=sp) ::  e0
  real(kind=sp) ::  ec
  real(kind=sp) ::  f
  real(kind=sp) ::  f0
  real(kind=sp) ::  f1
  real(kind=sp) ::  fjn
  real(kind=sp) ::  fyn
  integer(kind=i4) :: k
  integer(kind=i4) :: m
  integer(kind=i4) :: mt
  integer(kind=i4) :: n
  integer(kind=i4) :: nt
  real(kind=sp) ::  s1
  real(kind=sp) ::  su
  real(kind=sp) ::  x

  do nt = 1, 900
    mt = int ( 0.5_sp * log10 ( 6.28_sp * nt ) &
      - nt * log10 ( 1.36_sp * abs ( x ) / nt ) )
    if ( 20 < mt ) then
      exit
    end if
  end do

  m = nt
  bs = 0.0_sp
  f0 = 0.0_sp
  f1 = tiny(1.0_sp,kind=sp)
  su = 0.0_sp
  do k = m, 0, -1
    f = 2.0_sp * ( k + 1.0_sp ) * f1 / x - f0
    if ( k <= n + 1 ) then
      bj(k+1) = f
    end if
    if ( k == 2 * int ( k / 2 ) ) then
      bs = bs + 2.0_sp * f
      if ( k /= 0 ) then
        su = su + ( -1.0_sp ) ** ( k / 2 ) * f / k
      end if
    end if
    f0 = f1
    f1 = f
  end do

  do k = 0, n + 1
    bj(k+1) = bj(k+1) / ( bs - f )
  end do

  bjn = bj(n+1)
  ec = 0.5772156649015329_sp
  e0 = 0.3183098861837907_sp
  s1 = 2.0_sp * e0 * ( log ( x / 2.0_sp ) + ec ) * bj(1)
  f0 = s1 - 8.0_sp * e0 * su / ( bs - f )
  f1 = ( bj(2) * f0 - 2.0_sp * e0 / x ) / bj(1)

  by(1) = f0
  by(2) = f1
  do k = 2, n + 1 
    f = 2.0_sp * ( k - 1.0_sp ) * f1 / x - f0
    by(k+1) = f
    f0 = f1
    f1 = f
  end do

  byn = by(n+1)
  djn = - bj(n+2) + n * bj(n+1) / x
  dyn = - by(n+2) + n * by(n+1) / x
  fjn = ( n * n / ( x * x ) - 1.0_sp ) * bjn - djn / x
  fyn = ( n * n / ( x * x ) - 1.0_sp ) * byn - dyn / x

end subroutine jyndd 


attributes(device) subroutine klvnb ( x, ber, bei, ger, gei, der, dei, her, hei )

!*****************************************************************************80
!
!! KLVNB: Kelvin functions ber(x), bei(x), ker(x), and kei(x), and derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    03 August 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  BER, BEI, GER, GEI, DER, DEI, HER, HEI, 
!    the values of ber x, bei x, ker x, kei x, ber'x, bei'x, ker'x, kei'x.
!
  implicit none

  real(kind=sp) ::  bei
  real(kind=sp) ::  ber
  real(kind=sp) ::  csn
  real(kind=sp) ::  csp
  real(kind=sp) ::  dei
  real(kind=sp) ::  der
  real(kind=sp) ::  fxi
  real(kind=sp) ::  fxr
  real(kind=sp) ::  gei
  real(kind=sp) ::  ger
  real(kind=sp) ::  hei
  real(kind=sp) ::  her
  integer(kind=i4) :: l
  real(kind=sp) ::  pi
  real(kind=sp) ::  pni
  real(kind=sp) ::  pnr
  real(kind=sp) ::  ppi
  real(kind=sp) ::  ppr
  real(kind=sp) ::  ssn
  real(kind=sp) ::  ssp
  real(kind=sp) ::  t
  real(kind=sp) ::  t2
  real(kind=sp) ::  tni
  real(kind=sp) ::  tnr
  real(kind=sp) ::  tpi
  real(kind=sp) ::  tpr
  real(kind=sp) ::  u
  real(kind=sp) ::  v
  real(kind=sp) ::  x
  real(kind=sp) ::  yc1
  real(kind=sp) ::  yc2
  real(kind=sp) ::  yci
  real(kind=sp) ::  ye1
  real(kind=sp) ::  ye2
  real(kind=sp) ::  yei
  real(kind=sp) ::  yd

  pi = 3.141592653589793_sp

  if ( x == 0.0_sp ) then

    ber = 1.0_sp
    bei = 0.0_sp
    ger = 1.0e+300
    gei = -0.25_sp * pi
    der = 0.0_sp
    dei = 0.0_sp
    her = -huge(1.0_sp,kind=sp)
    hei = 0.0_sp

  else if ( x < 8.0_sp ) then

    t = x / 8.0_sp
    t2 = t * t
    u = t2 * t2

    ber = (((((( &
      - 0.901e-05_sp * u &
      + 0.122552e-02_sp ) * u &
      - 0.08349609_sp ) * u &
      + 2.64191397_sp ) * u &
      - 32.36345652_sp ) * u &
      + 113.77777774_sp ) * u &
      - 64.0_sp ) * u &
      + 1.0_sp

    bei = t * t * (((((( &
        0.11346e-03_sp * u &
      - 0.01103667_sp ) * u &
      + 0.52185615_sp ) * u &
      - 10.56765779_sp ) * u &
      + 72.81777742_sp ) * u &
      - 113.77777774_sp ) * u &
      + 16.0_sp )

    ger = (((((( &
      - 0.2458e-04_sp * u &
      + 0.309699e-02_sp ) * u &
      - 0.19636347_sp ) * u &
      + 5.65539121_sp ) * u &
      - 60.60977451_sp ) * u &
      + 171.36272133_sp ) * u &
      - 59.05819744_sp ) * u &
      - 0.57721566_sp

    ger = ger - log ( 0.5_sp * x ) * ber + 0.25_sp * pi * bei

    gei = t2 * (((((( &
        0.29532e-03_sp * u &
      - 0.02695875_sp ) * u &
      + 1.17509064_sp ) * u &
      - 21.30060904_sp ) * u &
      + 124.2356965_sp ) * u &
      - 142.91827687_sp ) * u &
      + 6.76454936_sp )

    gei = gei - log ( 0.5_sp * x ) * bei - 0.25_sp * pi * ber

    der = x * t2 * (((((( &
      - 0.394e-05_sp * u &
      + 0.45957e-03_sp ) * u &
      - 0.02609253_sp ) * u &
      + 0.66047849_sp ) * u &
      - 6.0681481_sp ) * u &
      + 14.22222222_sp ) * u &
      - 4.0_sp )

    dei = x * (((((( &
        0.4609e-04_sp * u &
      - 0.379386e-02_sp ) * u &
      + 0.14677204_sp ) * u &
      - 2.31167514_sp ) * u &
      + 11.37777772_sp ) * u &
      - 10.66666666_sp ) * u &
      + 0.5_sp ) 

    her = x * t2 * (((((( &
      - 0.1075e-04_sp * u &
      + 0.116137e-02_sp ) * u &
      - 0.06136358_sp ) * u &
      + 1.4138478_sp ) * u &
      - 11.36433272_sp ) * u &
      + 21.42034017_sp ) * u &
      - 3.69113734_sp )

    her = her - log ( 0.5_sp * x ) * der - ber / x  &
      + 0.25_sp * pi * dei

    hei = x * (((((( &
        0.11997e-03_sp * u &
      - 0.926707e-02_sp ) * u &
      + 0.33049424_sp ) * u &
      - 4.65950823_sp ) * u &
      + 19.41182758_sp ) * u &
      - 13.39858846_sp ) * u &
      + 0.21139217_sp )

    hei = hei - log ( 0.5_sp * x ) * dei - bei / x  &
      - 0.25_sp * pi * der

  else

    t = 8.0_sp / x

    do l = 1, 2

      v = ( -1.0_sp ) ** l * t

      tpr = (((( &
          0.6e-06_sp * v &
        - 0.34e-05_sp ) * v &
        - 0.252e-04_sp ) * v &
        - 0.906e-04_sp ) * v * v &
        + 0.0110486_sp ) * v

      tpi = (((( &
          0.19e-05_sp * v &
        + 0.51e-05_sp ) * v * v &
        - 0.901e-04_sp ) * v &
        - 0.9765e-03_sp ) * v &
        - 0.0110485_sp ) * v &
        - 0.3926991_sp

      if ( l == 1 ) then
        tnr = tpr
        tni = tpi
      end if

    end do

    yd = x / sqrt ( 2.0_sp )
    ye1 = exp ( yd + tpr )
    ye2 = exp ( - yd + tnr )
    yc1 = 1.0_sp / sqrt ( 2.0_sp * pi * x )
    yc2 = sqrt ( pi / ( 2.0_sp * x ) )
    csp = cos ( yd + tpi )
    ssp = sin ( yd + tpi )
    csn = cos ( - yd + tni )
    ssn = sin ( - yd + tni )
    ger = yc2 * ye2 * csn
    gei = yc2 * ye2 * ssn
    fxr = yc1 * ye1 * csp
    fxi = yc1 * ye1 * ssp
    ber = fxr - gei / pi
    bei = fxi + ger / pi

    do l = 1, 2

      v = ( -1.0_sp ) ** l * t

      ppr = ((((( &
          0.16e-05_sp * v &
        + 0.117e-04_sp ) * v &
        + 0.346e-04_sp ) * v &
        + 0.5e-06_sp ) * v &
        - 0.13813e-02_sp ) * v &
        - 0.0625001_sp ) * v &
        + 0.7071068_sp

      ppi = ((((( &
        - 0.32e-05_sp * v &
        - 0.24e-05_sp ) * v &
        + 0.338e-04_sp ) * v &
        + 0.2452e-03_sp ) * v &
        + 0.13811e-02_sp ) * v &
        - 0.1e-06_sp ) * v &
        + 0.7071068_sp

      if ( l == 1 ) then
        pnr = ppr
        pni = ppi
      end if

    end do

    her =     gei * pni - ger * pnr
    hei = - ( gei * pnr + ger * pni )
    der = fxr * ppr - fxi * ppi - hei / pi
    dei = fxi * ppr + fxr * ppi + her / pi

  end if
 
end subroutine klvnb


attributes(device) subroutine lagzo ( n, x, w )

!*****************************************************************************80
!
!! LAGZO computes zeros of the Laguerre polynomial, and integration weights.
!
!  Discussion:
!
!    This procedure computes the zeros of Laguerre polynomial Ln(x) in the 
!    interval [0,\EC], and the corresponding weighting coefficients for 
!    Gauss-Laguerre integration.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    07 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order of the Laguerre polynomial.
!
!    Output, real(kind=sp) ::  X(N), the zeros of the Laguerre polynomial.
!
!    Output, real(kind=sp) ::  W(N), the weighting coefficients.
!
  implicit none

  integer(kind=i4) :: n

  real(kind=sp) ::  f0
  real(kind=sp) ::  f1
  real(kind=sp) ::  fd
  real(kind=sp) ::  gd
  real(kind=sp) ::  hn
  integer(kind=i4) :: i
  integer(kind=i4) :: it
  integer(kind=i4) :: j
  integer(kind=i4) :: k
  integer(kind=i4) :: nr
  real(kind=sp) ::  p
  real(kind=sp) ::  pd
  real(kind=sp) ::  pf
  real(kind=sp) ::  q
  real(kind=sp) ::  w(n)
  real(kind=sp) ::  wp
  real(kind=sp) ::  x(n)
  real(kind=sp) ::  z
  real(kind=sp) ::  z0

  hn = 1.0_sp / real ( n, kind=sp )

  do nr = 1, n

    if ( nr == 1 ) then
      z = hn
    else
      z = x(nr-1) + hn * nr ** 1.27_sp
    end if

    it = 0

    do

      it = it + 1
      z0 = z
      p = 1.0_sp
      do i = 1, nr - 1
        p = p * ( z - x(i) )
      end do

      f0 = 1.0_sp
      f1 = 1.0_sp - z
      do k = 2, n
        pf = (( 2.0_sp * k - 1.0_sp - z ) * f1 &
          - ( k - 1.0_sp ) * f0 ) / k
        pd = k / z * ( pf - f1 )
        f0 = f1
        f1 = pf
      end do

      fd = pf / p

      q = 0.0_sp
      do i = 1, nr - 1
        wp = 1.0_sp
        do j = 1, nr - 1
          if ( j /= i ) then
            wp = wp * ( z - x(j) )
          end if
        end do
        q = q + wp
      end do

      gd = ( pd - q * fd ) / p
      z = z - fd / gd

      if ( 40 < it .or. abs ( ( z - z0 ) / z ) <= 1.0e-15_sp ) then
        exit
      end if

    end do

    x(nr) = z
    w(nr) = 1.0_sp / ( z * pd * pd )

  end do

  
end subroutine lagzo


attributes(device) subroutine legzo ( n, x, w )

!*****************************************************************************80
!
!! LEGZO computes the zeros of Legendre polynomials, and integration weights.
!
!  Discussion:
!
!    This procedure computes the zeros of Legendre polynomial Pn(x) in the 
!    interval [-1,1], and the corresponding weighting coefficients for 
!    Gauss-Legendre integration.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    13 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order of the polynomial.
!
!    Output, real(kind=sp) ::  X(N), W(N), the zeros of the polynomial,
!    and the corresponding weights.
!
  implicit none

  integer(kind=i4) :: n

  real(kind=sp) ::  f0
  real(kind=sp) ::  f1
  real(kind=sp) ::  fd
  real(kind=sp) ::  gd
  integer(kind=i4) :: i
  integer(kind=i4) :: j
  integer(kind=i4) :: k
  integer(kind=i4) :: n0
  integer(kind=i4) :: nr
  real(kind=sp) ::  p
  real(kind=sp) ::  pd
  real(kind=sp) ::  pf
  real(kind=sp) ::  q
  real(kind=sp) ::  w(n)
  real(kind=sp) ::  wp
  real(kind=sp) ::  x(n)
  real(kind=sp) ::  z
  real(kind=sp) ::  z0

  n0 = ( n + 1 ) / 2

  do nr = 1, n0

    z = cos ( 3.14159265358979323846264_sp * ( nr - 0.25_sp ) / n )

    do

      z0 = z
      p = 1.0_sp
      do i = 1, nr - 1
        p = p * ( z - x(i))
      end do
      f0 = 1.0_sp
      if ( nr == n0 .and. n /= 2 * int ( n / 2 ) ) then
        z = 0.0_sp
      end if
      f1 = z
      do k = 2, n
        pf = ( 2.0_sp - 1.0_sp / k ) * z * f1 &
          - ( 1.0_sp - 1.0_sp / k ) * f0
        pd = k * ( f1 - z * pf ) / ( 1.0_sp - z * z )
        f0 = f1
        f1 = pf
      end do

      if ( z == 0.0_sp ) then
        exit
      end if

      fd = pf / p
      q = 0.0_sp
      do i = 1, nr - 1
        wp = 1.0_sp
        do j = 1, nr - 1
          if ( j /= i ) then
            wp = wp * ( z - x(j) )
          end if
        end do
        q = q + wp
      end do
      gd = ( pd - q * fd ) / p
      z = z - fd / gd

      if ( abs ( z - z0 ) < abs ( z ) * 1.0e-15_sp ) then
        exit
      end if

    end do

    x(nr) = z
    x(n+1-nr) = - z
    w(nr) = 2.0_sp / ( ( 1.0_sp - z * z ) * pd * pd )
    w(n+1-nr) = w(nr)

  end do

end subroutine legzo


attributes(device) subroutine lgama ( kf, x, gl )

!*****************************************************************************80
!
!! LGAMA computes the gamma function or its logarithm.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    15 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: KF, the argument code.
!    1, for gamma(x);
!    2, for ln(gamma(x)).
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  GL, the function value.
!
  implicit none

  real(kind=sp), dimension ( 10 ) :: a = (/ &
    8.333333333333333e-02_sp, &
   -2.777777777777778e-03_sp, &
    7.936507936507937e-04_sp, &
   -5.952380952380952e-04_sp, &
    8.417508417508418e-04_sp, &
   -1.917526917526918e-03_sp, &
    6.410256410256410e-03_sp, &
   -2.955065359477124e-02_sp, &
    1.796443723688307e-01_sp, &
   -1.39243221690590_sp /)
  real(kind=sp) ::  gl
  real(kind=sp) ::  gl0
  integer(kind=i4) :: k
  integer(kind=i4) :: kf
  integer(kind=i4) :: n
  real(kind=sp) ::  x
  real(kind=sp) ::  x0
  real(kind=sp) ::  x2
  real(kind=sp) ::  xp

  x0 = x

  if ( x == 1.0_sp .or. x == 2.0_sp ) then
    gl = 0.0_sp
    if ( kf == 1 ) then
      gl = 1.0_sp
    end if
    return
  else if ( x <= 7.0_sp ) then
    n = int ( 7.0_sp - x )
    x0 = x + n
  end if

  x2 = 1.0_sp / ( x0 * x0 )
  xp = 6.283185307179586477_sp
  gl0 = a(10)

  do k = 9, 1, -1
    gl0 = gl0 * x2 + a(k)
  end do

  gl = gl0 / x0 + 0.5_sp * log ( xp ) + ( x0 - 0.5_sp ) * log ( x0 ) - x0

  if ( x <= 7.0_sp ) then
    do k = 1, n
      gl = gl - log ( x0 - 1.0_sp )
      x0 = x0 - 1.0_sp
    end do
  end if

  if ( kf == 1 ) then
    gl = exp ( gl )
  end if
  
end subroutine lgama


attributes(device) subroutine lpn ( n, x, pn, pd )

!*****************************************************************************80
!
!! LPN computes Legendre polynomials Pn(x) and derivatives Pn'(x).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    07 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the maximum degree.
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  PN(0:N), PD(0:N), the values and derivatives
!    of the polyomials of degrees 0 to N at X.
!
  implicit none

  integer(kind=i4) :: n

  integer(kind=i4) :: k
  real(kind=sp) ::  p0
  real(kind=sp) ::  p1
  real(kind=sp) ::  pd(0:n)
  real(kind=sp) ::  pf
  real(kind=sp) ::  pn(0:n)
  real(kind=sp) ::  x

  pn(0) = 1.0_sp
  pn(1) = x
  pd(0) = 0.0_sp
  pd(1) = 1.0_sp
  p0 = 1.0_sp
  p1 = x

  do k = 2, n

    pf = ( 2.0_sp * k - 1.0_sp ) / k * x * p1 &
      - ( k - 1.0_sp ) / k * p0
    pn(k) = pf

    if ( abs ( x ) == 1.0_sp ) then
      pd(k) = 0.5_sp * x ** ( k + 1 ) * k * ( k + 1.0_sp )
    else
      pd(k) = k * ( p1 - x * pf ) / ( 1.0_sp - x * x )
    end if

    p0 = p1
    p1 = pf

  end do

end subroutine lpn


attributes(device) function msta1 ( x, mp )

!*****************************************************************************80
!
!! MSTA1 determines a backward recurrence starting point for Jn(x).
!
!  Discussion:
!
!    This procedure determines the starting point for backward  
!    recurrence such that the magnitude of    
!    Jn(x) at that point is about 10^(-MP).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    08 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Input, integer(kind=i4) :: MP, the negative logarithm of the 
!    desired magnitude.
!
!    Output, integer(kind=i4) :: MSTA1, the starting point.
!
  implicit none

  real(kind=sp) ::  a0
  real(kind=sp) ::  envj
  real(kind=sp) ::  f
  real(kind=sp) ::  f0
  real(kind=sp) ::  f1
  integer(kind=i4) :: it
  integer(kind=i4) :: mp
  integer(kind=i4) :: msta1
  integer(kind=i4) :: n0
  integer(kind=i4) :: n1
  integer(kind=i4) :: nn
  real(kind=sp) ::  x

  a0 = abs ( x )
  n0 = int ( 1.1e+00_sp * a0 ) + 1
  f0 = envj ( n0, a0 ) - mp
  n1 = n0 + 5
  f1 = envj ( n1, a0 ) - mp
  do it = 1, 20       
    nn = n1 - ( n1 - n0 ) / ( 1.0e+00_sp - f0 / f1 )                  
    f = envj ( nn, a0 ) - mp
    if ( abs ( nn - n1 ) < 1 ) then
      exit
    end if
    n0 = n1
    f0 = f1
    n1 = nn
    f1 = f
  end do

  msta1 = nn

end

attributes(device) function msta2 ( x, n, mp )

!*****************************************************************************80
!
!! MSTA2 determines a backward recurrence starting point for Jn(x).
!
!  Discussion:
!
!    This procedure determines the starting point for a backward
!    recurrence such that all Jn(x) has MP significant digits.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    08 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument of Jn(x).
!
!    Input, integer(kind=i4) :: N, the order of Jn(x).
!
!    Input, integer(kind=i4) :: MP, the number of significant digits.
!
!    Output, integer(kind=i4) :: MSTA2, the starting point.
!
  implicit none

  real(kind=sp) ::  a0
  real(kind=sp) ::  ejn
  real(kind=sp) ::  f
  real(kind=sp) ::  f0
  real(kind=sp) ::  f1
  real(kind=sp) ::  hmp
  integer(kind=i4) :: it
  integer(kind=i4) :: mp
  integer(kind=i4) :: msta2
  integer(kind=i4) :: n
  integer(kind=i4) :: n0
  integer(kind=i4) :: n1
  integer(kind=i4) :: nn
  real(kind=sp) ::  obj
  real(kind=sp) ::  x

  a0 = abs ( x )
  hmp = 0.5e+00_sp * mp
  ejn = envj ( n, a0 )

  if ( ejn <= hmp ) then
    obj = mp
    n0 = int ( 1.1e+00_sp * a0 )
  else
    obj = hmp + ejn
    n0 = n
  end if

  f0 = envj ( n0, a0 ) - obj
  n1 = n0 + 5
  f1 = envj ( n1, a0 ) - obj

  do it = 1, 20
    nn = n1 - ( n1 - n0 ) / ( 1.0e+00_sp - f0 / f1 )
    f = envj ( nn, a0 ) - obj
    if ( abs ( nn - n1 ) < 1 ) then
      exit
    end if
    n0 = n1
    f0 = f1
    n1 = nn
    f1 = f
  end do

  msta2 = nn + 10

end


attributes(device) subroutine othpl ( kf, n, x, pl, dpl )

!*****************************************************************************80
!
!! OTHPL computes orthogonal polynomials Tn(x), Un(x), Ln(x) or Hn(x).
!
!  Discussion:
!
!    This procedure computes orthogonal polynomials: Tn(x) or Un(x),
!    or Ln(x) or Hn(x), and their derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    08 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: KT, the function code:
!    1 for Chebyshev polynomial Tn(x)
!    2 for Chebyshev polynomial Un(x)
!    3 for Laguerre polynomial Ln(x)
!    4 for Hermite polynomial Hn(x)
!
!    Input, integer(kind=i4) :: N, the order.
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  PL(0:N), DPL(0:N), the value and derivative of
!    the polynomials of order 0 through N at X.
!
  implicit none

  integer n

  real(kind=sp) ::  a
  real(kind=sp) ::  b
  real(kind=sp) ::  c
  real(kind=sp) ::  dpl(0:n)
  real(kind=sp) ::  dy0
  real(kind=sp) ::  dy1
  real(kind=sp) ::  dyn
  integer(kind=i4) :: k
  integer(kind=i4) :: kf
  real(kind=sp) ::  pl(0:n)
  real(kind=sp) ::  x
  real(kind=sp) ::  y0
  real(kind=sp) ::  y1
  real(kind=sp) ::  yn

  a = 2.0_sp
  b = 0.0_sp
  c = 1.0_sp
  y0 = 1.0_sp
  y1 = 2.0_sp * x
  dy0 = 0.0_sp
  dy1 = 2.0_sp
  pl(0) = 1.0_sp
  pl(1) = 2.0_sp * x
  dpl(0) = 0.0_sp
  dpl(1) = 2.0_sp

  if ( kf == 1 ) then
    y1 = x
    dy1 = 1.0_sp
    pl(1) = x
    dpl(1) = 1.0_sp
  else if ( kf == 3 ) then
    y1 = 1.0_sp - x
    dy1 = -1.0_sp
    pl(1) = 1.0_sp - x
    dpl(1) = -1.0_sp
  end if

  do k = 2, n

    if ( kf == 3 ) then
      a = -1.0_sp / k
      b = 2.0_sp + a
      c = 1.0_sp + a
    else if ( kf == 4 ) then
      c = 2.0_sp * ( k - 1.0_sp )
    end if

    yn = ( a * x + b ) * y1 - c * y0
    dyn = a * y1 + ( a * x + b ) * dy1 - c * dy0
    pl(k) = yn
    dpl(k) = dyn
    y0 = y1
    y1 = yn
    dy0 = dy1
    dy1 = dyn

  end do

end subroutine othpl


attributes(device) subroutine rctj ( n, x, nm, rj, dj )

!*****************************************************************************80
!
!! RCTJ computes Riccati-Bessel function of the first kind, and derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    18 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order of jn(x).
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, integer(kind=i4) :: NM, the highest order computed.
!
!    Output, real(kind=sp) ::  RJ(0:N), the values of x jn(x).
!
!    Output, real(kind=sp) ::  DJ(0:N), the values of [x jn(x)]'.
!
  implicit none

  integer(kind=i4) :: n

  real(kind=sp) ::  cs
  real(kind=sp) ::  dj(0:n)
  real(kind=sp) ::  f
  real(kind=sp) ::  f0
  real(kind=sp) ::  f1
  integer(kind=i4) :: k
  integer(kind=i4) :: m
 
  integer(kind=i4) :: nm
  real(kind=sp) ::  rj(0:n)
  real(kind=sp) ::  rj0
  real(kind=sp) ::  rj1
  real(kind=sp) ::  x

  nm = n

 

  rj(0) = sin ( x )
  rj(1) = rj(0) / x - cos ( x )
  rj0 = rj(0)
  rj1 = rj(1)

  if ( 2 <= n ) then

    m = msta1 ( x, 200 )

    if ( m < n ) then
      nm = m
    else
      m = msta2 ( x, n, 15 )
    end if

    f0 = 0.0_sp
    f1 = tiny(1.0_sp,kind=sp)
    do k = m, 0, -1
      f = ( 2.0_sp * k + 3.0_sp ) * f1 / x - f0
      if ( k <= nm ) then
        rj(k) = f
      end if
      f0 = f1
      f1 = f
    end do

    if ( abs ( rj1 ) < abs ( rj0 ) ) then
      cs = rj0 / f
    else
      cs = rj1 / f0
    end if

    do k = 0, nm
      rj(k) = cs * rj(k)
    end do

  end if

  dj(0) = cos ( x )
  do k = 1, nm
    dj(k) = - k * rj(k) / x + rj(k-1)
  end do

end subroutine rctj


attributes(device) subroutine rcty ( n, x, nm, ry, dy )

!*****************************************************************************80
!
!! RCTY computes Riccati-Bessel function of the second kind, and derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    18 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order of yn(x).
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, integer(kind=i4) :: NM, the highest order computed.
!
!    Output, real(kind=sp) ::  RY(0:N), the values of x yn(x).
!
!    Output, real(kind=sp) ::  DY(0:N), the values of [x yn(x)]'.
!
  implicit none

  integer(kind=i4) :: n

  real(kind=sp) ::  dy(0:n)
  integer(kind=i4) :: k
  integer(kind=i4) :: nm
  real(kind=sp) ::  rf0
  real(kind=sp) ::  rf1
  real(kind=sp) ::  rf2
  real(kind=sp) ::  ry(0:n)
  real(kind=sp) ::  x

  nm = n

  

  ry(0) = - cos ( x )
  ry(1) = ry(0) / x - sin ( x )
  rf0 = ry(0)
  rf1 = ry(1)
  do k = 2, n
    rf2 = ( 2.0_sp * k - 1.0_sp ) * rf1 / x - rf0
    if ( huge(1.0_sp,kind=sp) < abs ( rf2 ) ) then
      exit
    end if
    ry(k) = rf2
    rf0 = rf1
    rf1 = rf2
  end do

  nm = k - 1
  dy(0) = sin ( x )
  do k = 1, nm
    dy(k) = - k * ry(k) / x + ry(k-1)
  end do

  
end subroutine rcty


attributes(device) subroutine sphi ( n, x, nm, si, di )

!*****************************************************************************80
!
!! SPHI computes spherical Bessel functions in(x) and their derivatives in'(x).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    18 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order of In(X).
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, integer(kind=i4) :: NM, the highest order computed.
!
!    Output, real(kind=sp) ::  SI(0:N), DI(0:N), the values and derivatives
!    of the function of orders 0 through N.
!
  implicit none

  integer(kind=i4) :: n

  real(kind=sp) ::  cs
  real(kind=sp) ::  di(0:n)
  real(kind=sp) ::  f
  real(kind=sp) ::  f0
  real(kind=sp) ::  f1
  integer(kind=i4) :: k
  integer(kind=i4) :: m
  integer(kind=i4) :: nm
  real(kind=sp) ::  si(0:n)
  real(kind=sp) ::  si0
  real(kind=sp) ::  x

  nm = n

 

  si(0) = sinh ( x ) / x
  si(1) = -( sinh ( x ) / x - cosh ( x ) ) / x
  si0 = si(0)

  if ( 2 <= n ) then

    m = msta1 ( x, 200 )
    if ( m < n ) then
      nm = m
    else
      m = msta2 ( x, n, 15 )
    end if
    f0 = 0.0_sp
    f1 = tiny(1.0_sp,kind=sp)
    do k = m, 0, -1
      f = ( 2.0_sp * k + 3.0_sp ) * f1 / x + f0
      if ( k <= nm ) then
        si(k) = f
      end if
      f0 = f1
      f1 = f
    end do
    cs = si0 / f
    do k = 0, nm
      si(k) = cs * si(k)
    end do

  end if

  di(0) = si(1)
  do k = 1, nm
    di(k) = si(k-1) - ( k + 1.0_sp ) / x * si(k)
  end do

end subroutine sphi


attributes(device) subroutine sphj ( n, x, nm, sj, dj )

!*****************************************************************************80
!
!! SPHJ computes spherical Bessel functions jn(x) and their derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    15 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order.
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, integer(kind=i4) :: NM, the highest order computed.
!
!    Output, real(kind=sp) ::  SJ(0:N), the values of jn(x).
!
!    Output, real(kind=sp) ::  DJ(0:N), the values of jn'(x).
!
  implicit none

  integer(kind=i4) :: n

  real(kind=sp) ::  cs
  real(kind=sp) ::  dj(0:n)
  real(kind=sp) ::  f
  real(kind=sp) ::  f0
  real(kind=sp) ::  f1
  integer(kind=i4) :: k
  integer(kind=i4) :: m
  
  integer(kind=i4) :: nm
  real(kind=sp) ::  sa
  real(kind=sp) ::  sb
  real(kind=sp) ::  sj(0:n)
  real(kind=sp) ::  x

  nm = n

  

  sj(0) = sin ( x ) / x
  sj(1) = ( sj(0) - cos ( x ) ) / x

  if ( 2 <= n ) then

    sa = sj(0)
    sb = sj(1)
    m = msta1 ( x, 200 )
    if ( m < n ) then
      nm = m
    else
      m = msta2 ( x, n, 15 )
    end if

    f0 = 0.0_sp
    f1 = tiny(1.0_sp,kind=sp)
    do k = m, 0, -1
      f = ( 2.0_sp * k + 3.0_sp ) * f1 / x - f0
      if ( k <= nm ) then
        sj(k) = f
      end if
      f0 = f1
      f1 = f
    end do

    if ( abs ( sa ) <= abs ( sb ) ) then
      cs = sb / f0
    else
      cs = sa / f
    end if

    do k = 0, nm
      sj(k) = cs * sj(k)
    end do

  end if      

  dj(0) = ( cos(x) - sin(x) / x ) / x
  do k = 1, nm
    dj(k) = sj(k-1) - ( k + 1.0_sp ) * sj(k) / x
  end do

end subroutine sphj


attributes(device) subroutine sphk ( n, x, nm, sk, dk )

!*****************************************************************************80
!
!! SPHK computes modified spherical Bessel functions kn(x) and derivatives.
!
!  Discussion:
!
!    This procedure computes modified spherical Bessel functions
!    of the second kind, kn(x) and kn'(x).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    15 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order.
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, integer(kind=i4) :: NM, the highest order computed.
!
!    Output, real(kind=sp) ::  SK(0:N), DK(0:N), the values of kn(x) and kn'(x).
!
  implicit none

  integer(kind=i4) :: n

  real(kind=sp) ::  dk(0:n)
  real(kind=sp) ::  f
  real(kind=sp) ::  f0
  real(kind=sp) ::  f1
  integer(kind=i4) :: k
  integer(kind=i4) :: nm
  real(kind=sp) ::  sk(0:n)
  real(kind=sp) ::  pi
  real(kind=sp) ::  x

  pi = 3.14159265358979323846264_sp
  nm = n
  

  sk(0) = 0.5_sp * pi / x * exp ( - x )
  sk(1) = sk(0) * ( 1.0_sp + 1.0_sp / x )
  f0 = sk(0)
  f1 = sk(1)
  do k = 2, n
    f = ( 2.0_sp * k - 1.0_sp ) * f1 / x + f0
    sk(k) = f
    if ( huge(1.0_sp,kind=sp) < abs ( f ) ) then
      exit
    end if
    f0 = f1
    f1 = f
  end do

  nm = k - 1

  dk(0) = -sk(1)
  do k = 1, nm
    dk(k) = -sk(k-1) - ( k + 1.0_sp ) / x * sk(k)
  end do

end subroutine sphk

attributes(device) subroutine sphy ( n, x, nm, sy, dy )

!*****************************************************************************80
!
!! SPHY computes spherical Bessel functions yn(x) and their derivatives.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    15 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, integer(kind=i4) :: N, the order.
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, integer(kind=i4) :: NM, the highest order computed.
!
!    Output, real(kind=sp) ::  SY(0:N), DY(0:N), the values of yn(x) and yn'(x).
! 
  implicit none

  integer(kind=i4) :: n

  real(kind=sp) ::  dy(0:n)
  real(kind=sp) ::  f
  real(kind=sp) ::  f0
  real(kind=sp) ::  f1
  integer(kind=i4) :: k
  integer(kind=i4) :: nm
  real(kind=sp) ::  sy(0:n)
  real(kind=sp) ::  x

  nm = n

 

  sy(0) = - cos ( x ) / x
  sy(1) = ( sy(0) - sin ( x ) ) / x
  f0 = sy(0)
  f1 = sy(1)
  do k = 2, n
    f = ( 2.0_sp * k - 1.0_sp ) * f1 / x - f0
    sy(k) = f
    if ( huge(1.0_sp,kind=sp) <= abs ( f ) ) then
      exit
    end if              
    f0 = f1
    f1 = f
  end do

  nm = k - 1
  dy(0) = ( sin ( x ) + cos ( x ) / x ) / x
  do k = 1, nm
    dy(k) = sy(k-1) - ( k + 1.0_sp ) * sy(k) / x
  end do

end subroutine sphy

attributes(device) subroutine stvh0 ( x, sh0 )

!*****************************************************************************80
!
!! STVH0 computes the Struve function H0(x).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    22 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  SH0, the value of H0(x).
!
  implicit none

  real(kind=sp) ::  a0
  real(kind=sp) ::  by0
  integer(kind=i4) :: k
  integer(kind=i4) :: km
  real(kind=sp) ::  p0
  real(kind=sp) ::  pi
  real(kind=sp) ::  q0
  real(kind=sp) ::  r
  real(kind=sp) ::  s
  real(kind=sp) ::  sh0
  real(kind=sp) ::  t
  real(kind=sp) ::  t2
  real(kind=sp) ::  ta0
  real(kind=sp) ::  x

  pi = 3.14159265358979323846264_sp
  s = 1.0_sp
  r = 1.0_sp

  if ( x <= 20.0_sp ) then
    a0 = 2.0_sp * x / pi
    do k = 1, 60
      r = - r * x / ( 2.0_sp * k + 1.0_sp ) * x &
        / ( 2.0_sp * k + 1.0_sp )
      s = s + r
      if ( abs ( r ) < abs ( s ) * 1.0e-12_sp ) then
        exit
      end if
    end do

    sh0 = a0 * s

  else

    if ( x < 50.0_sp ) then
      km = int ( 0.5_sp * ( x + 1.0_sp ) )
    else
      km = 25
    end if

    do k = 1, km
      r = - r * ( ( 2.0_sp * k - 1.0_sp ) / x ) ** 2
      s = s + r
      if ( abs ( r ) < abs ( s ) * 1.0e-12_sp ) then
        exit
      end if
    end do

    t = 4.0_sp / x
    t2 = t * t

    p0 = (((( &
      - 0.37043e-05_sp     * t2 &
      + 0.173565e-04_sp )  * t2 &
      - 0.487613e-04_sp )  * t2 &
      + 0.17343e-03_sp )   * t2 &
      - 0.1753062e-02_sp ) * t2 &
      + 0.3989422793_sp

    q0 = t * ((((( &
        0.32312e-05_sp     * t2 &
      - 0.142078e-04_sp )  * t2 &
      + 0.342468e-04_sp )  * t2 &
      - 0.869791e-04_sp )  * t2 &
      + 0.4564324e-03_sp ) * t2 &
      - 0.0124669441_sp )

    ta0 = x - 0.25_sp * pi
    by0 = 2.0_sp / sqrt ( x ) &
      * ( p0 * sin ( ta0 ) + q0 * cos ( ta0 ) )
    sh0 = 2.0_sp / ( pi * x ) * s + by0

  end if

end

attributes(device) subroutine stvh1 ( x, sh1 )

!*****************************************************************************80
!
!! STVH1 computes the Struve function H1(x).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    22 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  SH1, the value of H1(x).
!
  implicit none

  real(kind=sp) ::  a0
  real(kind=sp) ::  by1
  integer(kind=i4) :: k
  integer(kind=i4) :: km
  real(kind=sp) ::  p1
  real(kind=sp) ::  pi
  real(kind=sp) ::  q1
  real(kind=sp) ::  r
  real(kind=sp) ::  s
  real(kind=sp) ::  sh1
  real(kind=sp) ::  t
  real(kind=sp) ::  t2
  real(kind=sp) ::  ta1
  real(kind=sp) ::  x

  pi = 3.14159265358979323846264_sp
  r = 1.0_sp

  if ( x <= 20.0_sp ) then

    s = 0.0_sp
    a0 = - 2.0_sp / pi
    do k = 1, 60
      r = - r * x * x / ( 4.0_sp * k * k - 1.0_sp )
      s = s + r
      if ( abs ( r ) < abs ( s ) * 1.0e-12 ) then
        exit
      end if
    end do

    sh1 = a0 * s

  else

    s = 1.0_sp

    if ( x <= 50.0_sp ) then
      km = int ( 0.5_sp * x )
    else
      km = 25
    end if

    do k = 1, km
      r = - r * ( 4.0_sp * k * k - 1.0_sp ) / ( x * x )
      s = s + r
      if ( abs ( r ) < abs ( s ) * 1.0e-12 ) then
        exit
      end if
    end do

    t = 4.0_sp / x
    t2 = t * t

    p1 = (((( &
        0.42414e-05_sp      * t2 &
      - 0.20092e-04_sp )    * t2 &
      + 0.580759e-04_sp )   * t2 &
      - 0.223203e-03_sp )   * t2 &
      + 0.29218256e-02_sp ) * t2 &
      + 0.3989422819_sp

    q1 = t * ((((( &
      - 0.36594e-05_sp     * t2 &
      + 0.1622e-04_sp )    * t2 &
      - 0.398708e-04_sp )  * t2 &
      + 0.1064741e-03_sp ) * t2 &
      - 0.63904e-03_sp )   * t2 &
      + 0.0374008364_sp )

    ta1 = x - 0.75_sp * pi
    by1 = 2.0_sp / sqrt ( x ) * ( p1 * sin ( ta1 ) + q1 * cos ( ta1 ) )
    sh1 = 2.0_sp / pi * ( 1.0_sp + s / ( x * x ) ) + by1

  end if

end

attributes(device) subroutine stvhv ( v, x, hv )

!*****************************************************************************80
!
!! STVHV computes the Struve function Hv(x) with arbitrary order v.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    24 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  V, the order of the function.
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  HV, the value of Hv(x).
!
  implicit none

  real(kind=sp) ::  bf
  real(kind=sp) ::  bf0
  real(kind=sp) ::  bf1
  real(kind=sp) ::  by0
  real(kind=sp) ::  by1
  real(kind=sp) ::  byv
  real(kind=sp) ::  ga
  real(kind=sp) ::  gb
  real(kind=sp) ::  hv
  integer(kind=i4) :: k
  integer(kind=i4) :: l
  integer(kind=i4) :: n
  real(kind=sp) ::  pi
  real(kind=sp) ::  pu0
  real(kind=sp) ::  pu1
  real(kind=sp) ::  qu0
  real(kind=sp) ::  qu1
  real(kind=sp) ::  r1
  real(kind=sp) ::  r2
  real(kind=sp) ::  s
  real(kind=sp) ::  s0
  real(kind=sp) ::  sa
  real(kind=sp) ::  sr
  real(kind=sp) ::  t0
  real(kind=sp) ::  t1
  real(kind=sp) ::  u
  real(kind=sp) ::  u0
  real(kind=sp) ::  v
  real(kind=sp) ::  v0
  real(kind=sp) ::  va
  real(kind=sp) ::  vb
  real(kind=sp) ::  vt
  real(kind=sp) ::  x

  pi = 3.141592653589793_sp

  

  if ( x <= 20.0_sp ) then

    v0 = v + 1.5_sp
    call gamma ( v0, ga )
    s = 2.0_sp / ( sqrt ( pi ) * ga )
    r1 = 1.0_sp

    do k = 1, 100
      va = k + 1.5_sp
      call gamma ( va, ga )
      vb = v + k + 1.5_sp
      call gamma ( vb, gb )
      r1 = -r1 * ( 0.5_sp * x ) ** 2
      r2 = r1 / ( ga * gb )
      s = s + r2
      if ( abs ( r2 ) < abs ( s ) * 1.0e-12 ) then
        exit
      end if
    end do

    hv = ( 0.5_sp * x ) ** ( v + 1.0_sp ) * s

  else

    sa = ( 0.5_sp * x ) ** ( v - 1.0_sp ) / pi
    v0 = v + 0.5_sp
    call gamma ( v0, ga )
    s = 1.77245385090551602729817_sp / ga
    r1 = 1.0_sp

    do k = 1, 12
      va = k + 0.5_sp
      call gamma ( va, ga )
      vb = - k + v + 0.5_sp
      call gamma ( vb, gb )
      r1 = r1 / ( 0.5_sp * x ) ** 2
      s = s + r1 * ga / gb
    end do

    s0 = sa * s
    u = abs ( v )
    n = int ( u )
    u0 = u - n

    do l = 0, 1

      vt = 4.0_sp * ( u0 + l ) ** 2
      r1 = 1.0_sp
      pu1 = 1.0_sp
      do k = 1, 12
        r1 = -0.0078125_sp * r1 &
          * ( vt - ( 4.0_sp * k - 3.0_sp ) ** 2 ) &
          * ( vt - ( 4.0_sp * k - 1.0_sp ) ** 2 ) &
          / ( ( 2.0_sp * k - 1.0_sp ) * k * x * x )
        pu1 = pu1 + r1
      end do

      qu1 = 1.0_sp
      r2 = 1.0_sp
      do k = 1, 12
        r2 = -0.0078125_sp * r2 &
          * ( vt - ( 4.0_sp * k - 1.0_sp ) ** 2 ) &
          * ( vt - ( 4.0_sp * k + 1.0_sp ) ** 2 ) &
          / ( ( 2.0_sp * k + 1.0_sp ) * k * x * x )
        qu1 = qu1 + r2
      end do
      qu1 = 0.125_sp * ( vt - 1.0_sp ) / x * qu1

      if ( l == 0 ) then
        pu0 = pu1
        qu0 = qu1
      end if

    end do

    t0 = x - ( 0.5_sp * u0 + 0.25_sp ) * pi
    t1 = x - ( 0.5_sp * u0 + 0.75_sp ) * pi
    sr = sqrt ( 2.0_sp / ( pi * x ) )
    by0 = sr * ( pu0 * sin ( t0 ) + qu0 * cos ( t0 ) )
    by1 = sr * ( pu1 * sin ( t1 ) + qu1 * cos ( t1 ) )
    bf0 = by0
    bf1 = by1
    do k = 2, n
      bf = 2.0_sp * ( k - 1.0_sp + u0 ) / x * bf1 - bf0
      bf0 = bf1
      bf1 = bf
    end do

    if ( n == 0 ) then
      byv = by0
    else if ( n == 1 ) then
      byv = by1
    else
      byv = bf
    end if
    hv = byv + s0
  end if

end

attributes(device) subroutine stvl0 ( x, sl0 )

!*****************************************************************************80
!
!! STVL0 computes the modified Struve function L0(x).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    22 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  SL0, the function value.
!
  implicit none

  real(kind=sp) ::  a0
  real(kind=sp) ::  a1
  real(kind=sp) ::  bi0
  integer(kind=i4) :: k
  integer(kind=i4) :: km
  real(kind=sp) ::  pi
  real(kind=sp) ::  r
  real(kind=sp) ::  s
  real(kind=sp) ::  sl0
  real(kind=sp) ::  x

  pi = 3.14159265358979323846264_sp
  s = 1.0_sp
  r = 1.0_sp

  if ( x <= 20.0_sp ) then

    a0 = 2.0_sp * x / pi

    do k = 1, 60
      r = r * ( x / ( 2.0_sp * k + 1.0_sp ) ) ** 2
      s = s + r
      if ( abs ( r / s ) < 1.0e-12 ) then
        exit
      end if
    end do

    sl0 = a0 * s

  else

    if ( x < 50.0_sp ) then
      km = int ( 0.5_sp * ( x + 1.0_sp ) )
    else
      km = 25
    end if

    do k = 1, km
      r = r * ( ( 2.0_sp * k - 1.0_sp ) / x ) ** 2
      s = s + r
      if ( abs ( r / s ) < 1.0e-12 ) then
        exit
      end if
    end do

    a1 = exp ( x ) / sqrt ( 2.0_sp * pi * x )
    r = 1.0_sp
    bi0 = 1.0_sp
    do k = 1, 16
      r = 0.125_sp * r * ( 2.0_sp * k - 1.0_sp ) ** 2 / ( k * x )
      bi0 = bi0 + r
      if ( abs ( r / bi0 ) < 1.0e-12 ) then
        exit
      end if
    end do

    bi0 = a1 * bi0
    sl0 = - 2.0_sp / ( pi * x ) * s + bi0

  end if

end


attributes(device) subroutine stvl1 ( x, sl1 )

!*****************************************************************************80
!
!! STVL1 computes the modified Struve function L1(x).
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    05 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Output, real(kind=sp) ::  SL1, the function value.
!
  implicit none

  real(kind=sp) ::  a1
  real(kind=sp) ::  bi1
  integer(kind=i4) :: k
  integer(kind=i4) :: km
  real(kind=sp) ::  pi
  real(kind=sp) ::  r
  real(kind=sp) ::  s
  real(kind=sp) ::  sl1
  real(kind=sp) ::  x

  pi = 3.14159265358979323846264_sp
  r = 1.0_sp
  if ( x <= 20.0_sp ) then
    s = 0.0_sp
    do k = 1, 60
      r = r * x * x / ( 4.0_sp * k * k - 1.0_sp )
      s = s + r
      if ( abs ( r / s ) < 1.0e-12 ) then
        exit
      end if
    end do

    sl1 = 2.0_sp / pi * s

  else

    s = 1.0_sp
    km = int ( 0.50_sp * x )
    km = min ( km, 25 )

    do k = 1, km
      r = r * ( 2.0_sp * k + 3.0_sp ) &
        * ( 2.0_sp * k + 1.0_sp ) / ( x * x )
      s = s + r
      if ( abs ( r / s ) < 1.0e-12 ) then
        exit
      end if
    end do

    sl1 = 2.0_sp / pi * ( -1.0_sp + 1.0_sp &
      / ( x * x ) + 3.0_sp * s / x**4 )
    a1 = exp ( x ) / sqrt ( 2.0_sp * pi * x )
    r = 1.0_sp
    bi1 = 1.0_sp
    do k = 1, 16
      r = -0.125_sp * r &
        * ( 4.0_sp - ( 2.0_sp * k - 1.0_sp ) ** 2 ) / ( k * x )
      bi1 = bi1 + r
      if ( abs ( r / bi1 ) < 1.0e-12 ) then
        exit
      end if
    end do

    sl1 = sl1 + a1 * bi1

  end if

end


attributes(device) subroutine stvlv ( v, x, slv )

!*****************************************************************************80
!
!! STVLV computes the modified Struve function Lv(x) with arbitary order.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    04 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  V, the order of Lv(x).
!
!    Input, real(kind=sp) ::  X, the argument of Lv(x).
!
!    Output, real(kind=sp) ::  SLV, the value of Lv(x).
!
  implicit none

  real(kind=sp) ::  bf
  real(kind=sp) ::  bf0
  real(kind=sp) ::  bf1
  real(kind=sp) ::  biv
  real(kind=sp) ::  biv0
  real(kind=sp) ::  ga
  real(kind=sp) ::  gb
  integer(kind=i4) :: k
  integer(kind=i4) :: l
  integer(kind=i4) :: n
  real(kind=sp) ::  pi
  real(kind=sp) ::  r
  real(kind=sp) ::  r1
  real(kind=sp) ::  r2
  real(kind=sp) ::  s
  real(kind=sp) ::  s0
  real(kind=sp) ::  sa
  real(kind=sp) ::  slv
  real(kind=sp) ::  u
  real(kind=sp) ::  u0
  real(kind=sp) ::  v
  real(kind=sp) ::  v0
  real(kind=sp) ::  va
  real(kind=sp) ::  vb
  real(kind=sp) ::  vt
  real(kind=sp) ::  x

  pi = 3.14159265358979323846264_sp

  if ( x == 0.0_sp ) then

    if ( -1.0_sp < v .or. int ( v ) - v == 0.5_sp ) then
      slv = 0.0_sp
    else if ( v < -1.0_sp ) then
      slv = ( -1 ) ** ( int ( 0.5_sp - v ) - 1 ) * huge(1.0_sp,kind=sp)
    else if ( v == -1.0_sp ) then
      slv = 2.0_sp / pi
    end if

  else if ( x <= 40.0_sp ) then

    v0 = v + 1.5_sp
    call gamma ( v0, ga )
    s = 2.0_sp / ( 1.77245385090551602729817_sp * ga )
    r1 = 1.0_sp
    do k = 1, 100
      va = k + 1.5_sp
      call gamma ( va, ga )
      vb = v + k + 1.5_sp
      call gamma ( vb, gb )
      r1 = r1 * ( 0.5_sp * x ) ** 2
      r2 = r1 / ( ga * gb )
      s = s + r2
      if ( abs ( r2 / s ) < 1.0e-12 ) then
        exit
      end if
    end do

    slv = ( 0.5_sp * x ) ** ( v + 1.0_sp ) * s

  else

    sa = -1.0_sp / pi * ( 0.5_sp * x ) ** ( v - 1.0_sp )
    v0 = v + 0.5_sp
    call gamma ( v0, ga )
    s = - 1.77245385090551602729817_sp / ga
    r1 = -1.0_sp
    do k = 1, 12
      va = k + 0.5_sp
      call gamma ( va, ga )
      vb = - k + v + 0.5_sp
      call gamma ( vb, gb )
      r1 = - r1 / ( 0.5_sp * x ) ** 2
      s = s + r1 * ga / gb
    end do
    s0 = sa * s
    u = abs ( v )
    n = int ( u )
    u0 = u - n
    do l = 0, 1
      vt = u0 + l
      r = 1.0_sp
      biv = 1.0_sp
      do k = 1, 16
        r = -0.125_sp * r * ( 4.0_sp * vt * vt - &
          ( 2.0_sp * k - 1.0_sp )**2 ) / ( k * x )
        biv = biv + r
        if ( abs ( r / biv ) < 1.0e-12 ) then
          exit
        end if
      end do

      if ( l == 0 ) then
        biv0 = biv
      end if

    end do

    bf0 = biv0
    bf1 = biv
    do k = 2, n
      bf = - 2.0_sp * ( k - 1.0_sp + u0 ) / x * bf1 + bf0
      bf0 = bf1
      bf1 = bf
    end do

    if ( n == 0 ) then
      biv = biv0
    else if ( 1 < n ) then
      biv = bf
    end if

    slv = exp ( x ) / sqrt ( 2.0_sp * pi * x ) * biv + s0

  end if

end


attributes(device) subroutine vvla ( va, x, pv )

!*****************************************************************************80
!
!! VVLA computes parabolic cylinder function Vv(x) for large arguments.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    04 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Input, real(kind=sp) ::  VA, the order nu.
!
!    Output, real(kind=sp) ::  PV, the value of V(nu,x).
!
  implicit none

  real(kind=sp) ::  a0
  real(kind=sp) ::  dsl
  real(kind=sp) ::  eps
  real(kind=sp) ::  gl
  integer(kind=i4) :: k
  real(kind=sp) ::  pdl
  real(kind=sp) ::  pi
  real(kind=sp) ::  pv
  real(kind=sp) ::  qe
  real(kind=sp) ::  r
  real(kind=sp) ::  va
  real(kind=sp) ::  x
  real(kind=sp) ::  x1

  pi = 3.14159265358979323846264_sp
  eps = 1.0e-12_sp
  qe = exp ( 0.25_sp * x * x )
  a0 = abs ( x ) ** ( -va - 1.0_sp ) * sqrt ( 2.0_sp / pi ) * qe

  r = 1.0_sp
  pv = 1.0_sp
  do k = 1, 18
    r = 0.5_sp * r * ( 2.0_sp * k + va - 1.0_sp ) &
      * ( 2.0_sp * k + va ) / ( k * x * x )
    pv = pv + r
    if ( abs ( r / pv ) < eps ) then
      exit
    end if
  end do

  pv = a0 * pv

  if ( x < 0.0_sp ) then
    x1 = -x
    call dvla ( va, x1, pdl )
    call gamma ( -va, gl )
    dsl = sin ( pi * va ) * sin ( pi * va )
    pv = dsl * gl / pi * pdl - cos ( pi * va ) * pv
  end if

end


attributes(device) subroutine vvsa ( va, x, pv )

!*****************************************************************************80
!
!! VVSA computes parabolic cylinder function V(nu,x) for small arguments.
!
!  Licensing:
!
!    This routine is copyrighted by Shanjie Zhang and Jianming Jin.  However, 
!    they give permission to incorporate this routine into a user program 
!    provided that the copyright is acknowledged.
!
!  Modified:
!
!    04 July 2012
!
!  Author:
!
!    Shanjie Zhang, Jianming Jin
!
!  Reference:
!
!    Shanjie Zhang, Jianming Jin,
!    Computation of Special Functions,
!    Wiley, 1996,
!    ISBN: 0-471-11963-6,
!    LC: QA351.C45.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  X, the argument.
!
!    Input, real(kind=sp) ::  VA, the order nu.
!
!    Output, real(kind=sp) ::  PV, the value of V(nu,x).
!
  implicit none

  real(kind=sp) ::  a0
  real(kind=sp) ::  ep
  real(kind=sp) ::  eps
  real(kind=sp) ::  fac
  real(kind=sp) ::  g1
  real(kind=sp) ::  ga0
  real(kind=sp) ::  gm
  real(kind=sp) ::  gw
  integer(kind=i4) :: m
  real(kind=sp) ::  pi
  real(kind=sp) ::  pv
  real(kind=sp) ::  r
  real(kind=sp) ::  r1
  real(kind=sp) ::  sq2
  real(kind=sp) ::  sv
  real(kind=sp) ::  sv0
  real(kind=sp) ::  v1
  real(kind=sp) ::  va
  real(kind=sp) ::  va0
  real(kind=sp) ::  vb0
  real(kind=sp) ::  vm
  real(kind=sp) ::  x

  eps = 1.0e-15_sp
  pi = 3.14159265358979323846264_sp
  ep = exp ( -0.25_sp * x * x )
  va0 = 1.0_sp + 0.5_sp * va

  if ( x == 0.0_sp ) then

    if ( ( va0 <= 0.0_sp .and. va0 == int ( va0 ) ) .or. &
      va == 0.0_sp ) then
      pv = 0.0_sp
    else
      vb0 = -0.5_sp * va
      sv0 = sin ( va0 * pi )
      call gamma ( va0, ga0 )
      pv = 2.0_sp ** vb0 * sv0 / ga0
    end if

  else

    sq2 = sqrt ( 2.0_sp )
    a0 = 2.0_sp ** ( -0.5_sp * va ) * ep / ( 2.0_sp * pi )
    sv = sin ( - ( va + 0.5_sp ) * pi )
    v1 = -0.5_sp * va
    call gamma ( v1, g1 )
    pv = ( sv + 1.0_sp ) * g1
    r = 1.0_sp
    fac = 1.0_sp

    do m = 1, 250
      vm = 0.5_sp * ( m - va )
      call gamma ( vm, gm )
      r = r * sq2 * x / m
      fac = - fac
      gw = fac * sv + 1.0_sp
      r1 = gw * r * gm
      pv = pv + r1
      if ( abs ( r1 / pv ) < eps .and. gw /= 0.0_sp ) then
        exit
      end if
    end do

    pv = a0 * pv

  end if

end


attributes(device) subroutine calci0 ( arg, result, jint )

!*****************************************************************************80
!
!! CALCI0 computes various I0 Bessel functions.
!
!  Discussion:
!
!    This routine computes modified Bessel functions of the first kind
!    and order zero, I0(X) and EXP(-ABS(X))*I0(X), for real
!    arguments X.
!
!    The main computation evaluates slightly modified forms of
!    minimax approximations generated by Blair and Edwards, Chalk
!    River (Atomic Energy of Canada Limited) Report AECL-4928,
!    October, 1974.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody, Laura Stoltz.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  ARG, the argument.  If JINT = 1, then
!    the argument must be less than XMAX.
!
!    Output, real(kind=sp) ::  RESULT, the value of the function,
!    which depends on the input value of JINT:
!    1, RESULT = I0(x);
!    2, RESULT = exp(-x) * I0(x);
!
!    Input, integer(kind=i4) :: JINT, chooses the function to be computed.
!    1, I0(x);
!    2, exp(-x) * I0(x);
!
  implicit none

  real(kind=sp) ::  a
  real(kind=sp) ::  arg
  real(kind=sp) ::  b
  real(kind=sp) ::  exp40
  real(kind=sp) ::  forty
  integer(kind=i4) :: i
  integer(kind=i4) :: jint
  real(kind=sp) ::  one
  real(kind=sp) ::  one5
  real(kind=sp) ::  p(15)
  real(kind=sp) ::  pp(8)
  real(kind=sp) ::  q(5)
  real(kind=sp) ::  qq(7)
  real(kind=sp) ::  result
  real(kind=sp) ::  rec15
  real(kind=sp) ::  sump
  real(kind=sp) ::  sumq
  real(kind=sp) ::  two25
  real(kind=sp) ::  x
  real(kind=sp) ::  xinf
  real(kind=sp) ::  xmax
  real(kind=sp) ::  xsmall
  real(kind=sp) ::  xx
!
!  Mathematical constants
!
  data one /1.0e+00_sp/
  data one5 /15.0e+00_sp/
  data exp40 /2.353852668370199854e+17_sp/
  data forty /40.0e+00_sp/
  data rec15 /6.6666666666666666666e-2_sp/
  data two25 /225.0e+00_sp/
!
!  Machine-dependent constants
!
  data xsmall /5.55e-17_sp/
  data xinf /3.4028235e+38_sp/
  data xmax /713.986e+00/
!
!  Coefficients for XSMALL <= ABS(ARG) < 15.0
!
  data  p/-5.2487866627945699800e-18_sp,-1.5982226675653184646e-14_sp, &
          -2.6843448573468483278e-11_sp,-3.0517226450451067446e-08_sp, &
          -2.5172644670688975051e-05_sp,-1.5453977791786851041e-02_sp, &
          -7.0935347449210549190e+00_sp,-2.4125195876041896775e+03_sp, &
          -5.9545626019847898221e+05_sp,-1.0313066708737980747e+08_sp, &
          -1.1912746104985237192e+10_sp,-8.4925101247114157499e+11_sp, &
          -3.2940087627407749166e+13_sp,-5.5050369673018427753e+14_sp, &
          -2.2335582639474375249e+15_sp/
  data  q/-3.7277560179962773046e+03_sp, 6.5158506418655165707e+06_sp, &
          -6.5626560740833869295e+09_sp, 3.7604188704092954661e+12_sp, &
          -9.7087946179594019126e+14_sp/
!
!  Coefficients for 15.0 <= ABS(ARG)
!
  data pp/-3.9843750000000000000e-01_sp, 2.9205384596336793945e+00_sp, &
          -2.4708469169133954315e+00_sp, 4.7914889422856814203e-01_sp, &
          -3.7384991926068969150e-03_sp,-2.6801520353328635310e-03_sp, &
           9.9168777670983678974e-05_sp,-2.1877128189032726730e-06_sp/
  data qq/-3.1446690275135491500e+01_sp, 8.5539563258012929600e+01_sp, &
          -6.0228002066743340583e+01_sp, 1.3982595353892851542e+01_sp, &
          -1.1151759188741312645e+00_sp, 3.2547697594819615062e-02_sp, &
          -5.5194330231005480228e-04_sp/

  x = abs ( arg )

  if ( x < xsmall ) then

    result = one
!
!  XSMALL <= ABS(ARG) < 15.0_sp
!
  else if ( x < one5 ) then

    xx = x * x
    sump = p(1)
    do i = 2, 15
      sump = sump * xx + p(i)
    end do
    xx = xx - two25

    sumq = (((( &
        xx + q(1) ) &
      * xx + q(2) ) &
      * xx + q(3) ) &
      * xx + q(4) ) &
      * xx + q(5)

    result = sump / sumq

    if ( jint == 2 ) then
      result = result * exp ( - x )
    end if

  else if ( one5 <= x ) then

    if ( jint == 1 .and. xmax < x ) then
      result = xinf
    else
!
!  15.0 <= ABS(ARG).
!
      xx = one / x - rec15

      sump = (((((( &
               pp(1) &
        * xx + pp(2) ) &
        * xx + pp(3) ) &
        * xx + pp(4) ) &
        * xx + pp(5) ) &
        * xx + pp(6) ) &
        * xx + pp(7) ) &
        * xx + pp(8)

      sumq = (((((( &
          xx + qq(1) ) &
        * xx + qq(2) ) &
        * xx + qq(3) ) &
        * xx + qq(4) ) &
        * xx + qq(5) ) &
        * xx + qq(6) ) &
        * xx + qq(7)

      result = sump / sumq

      if ( jint == 2 ) then
        result = ( result - pp(1) ) / sqrt ( x )
      else
!
!  Calculation reformulated to avoid premature overflow.
!
        if ( x .le.( xmax - one5 ) ) then
          a = exp ( x )
          b = one
        else
          a = exp ( x - forty )
          b = exp40
        end if

        result = ( ( result * a - pp(1) * a ) / sqrt ( x ) ) * b

      end if

    end if

  end if
  
end subroutine calci0


attributes(device) subroutine calci1 ( arg, result, jint )

!*****************************************************************************80
!
!! CALCI1 computes various I1 Bessel functions.
!
!  Discussion:
!
!    This routine computes modified Bessel functioons of the first kind
!    and order one, I1(X) and EXP(-ABS(X))*I1(X), for real
!    arguments X.
!
!    The main computation evaluates slightly modified forms of
!    minimax approximations generated by Blair and Edwards, Chalk
!    River (Atomic Energy of Canada Limited) Report AECL-4928,
!    October, 1974.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody, Laura Stoltz.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  ARG, the argument.  If JINT = 1, then
!    the argument must be less than XMAX.
!
!    Output, real(kind=sp) ::  RESULT, the value of the function,
!    which depends on the input value of JINT:
!    1, RESULT = I1(x);
!    2, RESULT = exp(-x) * I1(x);
!
!    Input, integer(kind=i4) :: JINT, chooses the function to be computed.
!    1, I1(x);
!    2, exp(-x) * I1(x);
!
  implicit none

  real(kind=sp) ::  a
  real(kind=sp) ::  arg
  real(kind=sp) ::  b
  real(kind=sp) ::  exp40
  real(kind=sp) ::  forty
  real(kind=sp) ::  half
  integer(kind=i4) :: j
  integer(kind=i4) :: jint
  real(kind=sp) ::  one
  real(kind=sp) ::  one5
  real(kind=sp) ::  p(15)
  real(kind=sp) ::  pbar
  real(kind=sp) ::  pp(8)
  real(kind=sp) ::  q(5)
  real(kind=sp) ::  qq(6)
  real(kind=sp) ::  rec15
  real(kind=sp) ::  result
  real(kind=sp) ::  sump
  real(kind=sp) ::  sumq
  real(kind=sp) ::  two25
  real(kind=sp) ::  x
  real(kind=sp) ::  xinf
  real(kind=sp) ::  xmax
  real(kind=sp) ::  xsmall
  real(kind=sp) ::  xx
  real(kind=sp) ::  zero
!
!  Mathematical constants
!
  data one /1.0_sp/
  data one5 /15.0_sp/
  data exp40 /2.353852668370199854e+17_sp/
  data forty /40.0_sp/
  data rec15 /6.6666666666666666666e-2_sp/
  data two25 /225.0_sp/
  data half /0.5_sp/
  data zero /0.0_sp/
!
!  Machine-dependent constants
!
  data xsmall /5.55e-17_sp/
  data xinf /3.4028235e+38_sp/
  data xmax /713.987_sp/
!
!  Coefficients for XSMALL <= ABS(ARG) < 15.0
!
  data p/-1.9705291802535139930e-19_sp,-6.5245515583151902910e-16_sp, &
         -1.1928788903603238754e-12_sp,-1.4831904935994647675e-09_sp, &
         -1.3466829827635152875e-06_sp,-9.1746443287817501309e-04_sp, &
         -4.7207090827310162436e-01_sp,-1.8225946631657315931e+02_sp, &
         -5.1894091982308017540e+04_sp,-1.0588550724769347106e+07_sp, &
         -1.4828267606612366099e+09_sp,-1.3357437682275493024e+11_sp, &
         -6.9876779648010090070e+12_sp,-1.7732037840791591320e+14_sp, &
         -1.4577180278143463643e+15_sp/
  data q/-4.0076864679904189921e+03_sp, 7.4810580356655069138e+06_sp, &
         -8.0059518998619764991e+09_sp, 4.8544714258273622913e+12_sp, &
         -1.3218168307321442305e+15_sp/
!
!  Coefficients for 15.0 <= ABS(ARG)
!
  data pp/-6.0437159056137600000e-02_sp, 4.5748122901933459000e-01_sp, &
          -4.2843766903304806403e-01_sp, 9.7356000150886612134e-02_sp, &
          -3.2457723974465568321e-03_sp,-3.6395264712121795296e-04_sp, &
           1.6258661867440836395e-05_sp,-3.6347578404608223492e-07_sp/
  data qq/-3.8806586721556593450e+00_sp, 3.2593714889036996297e+00_sp, &
          -8.5017476463217924408e-01_sp, 7.4212010813186530069e-02_sp, &
          -2.2835624489492512649e-03_sp, 3.7510433111922824643e-05_sp/
  data pbar/3.98437500e-01_sp/

  x = abs ( arg )
!
!  Return for ABS(ARG) < XSMALL.
!
  if ( x < xsmall ) then

    result = half * x
!
!  XSMALL <= ABS(ARG) < 15.0
!
  else if ( x < one5 ) then

    xx = x * x
    sump = p(1)
    do j = 2, 15
      sump = sump * xx + p(j)
    end do
    xx = xx - two25

    sumq = (((( &
        xx + q(1) ) &
      * xx + q(2) ) &
      * xx + q(3) ) &
      * xx + q(4) ) &
      * xx + q(5)

    result = ( sump / sumq ) * x

    if ( jint == 2 ) then
      result = result * exp ( -x )
    end if

  else if ( jint == 1 .and. xmax < x ) then

    result = xinf

  else
!
!  15.0 <= ABS(ARG).
!
    xx = one / x - rec15

    sump = (((((( &
             pp(1) &
      * xx + pp(2) ) &
      * xx + pp(3) ) &
      * xx + pp(4) ) &
      * xx + pp(5) ) &
      * xx + pp(6) ) &
      * xx + pp(7) ) &
      * xx + pp(8)

    sumq = ((((( &
        xx + qq(1) ) &
      * xx + qq(2) ) &
      * xx + qq(3) ) &
      * xx + qq(4) ) &
      * xx + qq(5) ) &
      * xx + qq(6)

    result = sump / sumq

    if ( jint /= 1 ) then
      result = ( result + pbar ) / sqrt ( x )
    else
!
!  Calculation reformulated to avoid premature overflow.
!
      if ( xmax - one5 < x ) then
        a = exp ( x - forty )
        b = exp40
      else
        a = exp ( x )
        b = one
      end if

      result = ( ( result * a + pbar * a ) / sqrt ( x ) ) * b

    end if
  end if

  if ( arg < zero ) then
    result = -result
  end if

end subroutine calci1


attributes(device) subroutine calck0 ( arg, result, jint )

!*****************************************************************************80
!
!! CALCK0 computes various K0 Bessel functions.
!
!  Discussion:
!
!    This routine computes modified Bessel functions of the second kind
!    and order zero, K0(X) and EXP(X)*K0(X), for real
!    arguments X.
!
!    The main computation evaluates slightly modified forms of near
!    minimax rational approximations generated by Russon and Blair,
!    Chalk River (Atomic Energy of Canada Limited) Report AECL-3461,
!    1969.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody, Laura Stoltz.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  ARG, the argument.  0 < ARG is
!    always required.  If JINT = 1, then the argument must also be
!    less than XMAX.
!
!    Output, real(kind=sp) ::  RESULT, the value of the function,
!    which depends on the input value of JINT:
!    1, RESULT = K0(x);
!    2, RESULT = exp(x) * K0(x);
!
!    Input, integer(kind=i4) :: JINT, chooses the function to be computed.
!    1, K0(x);
!    2, exp(x) * K0(x);
!
  implicit none

  integer(kind=i4) :: i
  integer(kind=i4) :: jint
  real(kind=sp) ::  arg
  real(kind=sp) ::  f(4)
  real(kind=sp) ::  g(3)
  real(kind=sp) ::  one
  real(kind=sp) ::  p(6)
  real(kind=sp) ::  pp(10)
  real(kind=sp) ::  q(2)
  real(kind=sp) ::  qq(10)
  real(kind=sp) ::  result
  real(kind=sp) ::  sumf
  real(kind=sp) ::  sumg
  real(kind=sp) ::  sump
  real(kind=sp) ::  sumq
  real(kind=sp) ::  temp
  real(kind=sp) ::  x
  real(kind=sp) ::  xinf
  real(kind=sp) ::  xmax
  real(kind=sp) ::  xsmall
  real(kind=sp) ::  xx
  real(kind=sp) ::  zero
!
!  Mathematical constants
!
  data one /1.0_sp/
  data zero /0.0_sp/
!
!  Machine-dependent constants
!
  data xsmall /5.96e-08_sp/
  data xinf /3.4028235e+38_sp/
  data xmax /705.342_sp/
!
!  Coefficients for XSMALL <= ARG <= 1.0
!
  data   p/ 5.8599221412826100000e-04_sp, 1.3166052564989571850e-01_sp, &
            1.1999463724910714109e+01_sp, 4.6850901201934832188e+02_sp, &
            5.9169059852270512312e+03_sp, 2.4708152720399552679e+03_sp/
  data   q/-2.4994418972832303646e+02_sp, 2.1312714303849120380e+04_sp/
  data   f/-1.6414452837299064100e+00_sp,-2.9601657892958843866e+02_sp, &
           -1.7733784684952985886e+04_sp,-4.0320340761145482298e+05_sp/
  data   g/-2.5064972445877992730e+02_sp, 2.9865713163054025489e+04_sp, &
           -1.6128136304458193998e+06_sp/
!
!  Coefficients for  1.0 < ARG
!
  data  pp/ 1.1394980557384778174e+02_sp, 3.6832589957340267940e+03_sp, &
            3.1075408980684392399e+04_sp, 1.0577068948034021957e+05_sp, &
            1.7398867902565686251e+05_sp, 1.5097646353289914539e+05_sp, &
            7.1557062783764037541e+04_sp, 1.8321525870183537725e+04_sp, &
            2.3444738764199315021e+03_sp, 1.1600249425076035558e+02_sp/
  data  qq/ 2.0013443064949242491e+02_sp, 4.4329628889746408858e+03_sp, &
            3.1474655750295278825e+04_sp, 9.7418829762268075784e+04_sp, &
            1.5144644673520157801e+05_sp, 1.2689839587977598727e+05_sp, &
            5.8824616785857027752e+04_sp, 1.4847228371802360957e+04_sp, &
            1.8821890840982713696e+03_sp, 9.2556599177304839811e+01_sp/

  x = arg
!
!  0.0 < ARG <= 1.0.
!
  if ( zero < x ) then

    if ( x <= one ) then

      temp = log ( x )

      if ( x < xsmall ) then
!
!  Return for small ARG.
!
        result = p(6) / q(2) - temp

      else

        xx = x * x

        sump = (((( &
                 p(1) &
          * xx + p(2) ) &
          * xx + p(3) ) &
          * xx + p(4) ) &
          * xx + p(5) ) &
          * xx + p(6)

        sumq = ( xx + q(1) ) * xx + q(2)
        sumf = ( ( &
                 f(1) &
          * xx + f(2) ) &
          * xx + f(3) ) &
          * xx + f(4)

        sumg = ( ( xx + g(1) ) * xx + g(2) ) * xx + g(3)

        result = sump / sumq - xx * sumf * temp / sumg - temp

        if ( jint == 2 ) then
          result = result * exp ( x )
        end if

      end if

    else if ( jint == 1 .and. xmax < x ) then
!
!  Error return for XMAX < ARG.
!
      result = zero

    else
!
!  1.0 < ARG.
!
      xx = one / x
      sump = pp(1)
      do i = 2, 10
        sump = sump * xx + pp(i)
      end do

      sumq = xx
      do i = 1, 9
        sumq = ( sumq + qq(i) ) * xx
      end do
      sumq = sumq + qq(10)
      result = sump / sumq / sqrt ( x )

      if ( jint == 1 ) then
        result = result * exp ( -x )
      end if

    end if

  else
!
!  Error return for ARG <= 0.0.
!
    result = xinf

  end if

  
end subroutine calck0


attributes(device) subroutine calck1 ( arg, result, jint )

!*****************************************************************************80
!
!! CALCK1 computes various K1 Bessel functions.
!
!  Discussion:
!
!    This routine computes modified Bessel functions of the second kind
!    and order one, K1(X) and EXP(X)*K1(X), for real arguments X.
!
!    The main computation evaluates slightly modified forms of near
!    minimax rational approximations generated by Russon and Blair,
!    Chalk River (Atomic Energy of Canada Limited) Report AECL-3461,
!    1969.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody, Laura Stoltz.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  ARG, the argument.  XLEAST < ARG is
!    always required.  If JINT = 1, then the argument must also be
!    less than XMAX.
!
!    Output, real(kind=sp) ::  RESULT, the value of the function,
!    which depends on the input value of JINT:
!    1, RESULT = K1(x);
!    2, RESULT = exp(x) * K1(x);
!
!    Input, integer(kind=i4) :: JINT, chooses the function to be computed.
!    1, K1(x);
!    2, exp(x) * K1(x);
!
  implicit none

  real(kind=sp) ::  arg
  real(kind=sp) ::  f(5)
  real(kind=sp) ::  g(3)
  integer(kind=i4) :: i
  integer(kind=i4) :: jint
  real(kind=sp) ::  one
  real(kind=sp) ::  p(5)
  real(kind=sp) ::  pp(11)
  real(kind=sp) ::  q(3)
  real(kind=sp) ::  qq(9)
  real(kind=sp) ::  result
  real(kind=sp) ::  sumf
  real(kind=sp) ::  sumg
  real(kind=sp) ::  sump
  real(kind=sp) ::  sumq
  real(kind=sp) ::  x
 ! real(kind=sp) ::  xinf
  real(kind=sp) ::  xmax
  !real(kind=sp) ::  xleast
  !real(kind=sp) ::  xsmall
  real(kind=sp) ::  xx
  real(kind=sp) ::  zero
!
!  Mathematical constants
!
  data one /1.0_sp/
  data zero /0.0_sp/
!
!  Machine-dependent constants
!
  !data xleast /2.23e-308/
  !data xsmall /1.11e-16/
  !data xinf /1.79e+308/
  data xmax /705.343_sp/
!
!  Coefficients for  XLEAST <=  ARG  <= 1.0
!
  data   p/ 4.8127070456878442310e-1_sp, 9.9991373567429309922e+1_sp, &
            7.1885382604084798576e+3_sp, 1.7733324035147015630e+5_sp, &
            7.1938920065420586101e+5_sp/
  data   q/-2.8143915754538725829e+2_sp, 3.7264298672067697862e+4_sp, &
           -2.2149374878243304548e+6_sp/
  data   f/-2.2795590826955002390e-1_sp,-5.3103913335180275253e+1_sp, &
           -4.5051623763436087023e+3_sp,-1.4758069205414222471e+5_sp, &
           -1.3531161492785421328e+6_sp/
  data   g/-3.0507151578787595807e+2_sp, 4.3117653211351080007e+4_sp, &
           -2.7062322985570842656e+6_sp/
!
!  Coefficients for  1.0 < ARG
!
  data  pp/ 6.4257745859173138767e-2_sp, 7.5584584631176030810e+0_sp, &
            1.3182609918569941308e+2_sp, 8.1094256146537402173e+2_sp, &
            2.3123742209168871550e+3_sp, 3.4540675585544584407e+3_sp, &
            2.8590657697910288226e+3_sp, 1.3319486433183221990e+3_sp, &
            3.4122953486801312910e+2_sp, 4.4137176114230414036e+1_sp, &
            2.2196792496874548962e+0_sp/
  data  qq/ 3.6001069306861518855e+1_sp, 3.3031020088765390854e+2_sp, &
            1.2082692316002348638e+3_sp, 2.1181000487171943810e+3_sp, &
            1.9448440788918006154e+3_sp, 9.6929165726802648634e+2_sp, &
            2.5951223655579051357e+2_sp, 3.4552228452758912848e+1_sp, &
            1.7710478032601086579e+0_sp/

  x = arg
!
!  Error return for ARG < XLEAST.
!
  !if ( x < xleast ) then

    !result = xinf
!
!  XLEAST <= ARG <= 1.0.
!
  if ( x <= one ) then

   ! if ( x < xsmall ) then
!
!  Return for small ARG.
!
   !   result = one / x

    !else

      xx = x * x

      sump = (((( &
               p(1) &
        * xx + p(2) ) &
        * xx + p(3) ) &
        * xx + p(4) ) &
        * xx + p(5) ) &
        * xx + q(3)

      sumq = (( &
          xx + q(1) ) &
        * xx + q(2) ) &
        * xx + q(3)

      sumf = ((( &
               f(1) &
        * xx + f(2) ) &
        * xx + f(3) ) &
        * xx + f(4) ) &
        * xx + f(5)

      sumg = (( &
          xx + g(1) ) &
        * xx + g(2) ) &
        * xx + g(3)

      result = ( xx * log ( x ) * sumf / sumg + sump / sumq ) / x

      if ( jint == 2 ) then
        result = result * exp ( x )
      end if

    !end if

  else if ( jint == 1 .and. xmax < x ) then
!
!  Error return for XMAX < ARG.
!
    result = zero

  else
!
!  1.0 < ARG.
!
    xx = one / x

    sump = pp(1)
    do i = 2, 11
      sump = sump * xx + pp(i)
    end do

    sumq = xx
    do i = 1, 8
      sumq = ( sumq + qq(i) ) * xx
    end do
    sumq = sumq + qq(9)

    result = sump / sumq / sqrt ( x )

    if ( jint == 1 ) then
      result = result * exp ( -x )
    end if

  end if

  
end subroutine calck1


attributes(device) subroutine calerf ( arg, result, jint )

!*****************************************************************************80
!
!! CALERF computes various forms of the error function.
!
!  Discussion:
!
!    This routine evaluates erf(x), erfc(x), and exp(x*x)*erfc(x)
!    for a real argument x.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    William Cody,
!    Rational Chebyshev Approximations for the Error Function,
!    Mathematics of Computation,
!    Volume 23, Number 107, July 1969, pages 631-638.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  ARG, the argument.  If JINT is 1, the
!    argument must be less than XBIG.  If JINT is 2, the argument
!    must lie between XNEG and XMAX.
!
!    Output, real(kind=sp) ::  RESULT, the value of the function,
!    which depends on the input value of JINT:
!    0, RESULT = erf(x);
!    1, RESULT = erfc(x) = 1 - erf(x);
!    2, RESULT = exp(x*x)*erfc(x) = exp(x*x) - erf(x*x)*erf(x).
!
!    Input, integer(kind=i4) :: JINT, chooses the function to be computed.
!    0, erf(x);
!    1, erfc(x);
!    2, exp(x*x)*erfc(x).
!
  implicit none

  real(kind=sp) ::  a(5)
  real(kind=sp) ::  arg
  real(kind=sp) ::  b(4)
  real(kind=sp) ::  c(9)
  real(kind=sp) ::  d(8)
  real(kind=sp) ::  del
  real(kind=sp) ::  four
  real(kind=sp) ::  half
  integer(kind=i4) :: i
  integer(kind=i4) :: jint
  real(kind=sp) ::  one
  real(kind=sp) ::  p(6)
  real(kind=sp) ::  q(5)
  real(kind=sp) ::  result
  real(kind=sp) ::  sixten
  real(kind=sp) ::  sqrpi
  real(kind=sp) ::  two
  real(kind=sp) ::  thresh
  real(kind=sp) ::  x
  real(kind=sp) ::  xbig
  real(kind=sp) ::  xden
  real(kind=sp) ::  xhuge
  real(kind=sp) ::  xinf
  real(kind=sp) ::  xmax
  real(kind=sp) ::  xneg
  real(kind=sp) ::  xnum
  real(kind=sp) ::  xsmall
  real(kind=sp) ::  y
  real(kind=sp) ::  ysq
  real(kind=sp) ::  zero
!
!  Mathematical constants
!
  data four /4.0_sp/
  data one /1.0_sp/
  data half /0.5_sp/
  data two /2.0_sp/
  data zero /0.0_sp/
  data sqrpi /5.6418958354775628695e-1_sp/
  data thresh /0.46875_sp/
  data sixten /16.0_sp/
!
!  Machine-dependent constants
!
  data xinf /3.4028235e+38_sp /
  data xneg / -26.628_sp /
  data xsmall /1.11e-16_sp/
  data xbig /26.543_sp /
  data xhuge /6.71e+7_sp/
  data xmax /2.53d307/
!
!  Coefficients for approximation to  erf  in first interval
!
  data a/3.16112374387056560e+00_sp,1.13864154151050156e+02_sp, &
         3.77485237685302021e+02_sp,3.20937758913846947e+03_sp, &
         1.85777706184603153e-1_sp/
  data b/2.36012909523441209e+01_sp,2.44024637934444173e+02_sp, &
         1.28261652607737228e+03_sp,2.84423683343917062e+03_sp/
!
!  Coefficients for approximation to  erfc  in second interval
!
  data c/5.64188496988670089e-1_sp,8.88314979438837594e+00_sp, &
         6.61191906371416295e+01_sp,2.98635138197400131e+02_sp, &
         8.81952221241769090e+02_sp,1.71204761263407058e+03_sp, &
         2.05107837782607147e+03_sp,1.23033935479799725e+03_sp, &
         2.15311535474403846e-8_sp/
  data d/1.57449261107098347e+01_sp,1.17693950891312499e+02_sp, &
         5.37181101862009858e+02_sp,1.62138957456669019e+03_sp, &
         3.29079923573345963e+03_sp,4.36261909014324716e+03_sp, &
         3.43936767414372164e+03_sp,1.23033935480374942e+03_sp/
!
!  Coefficients for approximation to  erfc  in third interval
!
  data p/3.05326634961232344e-1_sp,3.60344899949804439e-1_sp, &
         1.25781726111229246e-1_sp,1.60837851487422766e-2_sp, &
         6.58749161529837803e-4_sp,1.63153871373020978e-2_sp/
  data q/2.56852019228982242e+00_sp,1.87295284992346047e+00_sp, &
         5.27905102951428412e-1_sp,6.05183413124413191e-2_sp, &
         2.33520497626869185e-3_sp/
  x = arg
  y = abs ( x )
!
!  Evaluate erf for |X| <= 0.46875.
!
  if ( y <= thresh ) then

    ysq = zero
    if ( xsmall < y ) then
      ysq = y * y
    end if

    xnum = a(5) * ysq
    xden = ysq

    do i = 1, 3
      xnum = ( xnum + a(i) ) * ysq
      xden = ( xden + b(i) ) * ysq
    end do

    result = x * ( xnum + a(4) ) / ( xden + b(4) )

    if ( jint /= 0 ) then
      result = one - result
    end if

    if ( jint == 2 ) then
      result = exp ( ysq ) * result
    end if

    return
!
!  Evaluate erfc for 0.46875 <= |X| <= 4.0.
!
   else if ( y <= four ) then

     xnum = c(9) * y
     xden = y

     do i = 1, 7
       xnum = ( xnum + c(i) ) * y
       xden = ( xden + d(i) ) * y
     end do

     result = ( xnum + c(8) ) / ( xden + d(8) )

     if ( jint /= 2 ) then
       ysq = aint ( y * sixten ) / sixten
       del = ( y - ysq ) * ( y + ysq )
       result = exp ( -ysq * ysq ) * exp ( -del ) * result
     end if
!
!  Evaluate erfc for 4.0 < |X|.
!
   else

     result = zero

     if ( xbig <= y ) then

       if ( jint /= 2  ) then
         go to 300
       end if

       if ( xhuge <= y ) then
         result = sqrpi / y
         go to 300
       end if

     end if

     ysq = one / ( y * y )
     xnum = p(6) * ysq
     xden = ysq
     do i = 1, 4
       xnum = ( xnum + p(i) ) * ysq
       xden = ( xden + q(i) ) * ysq
      end do

      result = ysq * ( xnum + p(5) ) / ( xden + q(5) )
      result = ( sqrpi -  result ) / y

      if ( jint /= 2 ) then
        ysq = aint ( y * sixten ) / sixten
        del = ( y - ysq ) * ( y + ysq )
        result = exp ( -ysq * ysq ) * exp ( -del ) * result
      end if

  end if
!
!  Fix up for negative argument, erf, etc.
!
  300 continue

  if ( jint == 0 ) then

    result = ( half - result ) + half
    if ( x < zero ) then
      result = -result
    end if

  else if ( jint == 1 ) then

    if ( x < zero ) then
      result = two - result
    end if

  else

    if ( x < zero ) then

      if ( x < xneg ) then
        result = xinf
      else
        ysq = aint ( x * sixten ) / sixten
        del = ( x - ysq ) * ( x + ysq )
        y = exp ( ysq * ysq ) * exp ( del )
        result = ( y + y ) - result
      end if

    end if

  end if

end subroutine calerf


attributes(device) subroutine caljy0 ( arg, result, jint )

!*****************************************************************************80
!
!! CALJY0 computes various J0 and Y0 Bessel functions.
!
!  Discussion:
!
!    This routine computes zero-order Bessel functions of the first and
!    second kind (J0 and Y0), for real arguments X, where 0 < X <= XMAX
!    for Y0, and |X| <= XMAX for J0.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    John Hart, Ward Cheney, Charles Lawson, Hans Maehly,
!    Charles Mesztenyi, John Rice, Henry Thatcher,
!    Christoph Witzgall,
!    Computer Approximations,
!    Wiley, 1968,
!    LC: QA297.C64.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  ARG, the argument.  If JINT = 0, ARG
!    must satisfy
!     -XMAX < ARG < XMAX;
!    If JINT = 1, then ARG must satisfy
!      0 < ARG < XMAX.
!
!    Output, real(kind=sp) ::  RESULT, the value of the function,
!    which depends on the input value of JINT:
!    0, RESULT = J0(x);
!    1, RESULT = Y0(x);
!
!    Input, integer(kind=i4) :: JINT, chooses the function to be computed.
!    0, J0(x);
!    1, Y0(x);
!
  implicit none

  integer(kind=i4) :: i
  integer(kind=i4) :: jint
  real(kind=sp) ::  arg
  real(kind=sp) ::  ax
  real(kind=sp) ::  cons
  real(kind=sp) ::  down
  real(kind=sp) ::  eight
  real(kind=sp) ::  five5
  real(kind=sp) ::  four
  real(kind=sp) ::  one
  real(kind=sp) ::  oneov8
  real(kind=sp) ::  pi2
  real(kind=sp) ::  pj0(7)
  real(kind=sp) ::  pj1(8)
  real(kind=sp) ::  plg(4)
  real(kind=sp) ::  prod
  real(kind=sp) ::  py0(6)
  real(kind=sp) ::  py1(7)
  real(kind=sp) ::  py2(8)
  real(kind=sp) ::  p0(6)
  real(kind=sp) ::  p1(6)
  real(kind=sp) ::  p17
  real(kind=sp) ::  qj0(5)
  real(kind=sp) ::  qj1(7)
  real(kind=sp) ::  qlg(4)
  real(kind=sp) ::  qy0(5)
  real(kind=sp) ::  qy1(6)
  real(kind=sp) ::  qy2(7)
  real(kind=sp) ::  q0(5)
  real(kind=sp) ::  q1(5)
  real(kind=sp) ::  resj
  real(kind=sp) ::  result
  real(kind=sp) ::  r0
  real(kind=sp) ::  r1
  real(kind=sp) ::  sixty4
  real(kind=sp) ::  three
  real(kind=sp) ::  twopi
  real(kind=sp) ::  twopi1
  real(kind=sp) ::  twopi2
  real(kind=sp) ::  two56
  real(kind=sp) ::  up
  real(kind=sp) ::  w
  real(kind=sp) ::  wsq
  real(kind=sp) ::  xden
  real(kind=sp) ::  xinf
  real(kind=sp) ::  xmax
  real(kind=sp) ::  xnum
  real(kind=sp) ::  xsmall
  real(kind=sp) ::  xj0
  real(kind=sp) ::  xj1
  real(kind=sp) ::  xj01
  real(kind=sp) ::  xj02
  real(kind=sp) ::  xj11
  real(kind=sp) ::  xj12
  real(kind=sp) ::  xy
  real(kind=sp) ::  xy0
  real(kind=sp) ::  xy01
  real(kind=sp) ::  xy02
  real(kind=sp) ::  xy1
  real(kind=sp) ::  xy11
  real(kind=sp) ::  xy12
  real(kind=sp) ::  xy2
  real(kind=sp) ::  xy21
  real(kind=sp) ::  xy22
  real(kind=sp) ::  z
  real(kind=sp) ::  zero
  real(kind=sp) ::  zsq
!
!  Mathematical constants
!  CONS = ln(.5) + Euler's gamma
!
  data zero / 0.0_sp /
  data one /1.0_sp  /
  data three /3.0_sp  /
  data four /4.0_sp  /
  data eight /8.0_sp /
  data five5 / 5.5_sp  /
  data sixty4 /64.0_sp  /
  data oneov8 /0.125_sp  /
  data p17 /1.716e-1_sp /
  data two56 /256.0_sp /
  data cons / -1.1593151565841244881e-1_sp /
  data pi2 /6.3661977236758134308e-1_sp /
  data twopi /6.2831853071795864769_sp /
  data twopi1 /6.28125_sp  /
  data twopi2 / 1.9353071795864769253e-3_sp /
!
!  Machine-dependent constants
!
  data xmax /1.07e+09_sp /
  data xsmall /9.31e-10_sp /
  data xinf /1.7e+38_sp /
!
!  Zeroes of Bessel functions
!
  data xj0 /2.4048255576957727686e+0_sp /
  data xj1 /5.5200781102863106496e+0_sp /
  data xy0 /8.9357696627916752158e-1_sp /
  data xy1 /3.9576784193148578684e+0_sp /
  data xy2 /7.0860510603017726976e+0_sp /
  data xj01 / 616.0e+0_sp /
  data xj02 /-1.4244423042272313784e-03_sp /
  data xj11 /1413.0e+0_sp /
  data xj12 / 5.4686028631064959660e-04_sp /
  data xy01 / 228.0e+0_sp /
  data xy02 / 2.9519662791675215849e-03_sp /
  data xy11 /1013.0e+0_sp /
  data xy12 / 6.4716931485786837568e-04_sp/
  data xy21 /1814.0e+0/
  data xy22 / 1.1356030177269762362e-04_sp/
!
!  Coefficients for rational approximation to ln(x/a)
!
  data plg/-2.4562334077563243311e+01_sp,2.3642701335621505212e+02_sp, &
           -5.4989956895857911039e+02_sp,3.5687548468071500413e+02_sp/
  data qlg/-3.5553900764052419184e+01_sp,1.9400230218539473193e+02_sp, &
           -3.3442903192607538956e+02_sp,1.7843774234035750207e+02_sp/
!
!  Coefficients for rational approximation of
!  J0(X) / (X**2 - XJ0**2),  XSMALL < |X| <= 4.0
!
  data pj0/6.6302997904833794242e+06_sp,-6.2140700423540120665e+08_sp, &
           2.7282507878605942706e+10_sp,-4.1298668500990866786e+11_sp, &
          -1.2117036164593528341e-01_sp, 1.0344222815443188943e+02_sp, &
          -3.6629814655107086448e+04_sp/
  data qj0/4.5612696224219938200e+05_sp, 1.3985097372263433271e+08_sp, &
           2.6328198300859648632e+10_sp, 2.3883787996332290397e+12_sp, &
           9.3614022392337710626e+02_sp/
!
!  Coefficients for rational approximation of
!  J0(X) / (X**2 - XJ1**2), 4.0 < |X| <= 8.0
!
  data pj1/4.4176707025325087628e+03_sp, 1.1725046279757103576e+04_sp, &
           1.0341910641583726701e+04_sp,-7.2879702464464618998e+03_sp, &
          -1.2254078161378989535e+04_sp,-1.8319397969392084011e+03_sp, &
           4.8591703355916499363e+01_sp, 7.4321196680624245801e+02_sp/
  data qj1/3.3307310774649071172e+02_sp,-2.9458766545509337327e+03_sp, &
           1.8680990008359188352e+04_sp,-8.4055062591169562211e+04_sp, &
           2.4599102262586308984e+05_sp,-3.5783478026152301072e+05_sp, &
          -2.5258076240801555057e+01_sp/
!
!  Coefficients for rational approximation of
!  (Y0(X) - 2 LN(X/XY0) J0(X)) / (X**2 - XY0**2),
!  XSMALL < |X| <= 3.0
!
  data py0/1.0102532948020907590e+04_sp,-2.1287548474401797963e+06_sp, &
           2.0422274357376619816e+08_sp,-8.3716255451260504098e+09_sp, &
           1.0723538782003176831e+11_sp,-1.8402381979244993524e+01_sp/
  data qy0/6.6475986689240190091e+02_sp, 2.3889393209447253406e+05_sp, &
           5.5662956624278251596e+07_sp, 8.1617187777290363573e+09_sp, &
           5.8873865738997033405e+11_sp/
!
!  Coefficients for rational approximation of
!  (Y0(X) - 2 LN(X/XY1) J0(X)) / (X**2 - XY1**2),
!  3.0 < |X| <= 5.5
!
  data py1/-1.4566865832663635920e+04_sp, 4.6905288611678631510e+06_sp, &
           -6.9590439394619619534e+08_sp, 4.3600098638603061642e+10_sp, &
           -5.5107435206722644429e+11_sp,-2.2213976967566192242e+13_sp, &
            1.7427031242901594547e+01_sp/
  data qy1/ 8.3030857612070288823e+02_sp, 4.0669982352539552018e+05_sp, &
            1.3960202770986831075e+08_sp, 3.4015103849971240096e+10_sp, &
            5.4266824419412347550e+12_sp, 4.3386146580707264428e+14_sp/
!
!  Coefficients for rational approximation of
!  (Y0(X) - 2 LN(X/XY2) J0(X)) / (X**2 - XY2**2),
!  5.5 < |X| <= 8.0
!
  data py2/ 2.1363534169313901632e+04_sp,-1.0085539923498211426e+07_sp, &
            2.1958827170518100757e+09_sp,-1.9363051266772083678e+11_sp, &
           -1.2829912364088687306e+11_sp, 6.7016641869173237784e+14_sp, &
           -8.0728726905150210443e+15_sp,-1.7439661319197499338e+01_sp/
  data qy2/ 8.7903362168128450017e+02_sp, 5.3924739209768057030e+05_sp, &
            2.4727219475672302327e+08_sp, 8.6926121104209825246e+10_sp, &
            2.2598377924042897629e+13_sp, 3.9272425569640309819e+15_sp, &
            3.4563724628846457519e+17_sp/
!
!  Coefficients for Hart,s approximation, 8.0 < |X|.
!
  data p0/3.4806486443249270347e+03_sp, 2.1170523380864944322e+04_sp, &
          4.1345386639580765797e+04_sp, 2.2779090197304684302e+04_sp, &
          8.8961548424210455236e-01_sp, 1.5376201909008354296e+02_sp/
  data q0/3.5028735138235608207e+03_sp, 2.1215350561880115730e+04_sp, &
          4.1370412495510416640e+04_sp, 2.2779090197304684318e+04_sp, &
          1.5711159858080893649e+02_sp/
  data p1/-2.2300261666214198472e+01_sp,-1.1183429920482737611e+02_sp, &
          -1.8591953644342993800e+02_sp,-8.9226600200800094098e+01_sp, &
          -8.8033303048680751817e-03_sp,-1.2441026745835638459e+00_sp/
  data q1/1.4887231232283756582e+03_sp, 7.2642780169211018836e+03_sp, &
          1.1951131543434613647e+04_sp, 5.7105024128512061905e+03_sp, &
          9.0593769594993125859e+01_sp/
!
!  Check for error conditions.
!
  ax = abs ( arg )

  if ( jint == 1 .and. arg <= zero ) then
    result = -xinf
    return
  else if ( xmax < ax ) then
    result = zero
    return
  end if

  if ( eight < ax ) then
    go to 800
  end if

  if ( ax <= xsmall ) then
    if ( jint == 0 ) then
      result = one
    else
      result = pi2 * ( log ( ax ) + cons )
    end if
    return
  end if
!
!  Calculate J0 for appropriate interval, preserving
!  accuracy near the zero of J0.
!
  zsq = ax * ax

  if ( ax <= four ) then
    xnum = ( pj0(5) * zsq + pj0(6) ) * zsq + pj0(7)
    xden = zsq + qj0(5)
    do i = 1, 4
      xnum = xnum * zsq + pj0(i)
      xden = xden * zsq + qj0(i)
    end do
    prod = ( ( ax - xj01 / two56 ) - xj02 ) * ( ax + xj0 )
  else
    wsq = one - zsq / sixty4
    xnum = pj1(7) * wsq + pj1(8)
    xden = wsq + qj1(7)
    do i = 1, 6
      xnum = xnum * wsq + pj1(i)
      xden = xden * wsq + qj1(i)
    end do
    prod = ( ax + xj1 ) * ( ( ax - xj11 / two56 ) - xj12 )
  end if

  result = prod * xnum / xden

  if ( jint == 0 ) then
    return
  end if
!
!  Calculate Y0.  First find  RESJ = pi/2 ln(x/xn) J0(x),
!  where xn is a zero of Y0.
!
  if ( ax <= three ) then
    up = ( ax - xy01 / two56 ) - xy02
    xy = xy0
  else if ( ax <= five5 ) then
    up = ( ax - xy11 / two56 ) - xy12
    xy = xy1
  else
    up = ( ax - xy21 / two56 ) - xy22
    xy = xy2
  end if

  down = ax + xy

  if ( abs ( up ) < p17 * down ) then
    w = up / down
    wsq = w * w
    xnum = plg(1)
    xden = wsq + qlg(1)
    do i = 2, 4
      xnum = xnum * wsq + plg(i)
      xden = xden * wsq + qlg(i)
    end do
    resj = pi2 * result * w * xnum / xden
  else
    resj = pi2 * result * log ( ax / xy )
  end if
!
!  Now calculate Y0 for appropriate interval, preserving
!  accuracy near the zero of Y0.
!
  if ( ax <= three ) then
    xnum = py0(6) * zsq + py0(1)
    xden = zsq + qy0(1)
    do i = 2, 5
      xnum = xnum * zsq + py0(i)
      xden = xden * zsq + qy0(i)
    end do
  else if ( ax <= five5 ) then
    xnum = py1(7) * zsq + py1(1)
    xden = zsq + qy1(1)
    do i = 2, 6
      xnum = xnum * zsq + py1(i)
      xden = xden * zsq + qy1(i)
    end do
  else
    xnum = py2(8) * zsq + py2(1)
    xden = zsq + qy2(1)
    do i = 2, 7
      xnum = xnum * zsq + py2(i)
      xden = xden * zsq + qy2(i)
    end do
  end if

  result = resj + up * down * xnum / xden

  return
!
!  Calculate J0 or Y0 for 8.0 < |ARG|.
!
  800 continue

  z = eight / ax
  w = ax / twopi
  w = aint ( w ) + oneov8
  w = ( ax - w * twopi1 ) - w * twopi2
  zsq = z * z
  xnum = p0(5) * zsq + p0(6)
  xden = zsq + q0(5)
  up = p1(5) * zsq + p1(6)
  down = zsq + q1(5)

  do i = 1, 4
    xnum = xnum * zsq + p0(i)
    xden = xden * zsq + q0(i)
    up = up * zsq + p1(i)
    down = down * zsq + q1(i)
  end do

  r0 = xnum / xden
  r1 = up / down

  if ( jint == 0 ) then
    result = sqrt ( pi2 / ax ) &
      * ( r0 * cos ( w ) - z * r1 * sin ( w ) )
  else
    result = sqrt ( pi2 / ax ) &
      * ( r0 * sin ( w ) + z * r1 * cos ( w ) )
  end if

end subroutine caljy0 


attributes(device) subroutine caljy1 ( arg, result, jint )

!*****************************************************************************80
!
!! CALJY1 computes various J1 and Y1 Bessel functions.
!
!  Discussion:
!
!    This routine computes first-order Bessel functions of the first and
!    second kind (J1 and Y1), for real arguments X, where 0 < X <= XMAX
!    for Y1, and |X| <= XMAX for J1.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    John Hart, Ward Cheney, Charles Lawson, Hans Maehly,
!    Charles Mesztenyi, John Rice, Henry Thatcher,
!    Christoph Witzgall,
!    Computer Approximations,
!    Wiley, 1968,
!    LC: QA297.C64.
!
!  Parameters:
!
!    Input, real(kind=sp) ::  ARG, the argument.  If JINT = 0, ARG
!    must satisfy
!     -XMAX < ARG < XMAX;
!    If JINT = 1, then ARG must satisfy
!      0 < ARG < XMAX.
!
!    Output, real(kind=sp) ::  RESULT, the value of the function,
!    which depends on the input value of JINT:
!    0, RESULT = J1(x);
!    1, RESULT = Y1(x);
!
!    Input, integer(kind=i4) :: JINT, chooses the function to be computed.
!    0, J1(x);
!    1, Y1(x);
!
  implicit none

  real(kind=sp) ::  arg
  real(kind=sp) ::  ax
  real(kind=sp) ::  down
  real(kind=sp) ::  eight
  real(kind=sp) ::  four
  real(kind=sp) ::  half
  integer(kind=i4) :: i
  integer(kind=i4) :: jint
  real(kind=sp) ::  pi2
  real(kind=sp) ::  pj0(7)
  real(kind=sp) ::  pj1(8)
  real(kind=sp) ::  plg(4)
  real(kind=sp) ::  prod
  real(kind=sp) ::  py0(7)
  real(kind=sp) ::  py1(9)
  real(kind=sp) ::  p0(6)
  real(kind=sp) ::  p1(6)
  real(kind=sp) ::  p17
  real(kind=sp) ::  qj0(5)
  real(kind=sp) ::  qj1(7)
  real(kind=sp) ::  qlg(4)
  real(kind=sp) ::  qy0(6)
  real(kind=sp) ::  qy1(8)
  real(kind=sp) ::  q0(6)
  real(kind=sp) ::  q1(6)
  real(kind=sp) ::  resj
  real(kind=sp) ::  result
  real(kind=sp) ::  rtpi2
  real(kind=sp) ::  r0
  real(kind=sp) ::  r1
  real(kind=sp) ::  throv8
  real(kind=sp) ::  twopi
  real(kind=sp) ::  twopi1
  real(kind=sp) ::  twopi2
  real(kind=sp) ::  two56
  real(kind=sp) ::  up
  real(kind=sp) ::  w
  real(kind=sp) ::  wsq
  real(kind=sp) ::  xden
  real(kind=sp) ::  xinf
  real(kind=sp) ::  xmax
  real(kind=sp) ::  xnum
  real(kind=sp) ::  xsmall
  real(kind=sp) ::  xj0
  real(kind=sp) ::  xj1
  real(kind=sp) ::  xj01
  real(kind=sp) ::  xj02
  real(kind=sp) ::  xj11
  real(kind=sp) ::  xj12
  real(kind=sp) ::  xy
  real(kind=sp) ::  xy0
  real(kind=sp) ::  xy01
  real(kind=sp) ::  xy02
  real(kind=sp) ::  xy1
  real(kind=sp) ::  xy11
  real(kind=sp) ::  xy12
  real(kind=sp) ::  z
  real(kind=sp) ::  zero
  real(kind=sp) ::  zsq
!
!  Mathematical constants
!
  data eight /8.0_sp/
  data four /4.0_sp/
  data half /0.5_sp/
  data throv8 /0.375_sp/
  data pi2 /6.3661977236758134308e-1_sp/
  data p17 /1.716e-1_sp/
  data twopi /6.2831853071795864769e+0_sp/
  data zero /0.0_sp/
  data twopi1 /6.28125_sp/
  data twopi2 /1.9353071795864769253e-03_sp/
  data two56 /256.0e+0_sp/
  data rtpi2 /7.9788456080286535588e-1_sp/
!
!  Machine-dependent constants
!
  data xmax /1.07e+09_sp/
  data xsmall /9.31e-10_sp/
  data xinf /1.7e+38_sp/
!
!  Zeroes of Bessel functions
!
  data xj0 /3.8317059702075123156e+0_sp/
  data xj1 /7.0155866698156187535e+0_sp/
  data xy0 /2.1971413260310170351e+0_sp/
  data xy1 /5.4296810407941351328e+0_sp/
  data xj01 / 981.0e+0_sp/
  data xj02 /-3.2527979248768438556e-04_sp/
  data xj11 /1796.0e+0_sp/
  data xj12 /-3.8330184381246462950e-05_sp/
  data xy01 / 562.0e+0_sp/
  data xy02 / 1.8288260310170351490e-03_sp/
  data xy11 /1390.0e+0_sp/
  data xy12 /-6.4592058648672279948e-06_sp/
!
!  Coefficients for rational approximation to ln(x/a)
!
  data plg/-2.4562334077563243311e+01_sp,2.3642701335621505212e+02_sp, &
           -5.4989956895857911039e+02_sp,3.5687548468071500413e+02_sp/
  data qlg/-3.5553900764052419184e+01_sp,1.9400230218539473193e+02_sp, &
           -3.3442903192607538956e+02_sp,1.7843774234035750207e+02_sp/
!
!  Coefficients for rational approximation of
!  J1(X) / (X * (X**2 - XJ0**2)), XSMALL < |X| <=  4.0
!
  data pj0/9.8062904098958257677e+05_sp,-1.1548696764841276794e+08_sp, &
         6.6781041261492395835e+09_sp,-1.4258509801366645672e+11_sp, &
        -4.4615792982775076130e+03_sp, 1.0650724020080236441e+01_sp, &
        -1.0767857011487300348e-02_sp/
  data qj0/5.9117614494174794095e+05_sp, 2.0228375140097033958e+08_sp, &
         4.2091902282580133541e+10_sp, 4.1868604460820175290e+12_sp, &
         1.0742272239517380498e+03_sp/
!
!  Coefficients for rational approximation of
!  J1(X) / (X * (X**2 - XJ1**2)), 4.0 < |X| <= 8.0
!
  data pj1/4.6179191852758252280e+00_sp,-7.1329006872560947377e+03_sp, &
         4.5039658105749078904e+06_sp,-1.4437717718363239107e+09_sp, &
         2.3569285397217157313e+11_sp,-1.6324168293282543629e+13_sp, &
         1.1357022719979468624e+14_sp, 1.0051899717115285432e+15_sp/
  data qj1/1.1267125065029138050e+06_sp, 6.4872502899596389593e+08_sp, &
         2.7622777286244082666e+11_sp, 8.4899346165481429307e+13_sp, &
         1.7128800897135812012e+16_sp, 1.7253905888447681194e+18_sp, &
         1.3886978985861357615e+03_sp/
!
!  Coefficients for rational approximation of
!  (Y1(X) - 2 LN(X/XY0) J1(X)) / (X**2 - XY0**2),
!  XSMALL < |X| <=  4.0
!
  data py0/2.2157953222280260820e+05_sp,-5.9157479997408395984e+07_sp, &
           7.2144548214502560419e+09_sp,-3.7595974497819597599e+11_sp, &
           5.4708611716525426053e+12_sp, 4.0535726612579544093e+13_sp, &
          -3.1714424660046133456e+02_sp/
  data qy0/8.2079908168393867438e+02_sp, 3.8136470753052572164e+05_sp, &
           1.2250435122182963220e+08_sp, 2.7800352738690585613e+10_sp, &
           4.1272286200406461981e+12_sp, 3.0737873921079286084e+14_sp/
!
!  Coefficients for rational approximation of
!  (Y1(X) - 2 LN(X/XY1) J1(X)) / (X**2 - XY1**2),
!  4.0 < |X| <= 8.0
!
  data py1/ 1.9153806858264202986e+06_sp,-1.1957961912070617006e+09_sp, &
            3.7453673962438488783e+11_sp,-5.9530713129741981618e+13_sp, &
            4.0686275289804744814e+15_sp,-2.3638408497043134724e+16_sp, &
           -5.6808094574724204577e+18_sp, 1.1514276357909013326e+19_sp, &
           -1.2337180442012953128e+03_sp/
  data qy1/ 1.2855164849321609336e+03, 1.0453748201934079734e+06, &
            6.3550318087088919566e+08, 3.0221766852960403645e+11, &
            1.1187010065856971027e+14, 3.0837179548112881950e+16, &
            5.6968198822857178911e+18, 5.3321844313316185697e+20/
!
!  Coefficients for Hart's approximation, 8.0 < |X|.
!
  data p0/-1.0982405543459346727e+05_sp,-1.5235293511811373833e+06_sp, &
           -6.6033732483649391093e+06_sp,-9.9422465050776411957e+06_sp, &
           -4.4357578167941278571e+06_sp,-1.6116166443246101165e+03_sp/
  data q0/-1.0726385991103820119e+05_sp,-1.5118095066341608816e+06_sp, &
           -6.5853394797230870728e+06_sp,-9.9341243899345856590e+06_sp, &
           -4.4357578167941278568e+06_sp,-1.4550094401904961825e+03_sp/
  data p1/ 1.7063754290207680021e+03_sp, 1.8494262873223866797e+04_sp, &
            6.6178836581270835179e+04_sp, 8.5145160675335701966e+04_sp, &
            3.3220913409857223519e+04_sp, 3.5265133846636032186e+01_sp/
  data q1/ 3.7890229745772202641e+04_sp, 4.0029443582266975117e+05_sp, &
            1.4194606696037208929e+06_sp, 1.8194580422439972989e+06_sp, &
            7.0871281941028743574e+05_sp, 8.6383677696049909675e+02_sp/
!
!  Check for error conditions.
!
  ax = abs ( arg )

  if ( jint == 1 .and. ( arg <= zero .or. &
    ( arg < half .and. ax * xinf < pi2 ) ) ) then
    result = -xinf
    return
  else if ( xmax < ax ) then
    result = zero
    return
  end if

  if ( eight < ax ) then
    go to 800
  else if ( ax <= xsmall ) then
    if ( jint == 0 ) then
      result = arg * half
    else
      result = -pi2 / ax
    end if
    return
  end if
!
!  Calculate J1 for appropriate interval, preserving
!  accuracy near the zero of J1.
!
  zsq = ax * ax

  if ( ax <= four ) then
    xnum = ( pj0(7) * zsq + pj0(6) ) * zsq + pj0(5)
    xden = zsq + qj0(5)
    do i = 1, 4
      xnum = xnum * zsq + pj0(i)
      xden = xden * zsq + qj0(i)
    end do
    prod = arg * ( ( ax - xj01 / two56 ) - xj02 ) * ( ax + xj0 )
  else
    xnum = pj1(1)
    xden = ( zsq + qj1(7) ) * zsq + qj1(1)
    do i = 2, 6
      xnum = xnum * zsq + pj1(i)
      xden = xden * zsq + qj1(i)
    end do
    xnum = xnum * ( ax - eight ) * ( ax + eight ) + pj1(7)
    xnum = xnum * ( ax - four ) * ( ax + four ) + pj1(8)
    prod = arg * ( ( ax - xj11 / two56 ) - xj12 ) * ( ax + xj1 )
  end if

  result = prod * ( xnum / xden )

  if ( jint == 0 ) then
    return
  end if
!
!  Calculate Y1.  First find RESJ = pi/2 ln(x/xn) J1(x),
!  where xn is a zero of Y1.
!
  if ( ax <= four ) then
    up = ( ax - xy01 / two56 ) - xy02
    xy = xy0
  else
    up = ( ax - xy11 / two56 ) - xy12
    xy = xy1
  end if

  down = ax + xy

  if ( abs ( up ) < p17 * down ) then
    w = up / down
    wsq = w * w
    xnum = plg(1)
    xden = wsq + qlg(1)
    do i = 2, 4
      xnum = xnum * wsq + plg(i)
      xden = xden * wsq + qlg(i)
    end do
    resj = pi2 * result * w * xnum / xden
  else
    resj = pi2 * result * log ( ax / xy )
  end if
!
!  Now calculate Y1 for appropriate interval, preserving
!  accuracy near the zero of Y1.
!
  if ( ax <= four ) then
    xnum = py0(7) * zsq + py0(1)
    xden = zsq + qy0(1)
    do i = 2, 6
      xnum = xnum * zsq + py0(i)
      xden = xden * zsq + qy0(i)
    end do
  else
    xnum = py1(9) * zsq + py1(1)
    xden = zsq + qy1(1)
    do i = 2, 8
      xnum = xnum * zsq + py1(i)
      xden = xden * zsq + qy1(i)
    end do
  end if

  result = resj + ( up * down / ax ) * xnum / xden
  return
!
!  Calculate J1 or Y1 for 8.0 < |ARG|.
!
  800 continue

  z = eight / ax
  w = aint ( ax / twopi ) + throv8
  w = ( ax - w * twopi1 ) - w * twopi2
  zsq = z * z
  xnum = p0(6)
  xden = zsq + q0(6)
  up = p1(6)
  down = zsq + q1(6)

  do i = 1, 5
    xnum = xnum * zsq + p0(i)
    xden = xden * zsq + q0(i)
    up = up * zsq + p1(i)
    down = down * zsq + q1(i)
  end do

  r0 = xnum / xden
  r1 = up / down

  if ( jint == 0 ) then
    result = ( rtpi2 / sqrt ( ax ) ) &
      * ( r0 * cos ( w ) - z * r1 * sin ( w ) )
  else
    result = ( rtpi2 / sqrt ( ax ) ) &
      * ( r0 * sin ( w ) + z * r1 * cos ( w ) )
  end if

  if ( jint == 0 .and. arg < zero ) then
    result = -result
  end if

end







end module specfuncs_cuda
